/**
 * NOTE: This class is auto generated by the akka-scala (beta) swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * For any issue or feedback, please open a ticket via https://github.com/swagger-api/swagger-codegen/issues/new
 */
package io.swagger.client.api

import io.swagger.client.model.IoK8sApiAutoscalingV1Scale
import io.swagger.client.model.IoK8sApiCoreV1Binding
import io.swagger.client.model.IoK8sApiCoreV1ComponentStatus
import io.swagger.client.model.IoK8sApiCoreV1ComponentStatusList
import io.swagger.client.model.IoK8sApiCoreV1ConfigMap
import io.swagger.client.model.IoK8sApiCoreV1ConfigMapList
import io.swagger.client.model.IoK8sApiCoreV1Endpoints
import io.swagger.client.model.IoK8sApiCoreV1EndpointsList
import io.swagger.client.model.IoK8sApiCoreV1Event
import io.swagger.client.model.IoK8sApiCoreV1EventList
import io.swagger.client.model.IoK8sApiCoreV1LimitRange
import io.swagger.client.model.IoK8sApiCoreV1LimitRangeList
import io.swagger.client.model.IoK8sApiCoreV1Namespace
import io.swagger.client.model.IoK8sApiCoreV1NamespaceList
import io.swagger.client.model.IoK8sApiCoreV1Node
import io.swagger.client.model.IoK8sApiCoreV1NodeList
import io.swagger.client.model.IoK8sApiCoreV1PersistentVolume
import io.swagger.client.model.IoK8sApiCoreV1PersistentVolumeClaim
import io.swagger.client.model.IoK8sApiCoreV1PersistentVolumeClaimList
import io.swagger.client.model.IoK8sApiCoreV1PersistentVolumeList
import io.swagger.client.model.IoK8sApiCoreV1Pod
import io.swagger.client.model.IoK8sApiCoreV1PodList
import io.swagger.client.model.IoK8sApiCoreV1PodTemplate
import io.swagger.client.model.IoK8sApiCoreV1PodTemplateList
import io.swagger.client.model.IoK8sApiCoreV1ReplicationController
import io.swagger.client.model.IoK8sApiCoreV1ReplicationControllerList
import io.swagger.client.model.IoK8sApiCoreV1ResourceQuota
import io.swagger.client.model.IoK8sApiCoreV1ResourceQuotaList
import io.swagger.client.model.IoK8sApiCoreV1Secret
import io.swagger.client.model.IoK8sApiCoreV1SecretList
import io.swagger.client.model.IoK8sApiCoreV1Service
import io.swagger.client.model.IoK8sApiCoreV1ServiceAccount
import io.swagger.client.model.IoK8sApiCoreV1ServiceAccountList
import io.swagger.client.model.IoK8sApiCoreV1ServiceList
import io.swagger.client.model.IoK8sApiPolicyV1beta1Eviction
import io.swagger.client.model.IoK8sApimachineryPkgApisMetaV1APIResourceList
import io.swagger.client.model.IoK8sApimachineryPkgApisMetaV1DeleteOptions
import io.swagger.client.model.IoK8sApimachineryPkgApisMetaV1Patch
import io.swagger.client.model.IoK8sApimachineryPkgApisMetaV1Status
import io.swagger.client.model.IoK8sApimachineryPkgApisMetaV1WatchEvent
import io.swagger.client.core._
import io.swagger.client.core.CollectionFormats._
import io.swagger.client.core.ApiKeyLocations._

object Core_v1Api {

  /**
   * connect DELETE requests to proxy of Pod
   * 
   * Expected answers:
   *   code 200 : String (OK)
   *   code 401 :  (Unauthorized)
   * 
   * Available security schemes:
   *   BearerToken (apiKey)
   * 
   * @param name name of the Pod
   * @param namespace object name and auth scope, such as for teams and projects
   * @param path Path is the URL path to use for the current proxy request to pod.
   */
  def connectCoreV1DeleteNamespacedPodProxy(name: String, namespace: String, path: Option[String] = None)(implicit apiKey: ApiKeyValue): ApiRequest[String] =
    ApiRequest[String](ApiMethods.DELETE, "https://localhost", "/api/v1/namespaces/{namespace}/pods/{name}/proxy", "*/*")
      .withApiKey(apiKey, "authorization", HEADER)
      .withQueryParam("path", path)
      .withPathParam("name", name)
      .withPathParam("namespace", namespace)
      .withSuccessResponse[String](200)
      .withErrorResponse[Unit](401)
        /**
   * connect DELETE requests to proxy of Pod
   * 
   * Expected answers:
   *   code 200 : String (OK)
   *   code 401 :  (Unauthorized)
   * 
   * Available security schemes:
   *   BearerToken (apiKey)
   * 
   * @param name name of the Pod
   * @param namespace object name and auth scope, such as for teams and projects
   * @param path path to the resource
   * @param path2 Path is the URL path to use for the current proxy request to pod.
   */
  def connectCoreV1DeleteNamespacedPodProxyWithPath(name: String, namespace: String, path: String, path2: Option[String] = None)(implicit apiKey: ApiKeyValue): ApiRequest[String] =
    ApiRequest[String](ApiMethods.DELETE, "https://localhost", "/api/v1/namespaces/{namespace}/pods/{name}/proxy/{path}", "*/*")
      .withApiKey(apiKey, "authorization", HEADER)
      .withQueryParam("path", path2)
      .withPathParam("name", name)
      .withPathParam("namespace", namespace)
      .withPathParam("path", path)
      .withSuccessResponse[String](200)
      .withErrorResponse[Unit](401)
        /**
   * connect DELETE requests to proxy of Service
   * 
   * Expected answers:
   *   code 200 : String (OK)
   *   code 401 :  (Unauthorized)
   * 
   * Available security schemes:
   *   BearerToken (apiKey)
   * 
   * @param name name of the Service
   * @param namespace object name and auth scope, such as for teams and projects
   * @param path Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q&#x3D;user:kimchy. Path is _search?q&#x3D;user:kimchy.
   */
  def connectCoreV1DeleteNamespacedServiceProxy(name: String, namespace: String, path: Option[String] = None)(implicit apiKey: ApiKeyValue): ApiRequest[String] =
    ApiRequest[String](ApiMethods.DELETE, "https://localhost", "/api/v1/namespaces/{namespace}/services/{name}/proxy", "*/*")
      .withApiKey(apiKey, "authorization", HEADER)
      .withQueryParam("path", path)
      .withPathParam("name", name)
      .withPathParam("namespace", namespace)
      .withSuccessResponse[String](200)
      .withErrorResponse[Unit](401)
        /**
   * connect DELETE requests to proxy of Service
   * 
   * Expected answers:
   *   code 200 : String (OK)
   *   code 401 :  (Unauthorized)
   * 
   * Available security schemes:
   *   BearerToken (apiKey)
   * 
   * @param name name of the Service
   * @param namespace object name and auth scope, such as for teams and projects
   * @param path path to the resource
   * @param path2 Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q&#x3D;user:kimchy. Path is _search?q&#x3D;user:kimchy.
   */
  def connectCoreV1DeleteNamespacedServiceProxyWithPath(name: String, namespace: String, path: String, path2: Option[String] = None)(implicit apiKey: ApiKeyValue): ApiRequest[String] =
    ApiRequest[String](ApiMethods.DELETE, "https://localhost", "/api/v1/namespaces/{namespace}/services/{name}/proxy/{path}", "*/*")
      .withApiKey(apiKey, "authorization", HEADER)
      .withQueryParam("path", path2)
      .withPathParam("name", name)
      .withPathParam("namespace", namespace)
      .withPathParam("path", path)
      .withSuccessResponse[String](200)
      .withErrorResponse[Unit](401)
        /**
   * connect DELETE requests to proxy of Node
   * 
   * Expected answers:
   *   code 200 : String (OK)
   *   code 401 :  (Unauthorized)
   * 
   * Available security schemes:
   *   BearerToken (apiKey)
   * 
   * @param name name of the Node
   * @param path Path is the URL path to use for the current proxy request to node.
   */
  def connectCoreV1DeleteNodeProxy(name: String, path: Option[String] = None)(implicit apiKey: ApiKeyValue): ApiRequest[String] =
    ApiRequest[String](ApiMethods.DELETE, "https://localhost", "/api/v1/nodes/{name}/proxy", "*/*")
      .withApiKey(apiKey, "authorization", HEADER)
      .withQueryParam("path", path)
      .withPathParam("name", name)
      .withSuccessResponse[String](200)
      .withErrorResponse[Unit](401)
        /**
   * connect DELETE requests to proxy of Node
   * 
   * Expected answers:
   *   code 200 : String (OK)
   *   code 401 :  (Unauthorized)
   * 
   * Available security schemes:
   *   BearerToken (apiKey)
   * 
   * @param name name of the Node
   * @param path path to the resource
   * @param path2 Path is the URL path to use for the current proxy request to node.
   */
  def connectCoreV1DeleteNodeProxyWithPath(name: String, path: String, path2: Option[String] = None)(implicit apiKey: ApiKeyValue): ApiRequest[String] =
    ApiRequest[String](ApiMethods.DELETE, "https://localhost", "/api/v1/nodes/{name}/proxy/{path}", "*/*")
      .withApiKey(apiKey, "authorization", HEADER)
      .withQueryParam("path", path2)
      .withPathParam("name", name)
      .withPathParam("path", path)
      .withSuccessResponse[String](200)
      .withErrorResponse[Unit](401)
        /**
   * connect GET requests to attach of Pod
   * 
   * Expected answers:
   *   code 200 : String (OK)
   *   code 401 :  (Unauthorized)
   * 
   * Available security schemes:
   *   BearerToken (apiKey)
   * 
   * @param name name of the Pod
   * @param namespace object name and auth scope, such as for teams and projects
   * @param container The container in which to execute the command. Defaults to only container if there is only one container in the pod.
   * @param stderr Stderr if true indicates that stderr is to be redirected for the attach call. Defaults to true.
   * @param stdin Stdin if true, redirects the standard input stream of the pod for this call. Defaults to false.
   * @param stdout Stdout if true indicates that stdout is to be redirected for the attach call. Defaults to true.
   * @param tty TTY if true indicates that a tty will be allocated for the attach call. This is passed through the container runtime so the tty is allocated on the worker node by the container runtime. Defaults to false.
   */
  def connectCoreV1GetNamespacedPodAttach(name: String, namespace: String, container: Option[String] = None, stderr: Option[Boolean] = None, stdin: Option[Boolean] = None, stdout: Option[Boolean] = None, tty: Option[Boolean] = None)(implicit apiKey: ApiKeyValue): ApiRequest[String] =
    ApiRequest[String](ApiMethods.GET, "https://localhost", "/api/v1/namespaces/{namespace}/pods/{name}/attach", "*/*")
      .withApiKey(apiKey, "authorization", HEADER)
      .withQueryParam("container", container)
      .withQueryParam("stderr", stderr)
      .withQueryParam("stdin", stdin)
      .withQueryParam("stdout", stdout)
      .withQueryParam("tty", tty)
      .withPathParam("name", name)
      .withPathParam("namespace", namespace)
      .withSuccessResponse[String](200)
      .withErrorResponse[Unit](401)
        /**
   * connect GET requests to exec of Pod
   * 
   * Expected answers:
   *   code 200 : String (OK)
   *   code 401 :  (Unauthorized)
   * 
   * Available security schemes:
   *   BearerToken (apiKey)
   * 
   * @param name name of the Pod
   * @param namespace object name and auth scope, such as for teams and projects
   * @param command Command is the remote command to execute. argv array. Not executed within a shell.
   * @param container Container in which to execute the command. Defaults to only container if there is only one container in the pod.
   * @param stderr Redirect the standard error stream of the pod for this call. Defaults to true.
   * @param stdin Redirect the standard input stream of the pod for this call. Defaults to false.
   * @param stdout Redirect the standard output stream of the pod for this call. Defaults to true.
   * @param tty TTY if true indicates that a tty will be allocated for the exec call. Defaults to false.
   */
  def connectCoreV1GetNamespacedPodExec(name: String, namespace: String, command: Option[String] = None, container: Option[String] = None, stderr: Option[Boolean] = None, stdin: Option[Boolean] = None, stdout: Option[Boolean] = None, tty: Option[Boolean] = None)(implicit apiKey: ApiKeyValue): ApiRequest[String] =
    ApiRequest[String](ApiMethods.GET, "https://localhost", "/api/v1/namespaces/{namespace}/pods/{name}/exec", "*/*")
      .withApiKey(apiKey, "authorization", HEADER)
      .withQueryParam("command", command)
      .withQueryParam("container", container)
      .withQueryParam("stderr", stderr)
      .withQueryParam("stdin", stdin)
      .withQueryParam("stdout", stdout)
      .withQueryParam("tty", tty)
      .withPathParam("name", name)
      .withPathParam("namespace", namespace)
      .withSuccessResponse[String](200)
      .withErrorResponse[Unit](401)
        /**
   * connect GET requests to portforward of Pod
   * 
   * Expected answers:
   *   code 200 : String (OK)
   *   code 401 :  (Unauthorized)
   * 
   * Available security schemes:
   *   BearerToken (apiKey)
   * 
   * @param name name of the Pod
   * @param namespace object name and auth scope, such as for teams and projects
   * @param ports List of ports to forward Required when using WebSockets
   */
  def connectCoreV1GetNamespacedPodPortforward(name: String, namespace: String, ports: Option[Int] = None)(implicit apiKey: ApiKeyValue): ApiRequest[String] =
    ApiRequest[String](ApiMethods.GET, "https://localhost", "/api/v1/namespaces/{namespace}/pods/{name}/portforward", "*/*")
      .withApiKey(apiKey, "authorization", HEADER)
      .withQueryParam("ports", ports)
      .withPathParam("name", name)
      .withPathParam("namespace", namespace)
      .withSuccessResponse[String](200)
      .withErrorResponse[Unit](401)
        /**
   * connect GET requests to proxy of Pod
   * 
   * Expected answers:
   *   code 200 : String (OK)
   *   code 401 :  (Unauthorized)
   * 
   * Available security schemes:
   *   BearerToken (apiKey)
   * 
   * @param name name of the Pod
   * @param namespace object name and auth scope, such as for teams and projects
   * @param path Path is the URL path to use for the current proxy request to pod.
   */
  def connectCoreV1GetNamespacedPodProxy(name: String, namespace: String, path: Option[String] = None)(implicit apiKey: ApiKeyValue): ApiRequest[String] =
    ApiRequest[String](ApiMethods.GET, "https://localhost", "/api/v1/namespaces/{namespace}/pods/{name}/proxy", "*/*")
      .withApiKey(apiKey, "authorization", HEADER)
      .withQueryParam("path", path)
      .withPathParam("name", name)
      .withPathParam("namespace", namespace)
      .withSuccessResponse[String](200)
      .withErrorResponse[Unit](401)
        /**
   * connect GET requests to proxy of Pod
   * 
   * Expected answers:
   *   code 200 : String (OK)
   *   code 401 :  (Unauthorized)
   * 
   * Available security schemes:
   *   BearerToken (apiKey)
   * 
   * @param name name of the Pod
   * @param namespace object name and auth scope, such as for teams and projects
   * @param path path to the resource
   * @param path2 Path is the URL path to use for the current proxy request to pod.
   */
  def connectCoreV1GetNamespacedPodProxyWithPath(name: String, namespace: String, path: String, path2: Option[String] = None)(implicit apiKey: ApiKeyValue): ApiRequest[String] =
    ApiRequest[String](ApiMethods.GET, "https://localhost", "/api/v1/namespaces/{namespace}/pods/{name}/proxy/{path}", "*/*")
      .withApiKey(apiKey, "authorization", HEADER)
      .withQueryParam("path", path2)
      .withPathParam("name", name)
      .withPathParam("namespace", namespace)
      .withPathParam("path", path)
      .withSuccessResponse[String](200)
      .withErrorResponse[Unit](401)
        /**
   * connect GET requests to proxy of Service
   * 
   * Expected answers:
   *   code 200 : String (OK)
   *   code 401 :  (Unauthorized)
   * 
   * Available security schemes:
   *   BearerToken (apiKey)
   * 
   * @param name name of the Service
   * @param namespace object name and auth scope, such as for teams and projects
   * @param path Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q&#x3D;user:kimchy. Path is _search?q&#x3D;user:kimchy.
   */
  def connectCoreV1GetNamespacedServiceProxy(name: String, namespace: String, path: Option[String] = None)(implicit apiKey: ApiKeyValue): ApiRequest[String] =
    ApiRequest[String](ApiMethods.GET, "https://localhost", "/api/v1/namespaces/{namespace}/services/{name}/proxy", "*/*")
      .withApiKey(apiKey, "authorization", HEADER)
      .withQueryParam("path", path)
      .withPathParam("name", name)
      .withPathParam("namespace", namespace)
      .withSuccessResponse[String](200)
      .withErrorResponse[Unit](401)
        /**
   * connect GET requests to proxy of Service
   * 
   * Expected answers:
   *   code 200 : String (OK)
   *   code 401 :  (Unauthorized)
   * 
   * Available security schemes:
   *   BearerToken (apiKey)
   * 
   * @param name name of the Service
   * @param namespace object name and auth scope, such as for teams and projects
   * @param path path to the resource
   * @param path2 Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q&#x3D;user:kimchy. Path is _search?q&#x3D;user:kimchy.
   */
  def connectCoreV1GetNamespacedServiceProxyWithPath(name: String, namespace: String, path: String, path2: Option[String] = None)(implicit apiKey: ApiKeyValue): ApiRequest[String] =
    ApiRequest[String](ApiMethods.GET, "https://localhost", "/api/v1/namespaces/{namespace}/services/{name}/proxy/{path}", "*/*")
      .withApiKey(apiKey, "authorization", HEADER)
      .withQueryParam("path", path2)
      .withPathParam("name", name)
      .withPathParam("namespace", namespace)
      .withPathParam("path", path)
      .withSuccessResponse[String](200)
      .withErrorResponse[Unit](401)
        /**
   * connect GET requests to proxy of Node
   * 
   * Expected answers:
   *   code 200 : String (OK)
   *   code 401 :  (Unauthorized)
   * 
   * Available security schemes:
   *   BearerToken (apiKey)
   * 
   * @param name name of the Node
   * @param path Path is the URL path to use for the current proxy request to node.
   */
  def connectCoreV1GetNodeProxy(name: String, path: Option[String] = None)(implicit apiKey: ApiKeyValue): ApiRequest[String] =
    ApiRequest[String](ApiMethods.GET, "https://localhost", "/api/v1/nodes/{name}/proxy", "*/*")
      .withApiKey(apiKey, "authorization", HEADER)
      .withQueryParam("path", path)
      .withPathParam("name", name)
      .withSuccessResponse[String](200)
      .withErrorResponse[Unit](401)
        /**
   * connect GET requests to proxy of Node
   * 
   * Expected answers:
   *   code 200 : String (OK)
   *   code 401 :  (Unauthorized)
   * 
   * Available security schemes:
   *   BearerToken (apiKey)
   * 
   * @param name name of the Node
   * @param path path to the resource
   * @param path2 Path is the URL path to use for the current proxy request to node.
   */
  def connectCoreV1GetNodeProxyWithPath(name: String, path: String, path2: Option[String] = None)(implicit apiKey: ApiKeyValue): ApiRequest[String] =
    ApiRequest[String](ApiMethods.GET, "https://localhost", "/api/v1/nodes/{name}/proxy/{path}", "*/*")
      .withApiKey(apiKey, "authorization", HEADER)
      .withQueryParam("path", path2)
      .withPathParam("name", name)
      .withPathParam("path", path)
      .withSuccessResponse[String](200)
      .withErrorResponse[Unit](401)
        /**
   * connect HEAD requests to proxy of Pod
   * 
   * Expected answers:
   *   code 200 : String (OK)
   *   code 401 :  (Unauthorized)
   * 
   * Available security schemes:
   *   BearerToken (apiKey)
   * 
   * @param name name of the Pod
   * @param namespace object name and auth scope, such as for teams and projects
   * @param path Path is the URL path to use for the current proxy request to pod.
   */
  def connectCoreV1HeadNamespacedPodProxy(name: String, namespace: String, path: Option[String] = None)(implicit apiKey: ApiKeyValue): ApiRequest[String] =
    ApiRequest[String](ApiMethods.HEAD, "https://localhost", "/api/v1/namespaces/{namespace}/pods/{name}/proxy", "*/*")
      .withApiKey(apiKey, "authorization", HEADER)
      .withQueryParam("path", path)
      .withPathParam("name", name)
      .withPathParam("namespace", namespace)
      .withSuccessResponse[String](200)
      .withErrorResponse[Unit](401)
        /**
   * connect HEAD requests to proxy of Pod
   * 
   * Expected answers:
   *   code 200 : String (OK)
   *   code 401 :  (Unauthorized)
   * 
   * Available security schemes:
   *   BearerToken (apiKey)
   * 
   * @param name name of the Pod
   * @param namespace object name and auth scope, such as for teams and projects
   * @param path path to the resource
   * @param path2 Path is the URL path to use for the current proxy request to pod.
   */
  def connectCoreV1HeadNamespacedPodProxyWithPath(name: String, namespace: String, path: String, path2: Option[String] = None)(implicit apiKey: ApiKeyValue): ApiRequest[String] =
    ApiRequest[String](ApiMethods.HEAD, "https://localhost", "/api/v1/namespaces/{namespace}/pods/{name}/proxy/{path}", "*/*")
      .withApiKey(apiKey, "authorization", HEADER)
      .withQueryParam("path", path2)
      .withPathParam("name", name)
      .withPathParam("namespace", namespace)
      .withPathParam("path", path)
      .withSuccessResponse[String](200)
      .withErrorResponse[Unit](401)
        /**
   * connect HEAD requests to proxy of Service
   * 
   * Expected answers:
   *   code 200 : String (OK)
   *   code 401 :  (Unauthorized)
   * 
   * Available security schemes:
   *   BearerToken (apiKey)
   * 
   * @param name name of the Service
   * @param namespace object name and auth scope, such as for teams and projects
   * @param path Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q&#x3D;user:kimchy. Path is _search?q&#x3D;user:kimchy.
   */
  def connectCoreV1HeadNamespacedServiceProxy(name: String, namespace: String, path: Option[String] = None)(implicit apiKey: ApiKeyValue): ApiRequest[String] =
    ApiRequest[String](ApiMethods.HEAD, "https://localhost", "/api/v1/namespaces/{namespace}/services/{name}/proxy", "*/*")
      .withApiKey(apiKey, "authorization", HEADER)
      .withQueryParam("path", path)
      .withPathParam("name", name)
      .withPathParam("namespace", namespace)
      .withSuccessResponse[String](200)
      .withErrorResponse[Unit](401)
        /**
   * connect HEAD requests to proxy of Service
   * 
   * Expected answers:
   *   code 200 : String (OK)
   *   code 401 :  (Unauthorized)
   * 
   * Available security schemes:
   *   BearerToken (apiKey)
   * 
   * @param name name of the Service
   * @param namespace object name and auth scope, such as for teams and projects
   * @param path path to the resource
   * @param path2 Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q&#x3D;user:kimchy. Path is _search?q&#x3D;user:kimchy.
   */
  def connectCoreV1HeadNamespacedServiceProxyWithPath(name: String, namespace: String, path: String, path2: Option[String] = None)(implicit apiKey: ApiKeyValue): ApiRequest[String] =
    ApiRequest[String](ApiMethods.HEAD, "https://localhost", "/api/v1/namespaces/{namespace}/services/{name}/proxy/{path}", "*/*")
      .withApiKey(apiKey, "authorization", HEADER)
      .withQueryParam("path", path2)
      .withPathParam("name", name)
      .withPathParam("namespace", namespace)
      .withPathParam("path", path)
      .withSuccessResponse[String](200)
      .withErrorResponse[Unit](401)
        /**
   * connect HEAD requests to proxy of Node
   * 
   * Expected answers:
   *   code 200 : String (OK)
   *   code 401 :  (Unauthorized)
   * 
   * Available security schemes:
   *   BearerToken (apiKey)
   * 
   * @param name name of the Node
   * @param path Path is the URL path to use for the current proxy request to node.
   */
  def connectCoreV1HeadNodeProxy(name: String, path: Option[String] = None)(implicit apiKey: ApiKeyValue): ApiRequest[String] =
    ApiRequest[String](ApiMethods.HEAD, "https://localhost", "/api/v1/nodes/{name}/proxy", "*/*")
      .withApiKey(apiKey, "authorization", HEADER)
      .withQueryParam("path", path)
      .withPathParam("name", name)
      .withSuccessResponse[String](200)
      .withErrorResponse[Unit](401)
        /**
   * connect HEAD requests to proxy of Node
   * 
   * Expected answers:
   *   code 200 : String (OK)
   *   code 401 :  (Unauthorized)
   * 
   * Available security schemes:
   *   BearerToken (apiKey)
   * 
   * @param name name of the Node
   * @param path path to the resource
   * @param path2 Path is the URL path to use for the current proxy request to node.
   */
  def connectCoreV1HeadNodeProxyWithPath(name: String, path: String, path2: Option[String] = None)(implicit apiKey: ApiKeyValue): ApiRequest[String] =
    ApiRequest[String](ApiMethods.HEAD, "https://localhost", "/api/v1/nodes/{name}/proxy/{path}", "*/*")
      .withApiKey(apiKey, "authorization", HEADER)
      .withQueryParam("path", path2)
      .withPathParam("name", name)
      .withPathParam("path", path)
      .withSuccessResponse[String](200)
      .withErrorResponse[Unit](401)
        /**
   * connect OPTIONS requests to proxy of Pod
   * 
   * Expected answers:
   *   code 200 : String (OK)
   *   code 401 :  (Unauthorized)
   * 
   * Available security schemes:
   *   BearerToken (apiKey)
   * 
   * @param name name of the Pod
   * @param namespace object name and auth scope, such as for teams and projects
   * @param path Path is the URL path to use for the current proxy request to pod.
   */
  def connectCoreV1OptionsNamespacedPodProxy(name: String, namespace: String, path: Option[String] = None)(implicit apiKey: ApiKeyValue): ApiRequest[String] =
    ApiRequest[String](ApiMethods.OPTIONS, "https://localhost", "/api/v1/namespaces/{namespace}/pods/{name}/proxy", "*/*")
      .withApiKey(apiKey, "authorization", HEADER)
      .withQueryParam("path", path)
      .withPathParam("name", name)
      .withPathParam("namespace", namespace)
      .withSuccessResponse[String](200)
      .withErrorResponse[Unit](401)
        /**
   * connect OPTIONS requests to proxy of Pod
   * 
   * Expected answers:
   *   code 200 : String (OK)
   *   code 401 :  (Unauthorized)
   * 
   * Available security schemes:
   *   BearerToken (apiKey)
   * 
   * @param name name of the Pod
   * @param namespace object name and auth scope, such as for teams and projects
   * @param path path to the resource
   * @param path2 Path is the URL path to use for the current proxy request to pod.
   */
  def connectCoreV1OptionsNamespacedPodProxyWithPath(name: String, namespace: String, path: String, path2: Option[String] = None)(implicit apiKey: ApiKeyValue): ApiRequest[String] =
    ApiRequest[String](ApiMethods.OPTIONS, "https://localhost", "/api/v1/namespaces/{namespace}/pods/{name}/proxy/{path}", "*/*")
      .withApiKey(apiKey, "authorization", HEADER)
      .withQueryParam("path", path2)
      .withPathParam("name", name)
      .withPathParam("namespace", namespace)
      .withPathParam("path", path)
      .withSuccessResponse[String](200)
      .withErrorResponse[Unit](401)
        /**
   * connect OPTIONS requests to proxy of Service
   * 
   * Expected answers:
   *   code 200 : String (OK)
   *   code 401 :  (Unauthorized)
   * 
   * Available security schemes:
   *   BearerToken (apiKey)
   * 
   * @param name name of the Service
   * @param namespace object name and auth scope, such as for teams and projects
   * @param path Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q&#x3D;user:kimchy. Path is _search?q&#x3D;user:kimchy.
   */
  def connectCoreV1OptionsNamespacedServiceProxy(name: String, namespace: String, path: Option[String] = None)(implicit apiKey: ApiKeyValue): ApiRequest[String] =
    ApiRequest[String](ApiMethods.OPTIONS, "https://localhost", "/api/v1/namespaces/{namespace}/services/{name}/proxy", "*/*")
      .withApiKey(apiKey, "authorization", HEADER)
      .withQueryParam("path", path)
      .withPathParam("name", name)
      .withPathParam("namespace", namespace)
      .withSuccessResponse[String](200)
      .withErrorResponse[Unit](401)
        /**
   * connect OPTIONS requests to proxy of Service
   * 
   * Expected answers:
   *   code 200 : String (OK)
   *   code 401 :  (Unauthorized)
   * 
   * Available security schemes:
   *   BearerToken (apiKey)
   * 
   * @param name name of the Service
   * @param namespace object name and auth scope, such as for teams and projects
   * @param path path to the resource
   * @param path2 Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q&#x3D;user:kimchy. Path is _search?q&#x3D;user:kimchy.
   */
  def connectCoreV1OptionsNamespacedServiceProxyWithPath(name: String, namespace: String, path: String, path2: Option[String] = None)(implicit apiKey: ApiKeyValue): ApiRequest[String] =
    ApiRequest[String](ApiMethods.OPTIONS, "https://localhost", "/api/v1/namespaces/{namespace}/services/{name}/proxy/{path}", "*/*")
      .withApiKey(apiKey, "authorization", HEADER)
      .withQueryParam("path", path2)
      .withPathParam("name", name)
      .withPathParam("namespace", namespace)
      .withPathParam("path", path)
      .withSuccessResponse[String](200)
      .withErrorResponse[Unit](401)
        /**
   * connect OPTIONS requests to proxy of Node
   * 
   * Expected answers:
   *   code 200 : String (OK)
   *   code 401 :  (Unauthorized)
   * 
   * Available security schemes:
   *   BearerToken (apiKey)
   * 
   * @param name name of the Node
   * @param path Path is the URL path to use for the current proxy request to node.
   */
  def connectCoreV1OptionsNodeProxy(name: String, path: Option[String] = None)(implicit apiKey: ApiKeyValue): ApiRequest[String] =
    ApiRequest[String](ApiMethods.OPTIONS, "https://localhost", "/api/v1/nodes/{name}/proxy", "*/*")
      .withApiKey(apiKey, "authorization", HEADER)
      .withQueryParam("path", path)
      .withPathParam("name", name)
      .withSuccessResponse[String](200)
      .withErrorResponse[Unit](401)
        /**
   * connect OPTIONS requests to proxy of Node
   * 
   * Expected answers:
   *   code 200 : String (OK)
   *   code 401 :  (Unauthorized)
   * 
   * Available security schemes:
   *   BearerToken (apiKey)
   * 
   * @param name name of the Node
   * @param path path to the resource
   * @param path2 Path is the URL path to use for the current proxy request to node.
   */
  def connectCoreV1OptionsNodeProxyWithPath(name: String, path: String, path2: Option[String] = None)(implicit apiKey: ApiKeyValue): ApiRequest[String] =
    ApiRequest[String](ApiMethods.OPTIONS, "https://localhost", "/api/v1/nodes/{name}/proxy/{path}", "*/*")
      .withApiKey(apiKey, "authorization", HEADER)
      .withQueryParam("path", path2)
      .withPathParam("name", name)
      .withPathParam("path", path)
      .withSuccessResponse[String](200)
      .withErrorResponse[Unit](401)
        /**
   * connect PATCH requests to proxy of Pod
   * 
   * Expected answers:
   *   code 200 : String (OK)
   *   code 401 :  (Unauthorized)
   * 
   * Available security schemes:
   *   BearerToken (apiKey)
   * 
   * @param name name of the Pod
   * @param namespace object name and auth scope, such as for teams and projects
   * @param path Path is the URL path to use for the current proxy request to pod.
   */
  def connectCoreV1PatchNamespacedPodProxy(name: String, namespace: String, path: Option[String] = None)(implicit apiKey: ApiKeyValue): ApiRequest[String] =
    ApiRequest[String](ApiMethods.PATCH, "https://localhost", "/api/v1/namespaces/{namespace}/pods/{name}/proxy", "*/*")
      .withApiKey(apiKey, "authorization", HEADER)
      .withQueryParam("path", path)
      .withPathParam("name", name)
      .withPathParam("namespace", namespace)
      .withSuccessResponse[String](200)
      .withErrorResponse[Unit](401)
        /**
   * connect PATCH requests to proxy of Pod
   * 
   * Expected answers:
   *   code 200 : String (OK)
   *   code 401 :  (Unauthorized)
   * 
   * Available security schemes:
   *   BearerToken (apiKey)
   * 
   * @param name name of the Pod
   * @param namespace object name and auth scope, such as for teams and projects
   * @param path path to the resource
   * @param path2 Path is the URL path to use for the current proxy request to pod.
   */
  def connectCoreV1PatchNamespacedPodProxyWithPath(name: String, namespace: String, path: String, path2: Option[String] = None)(implicit apiKey: ApiKeyValue): ApiRequest[String] =
    ApiRequest[String](ApiMethods.PATCH, "https://localhost", "/api/v1/namespaces/{namespace}/pods/{name}/proxy/{path}", "*/*")
      .withApiKey(apiKey, "authorization", HEADER)
      .withQueryParam("path", path2)
      .withPathParam("name", name)
      .withPathParam("namespace", namespace)
      .withPathParam("path", path)
      .withSuccessResponse[String](200)
      .withErrorResponse[Unit](401)
        /**
   * connect PATCH requests to proxy of Service
   * 
   * Expected answers:
   *   code 200 : String (OK)
   *   code 401 :  (Unauthorized)
   * 
   * Available security schemes:
   *   BearerToken (apiKey)
   * 
   * @param name name of the Service
   * @param namespace object name and auth scope, such as for teams and projects
   * @param path Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q&#x3D;user:kimchy. Path is _search?q&#x3D;user:kimchy.
   */
  def connectCoreV1PatchNamespacedServiceProxy(name: String, namespace: String, path: Option[String] = None)(implicit apiKey: ApiKeyValue): ApiRequest[String] =
    ApiRequest[String](ApiMethods.PATCH, "https://localhost", "/api/v1/namespaces/{namespace}/services/{name}/proxy", "*/*")
      .withApiKey(apiKey, "authorization", HEADER)
      .withQueryParam("path", path)
      .withPathParam("name", name)
      .withPathParam("namespace", namespace)
      .withSuccessResponse[String](200)
      .withErrorResponse[Unit](401)
        /**
   * connect PATCH requests to proxy of Service
   * 
   * Expected answers:
   *   code 200 : String (OK)
   *   code 401 :  (Unauthorized)
   * 
   * Available security schemes:
   *   BearerToken (apiKey)
   * 
   * @param name name of the Service
   * @param namespace object name and auth scope, such as for teams and projects
   * @param path path to the resource
   * @param path2 Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q&#x3D;user:kimchy. Path is _search?q&#x3D;user:kimchy.
   */
  def connectCoreV1PatchNamespacedServiceProxyWithPath(name: String, namespace: String, path: String, path2: Option[String] = None)(implicit apiKey: ApiKeyValue): ApiRequest[String] =
    ApiRequest[String](ApiMethods.PATCH, "https://localhost", "/api/v1/namespaces/{namespace}/services/{name}/proxy/{path}", "*/*")
      .withApiKey(apiKey, "authorization", HEADER)
      .withQueryParam("path", path2)
      .withPathParam("name", name)
      .withPathParam("namespace", namespace)
      .withPathParam("path", path)
      .withSuccessResponse[String](200)
      .withErrorResponse[Unit](401)
        /**
   * connect PATCH requests to proxy of Node
   * 
   * Expected answers:
   *   code 200 : String (OK)
   *   code 401 :  (Unauthorized)
   * 
   * Available security schemes:
   *   BearerToken (apiKey)
   * 
   * @param name name of the Node
   * @param path Path is the URL path to use for the current proxy request to node.
   */
  def connectCoreV1PatchNodeProxy(name: String, path: Option[String] = None)(implicit apiKey: ApiKeyValue): ApiRequest[String] =
    ApiRequest[String](ApiMethods.PATCH, "https://localhost", "/api/v1/nodes/{name}/proxy", "*/*")
      .withApiKey(apiKey, "authorization", HEADER)
      .withQueryParam("path", path)
      .withPathParam("name", name)
      .withSuccessResponse[String](200)
      .withErrorResponse[Unit](401)
        /**
   * connect PATCH requests to proxy of Node
   * 
   * Expected answers:
   *   code 200 : String (OK)
   *   code 401 :  (Unauthorized)
   * 
   * Available security schemes:
   *   BearerToken (apiKey)
   * 
   * @param name name of the Node
   * @param path path to the resource
   * @param path2 Path is the URL path to use for the current proxy request to node.
   */
  def connectCoreV1PatchNodeProxyWithPath(name: String, path: String, path2: Option[String] = None)(implicit apiKey: ApiKeyValue): ApiRequest[String] =
    ApiRequest[String](ApiMethods.PATCH, "https://localhost", "/api/v1/nodes/{name}/proxy/{path}", "*/*")
      .withApiKey(apiKey, "authorization", HEADER)
      .withQueryParam("path", path2)
      .withPathParam("name", name)
      .withPathParam("path", path)
      .withSuccessResponse[String](200)
      .withErrorResponse[Unit](401)
        /**
   * connect POST requests to attach of Pod
   * 
   * Expected answers:
   *   code 200 : String (OK)
   *   code 401 :  (Unauthorized)
   * 
   * Available security schemes:
   *   BearerToken (apiKey)
   * 
   * @param name name of the Pod
   * @param namespace object name and auth scope, such as for teams and projects
   * @param container The container in which to execute the command. Defaults to only container if there is only one container in the pod.
   * @param stderr Stderr if true indicates that stderr is to be redirected for the attach call. Defaults to true.
   * @param stdin Stdin if true, redirects the standard input stream of the pod for this call. Defaults to false.
   * @param stdout Stdout if true indicates that stdout is to be redirected for the attach call. Defaults to true.
   * @param tty TTY if true indicates that a tty will be allocated for the attach call. This is passed through the container runtime so the tty is allocated on the worker node by the container runtime. Defaults to false.
   */
  def connectCoreV1PostNamespacedPodAttach(name: String, namespace: String, container: Option[String] = None, stderr: Option[Boolean] = None, stdin: Option[Boolean] = None, stdout: Option[Boolean] = None, tty: Option[Boolean] = None)(implicit apiKey: ApiKeyValue): ApiRequest[String] =
    ApiRequest[String](ApiMethods.POST, "https://localhost", "/api/v1/namespaces/{namespace}/pods/{name}/attach", "*/*")
      .withApiKey(apiKey, "authorization", HEADER)
      .withQueryParam("container", container)
      .withQueryParam("stderr", stderr)
      .withQueryParam("stdin", stdin)
      .withQueryParam("stdout", stdout)
      .withQueryParam("tty", tty)
      .withPathParam("name", name)
      .withPathParam("namespace", namespace)
      .withSuccessResponse[String](200)
      .withErrorResponse[Unit](401)
        /**
   * connect POST requests to exec of Pod
   * 
   * Expected answers:
   *   code 200 : String (OK)
   *   code 401 :  (Unauthorized)
   * 
   * Available security schemes:
   *   BearerToken (apiKey)
   * 
   * @param name name of the Pod
   * @param namespace object name and auth scope, such as for teams and projects
   * @param command Command is the remote command to execute. argv array. Not executed within a shell.
   * @param container Container in which to execute the command. Defaults to only container if there is only one container in the pod.
   * @param stderr Redirect the standard error stream of the pod for this call. Defaults to true.
   * @param stdin Redirect the standard input stream of the pod for this call. Defaults to false.
   * @param stdout Redirect the standard output stream of the pod for this call. Defaults to true.
   * @param tty TTY if true indicates that a tty will be allocated for the exec call. Defaults to false.
   */
  def connectCoreV1PostNamespacedPodExec(name: String, namespace: String, command: Option[String] = None, container: Option[String] = None, stderr: Option[Boolean] = None, stdin: Option[Boolean] = None, stdout: Option[Boolean] = None, tty: Option[Boolean] = None)(implicit apiKey: ApiKeyValue): ApiRequest[String] =
    ApiRequest[String](ApiMethods.POST, "https://localhost", "/api/v1/namespaces/{namespace}/pods/{name}/exec", "*/*")
      .withApiKey(apiKey, "authorization", HEADER)
      .withQueryParam("command", command)
      .withQueryParam("container", container)
      .withQueryParam("stderr", stderr)
      .withQueryParam("stdin", stdin)
      .withQueryParam("stdout", stdout)
      .withQueryParam("tty", tty)
      .withPathParam("name", name)
      .withPathParam("namespace", namespace)
      .withSuccessResponse[String](200)
      .withErrorResponse[Unit](401)
        /**
   * connect POST requests to portforward of Pod
   * 
   * Expected answers:
   *   code 200 : String (OK)
   *   code 401 :  (Unauthorized)
   * 
   * Available security schemes:
   *   BearerToken (apiKey)
   * 
   * @param name name of the Pod
   * @param namespace object name and auth scope, such as for teams and projects
   * @param ports List of ports to forward Required when using WebSockets
   */
  def connectCoreV1PostNamespacedPodPortforward(name: String, namespace: String, ports: Option[Int] = None)(implicit apiKey: ApiKeyValue): ApiRequest[String] =
    ApiRequest[String](ApiMethods.POST, "https://localhost", "/api/v1/namespaces/{namespace}/pods/{name}/portforward", "*/*")
      .withApiKey(apiKey, "authorization", HEADER)
      .withQueryParam("ports", ports)
      .withPathParam("name", name)
      .withPathParam("namespace", namespace)
      .withSuccessResponse[String](200)
      .withErrorResponse[Unit](401)
        /**
   * connect POST requests to proxy of Pod
   * 
   * Expected answers:
   *   code 200 : String (OK)
   *   code 401 :  (Unauthorized)
   * 
   * Available security schemes:
   *   BearerToken (apiKey)
   * 
   * @param name name of the Pod
   * @param namespace object name and auth scope, such as for teams and projects
   * @param path Path is the URL path to use for the current proxy request to pod.
   */
  def connectCoreV1PostNamespacedPodProxy(name: String, namespace: String, path: Option[String] = None)(implicit apiKey: ApiKeyValue): ApiRequest[String] =
    ApiRequest[String](ApiMethods.POST, "https://localhost", "/api/v1/namespaces/{namespace}/pods/{name}/proxy", "*/*")
      .withApiKey(apiKey, "authorization", HEADER)
      .withQueryParam("path", path)
      .withPathParam("name", name)
      .withPathParam("namespace", namespace)
      .withSuccessResponse[String](200)
      .withErrorResponse[Unit](401)
        /**
   * connect POST requests to proxy of Pod
   * 
   * Expected answers:
   *   code 200 : String (OK)
   *   code 401 :  (Unauthorized)
   * 
   * Available security schemes:
   *   BearerToken (apiKey)
   * 
   * @param name name of the Pod
   * @param namespace object name and auth scope, such as for teams and projects
   * @param path path to the resource
   * @param path2 Path is the URL path to use for the current proxy request to pod.
   */
  def connectCoreV1PostNamespacedPodProxyWithPath(name: String, namespace: String, path: String, path2: Option[String] = None)(implicit apiKey: ApiKeyValue): ApiRequest[String] =
    ApiRequest[String](ApiMethods.POST, "https://localhost", "/api/v1/namespaces/{namespace}/pods/{name}/proxy/{path}", "*/*")
      .withApiKey(apiKey, "authorization", HEADER)
      .withQueryParam("path", path2)
      .withPathParam("name", name)
      .withPathParam("namespace", namespace)
      .withPathParam("path", path)
      .withSuccessResponse[String](200)
      .withErrorResponse[Unit](401)
        /**
   * connect POST requests to proxy of Service
   * 
   * Expected answers:
   *   code 200 : String (OK)
   *   code 401 :  (Unauthorized)
   * 
   * Available security schemes:
   *   BearerToken (apiKey)
   * 
   * @param name name of the Service
   * @param namespace object name and auth scope, such as for teams and projects
   * @param path Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q&#x3D;user:kimchy. Path is _search?q&#x3D;user:kimchy.
   */
  def connectCoreV1PostNamespacedServiceProxy(name: String, namespace: String, path: Option[String] = None)(implicit apiKey: ApiKeyValue): ApiRequest[String] =
    ApiRequest[String](ApiMethods.POST, "https://localhost", "/api/v1/namespaces/{namespace}/services/{name}/proxy", "*/*")
      .withApiKey(apiKey, "authorization", HEADER)
      .withQueryParam("path", path)
      .withPathParam("name", name)
      .withPathParam("namespace", namespace)
      .withSuccessResponse[String](200)
      .withErrorResponse[Unit](401)
        /**
   * connect POST requests to proxy of Service
   * 
   * Expected answers:
   *   code 200 : String (OK)
   *   code 401 :  (Unauthorized)
   * 
   * Available security schemes:
   *   BearerToken (apiKey)
   * 
   * @param name name of the Service
   * @param namespace object name and auth scope, such as for teams and projects
   * @param path path to the resource
   * @param path2 Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q&#x3D;user:kimchy. Path is _search?q&#x3D;user:kimchy.
   */
  def connectCoreV1PostNamespacedServiceProxyWithPath(name: String, namespace: String, path: String, path2: Option[String] = None)(implicit apiKey: ApiKeyValue): ApiRequest[String] =
    ApiRequest[String](ApiMethods.POST, "https://localhost", "/api/v1/namespaces/{namespace}/services/{name}/proxy/{path}", "*/*")
      .withApiKey(apiKey, "authorization", HEADER)
      .withQueryParam("path", path2)
      .withPathParam("name", name)
      .withPathParam("namespace", namespace)
      .withPathParam("path", path)
      .withSuccessResponse[String](200)
      .withErrorResponse[Unit](401)
        /**
   * connect POST requests to proxy of Node
   * 
   * Expected answers:
   *   code 200 : String (OK)
   *   code 401 :  (Unauthorized)
   * 
   * Available security schemes:
   *   BearerToken (apiKey)
   * 
   * @param name name of the Node
   * @param path Path is the URL path to use for the current proxy request to node.
   */
  def connectCoreV1PostNodeProxy(name: String, path: Option[String] = None)(implicit apiKey: ApiKeyValue): ApiRequest[String] =
    ApiRequest[String](ApiMethods.POST, "https://localhost", "/api/v1/nodes/{name}/proxy", "*/*")
      .withApiKey(apiKey, "authorization", HEADER)
      .withQueryParam("path", path)
      .withPathParam("name", name)
      .withSuccessResponse[String](200)
      .withErrorResponse[Unit](401)
        /**
   * connect POST requests to proxy of Node
   * 
   * Expected answers:
   *   code 200 : String (OK)
   *   code 401 :  (Unauthorized)
   * 
   * Available security schemes:
   *   BearerToken (apiKey)
   * 
   * @param name name of the Node
   * @param path path to the resource
   * @param path2 Path is the URL path to use for the current proxy request to node.
   */
  def connectCoreV1PostNodeProxyWithPath(name: String, path: String, path2: Option[String] = None)(implicit apiKey: ApiKeyValue): ApiRequest[String] =
    ApiRequest[String](ApiMethods.POST, "https://localhost", "/api/v1/nodes/{name}/proxy/{path}", "*/*")
      .withApiKey(apiKey, "authorization", HEADER)
      .withQueryParam("path", path2)
      .withPathParam("name", name)
      .withPathParam("path", path)
      .withSuccessResponse[String](200)
      .withErrorResponse[Unit](401)
        /**
   * connect PUT requests to proxy of Pod
   * 
   * Expected answers:
   *   code 200 : String (OK)
   *   code 401 :  (Unauthorized)
   * 
   * Available security schemes:
   *   BearerToken (apiKey)
   * 
   * @param name name of the Pod
   * @param namespace object name and auth scope, such as for teams and projects
   * @param path Path is the URL path to use for the current proxy request to pod.
   */
  def connectCoreV1PutNamespacedPodProxy(name: String, namespace: String, path: Option[String] = None)(implicit apiKey: ApiKeyValue): ApiRequest[String] =
    ApiRequest[String](ApiMethods.PUT, "https://localhost", "/api/v1/namespaces/{namespace}/pods/{name}/proxy", "*/*")
      .withApiKey(apiKey, "authorization", HEADER)
      .withQueryParam("path", path)
      .withPathParam("name", name)
      .withPathParam("namespace", namespace)
      .withSuccessResponse[String](200)
      .withErrorResponse[Unit](401)
        /**
   * connect PUT requests to proxy of Pod
   * 
   * Expected answers:
   *   code 200 : String (OK)
   *   code 401 :  (Unauthorized)
   * 
   * Available security schemes:
   *   BearerToken (apiKey)
   * 
   * @param name name of the Pod
   * @param namespace object name and auth scope, such as for teams and projects
   * @param path path to the resource
   * @param path2 Path is the URL path to use for the current proxy request to pod.
   */
  def connectCoreV1PutNamespacedPodProxyWithPath(name: String, namespace: String, path: String, path2: Option[String] = None)(implicit apiKey: ApiKeyValue): ApiRequest[String] =
    ApiRequest[String](ApiMethods.PUT, "https://localhost", "/api/v1/namespaces/{namespace}/pods/{name}/proxy/{path}", "*/*")
      .withApiKey(apiKey, "authorization", HEADER)
      .withQueryParam("path", path2)
      .withPathParam("name", name)
      .withPathParam("namespace", namespace)
      .withPathParam("path", path)
      .withSuccessResponse[String](200)
      .withErrorResponse[Unit](401)
        /**
   * connect PUT requests to proxy of Service
   * 
   * Expected answers:
   *   code 200 : String (OK)
   *   code 401 :  (Unauthorized)
   * 
   * Available security schemes:
   *   BearerToken (apiKey)
   * 
   * @param name name of the Service
   * @param namespace object name and auth scope, such as for teams and projects
   * @param path Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q&#x3D;user:kimchy. Path is _search?q&#x3D;user:kimchy.
   */
  def connectCoreV1PutNamespacedServiceProxy(name: String, namespace: String, path: Option[String] = None)(implicit apiKey: ApiKeyValue): ApiRequest[String] =
    ApiRequest[String](ApiMethods.PUT, "https://localhost", "/api/v1/namespaces/{namespace}/services/{name}/proxy", "*/*")
      .withApiKey(apiKey, "authorization", HEADER)
      .withQueryParam("path", path)
      .withPathParam("name", name)
      .withPathParam("namespace", namespace)
      .withSuccessResponse[String](200)
      .withErrorResponse[Unit](401)
        /**
   * connect PUT requests to proxy of Service
   * 
   * Expected answers:
   *   code 200 : String (OK)
   *   code 401 :  (Unauthorized)
   * 
   * Available security schemes:
   *   BearerToken (apiKey)
   * 
   * @param name name of the Service
   * @param namespace object name and auth scope, such as for teams and projects
   * @param path path to the resource
   * @param path2 Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q&#x3D;user:kimchy. Path is _search?q&#x3D;user:kimchy.
   */
  def connectCoreV1PutNamespacedServiceProxyWithPath(name: String, namespace: String, path: String, path2: Option[String] = None)(implicit apiKey: ApiKeyValue): ApiRequest[String] =
    ApiRequest[String](ApiMethods.PUT, "https://localhost", "/api/v1/namespaces/{namespace}/services/{name}/proxy/{path}", "*/*")
      .withApiKey(apiKey, "authorization", HEADER)
      .withQueryParam("path", path2)
      .withPathParam("name", name)
      .withPathParam("namespace", namespace)
      .withPathParam("path", path)
      .withSuccessResponse[String](200)
      .withErrorResponse[Unit](401)
        /**
   * connect PUT requests to proxy of Node
   * 
   * Expected answers:
   *   code 200 : String (OK)
   *   code 401 :  (Unauthorized)
   * 
   * Available security schemes:
   *   BearerToken (apiKey)
   * 
   * @param name name of the Node
   * @param path Path is the URL path to use for the current proxy request to node.
   */
  def connectCoreV1PutNodeProxy(name: String, path: Option[String] = None)(implicit apiKey: ApiKeyValue): ApiRequest[String] =
    ApiRequest[String](ApiMethods.PUT, "https://localhost", "/api/v1/nodes/{name}/proxy", "*/*")
      .withApiKey(apiKey, "authorization", HEADER)
      .withQueryParam("path", path)
      .withPathParam("name", name)
      .withSuccessResponse[String](200)
      .withErrorResponse[Unit](401)
        /**
   * connect PUT requests to proxy of Node
   * 
   * Expected answers:
   *   code 200 : String (OK)
   *   code 401 :  (Unauthorized)
   * 
   * Available security schemes:
   *   BearerToken (apiKey)
   * 
   * @param name name of the Node
   * @param path path to the resource
   * @param path2 Path is the URL path to use for the current proxy request to node.
   */
  def connectCoreV1PutNodeProxyWithPath(name: String, path: String, path2: Option[String] = None)(implicit apiKey: ApiKeyValue): ApiRequest[String] =
    ApiRequest[String](ApiMethods.PUT, "https://localhost", "/api/v1/nodes/{name}/proxy/{path}", "*/*")
      .withApiKey(apiKey, "authorization", HEADER)
      .withQueryParam("path", path2)
      .withPathParam("name", name)
      .withPathParam("path", path)
      .withSuccessResponse[String](200)
      .withErrorResponse[Unit](401)
        /**
   * create a Namespace
   * 
   * Expected answers:
   *   code 200 : IoK8sApiCoreV1Namespace (OK)
   *   code 201 : IoK8sApiCoreV1Namespace (Created)
   *   code 202 : IoK8sApiCoreV1Namespace (Accepted)
   *   code 401 :  (Unauthorized)
   * 
   * Available security schemes:
   *   BearerToken (apiKey)
   * 
   * @param body 
   * @param pretty If &#39;true&#39;, then the output is pretty printed.
   */
  def createCoreV1Namespace(body: IoK8sApiCoreV1Namespace, pretty: Option[String] = None)(implicit apiKey: ApiKeyValue): ApiRequest[IoK8sApiCoreV1Namespace] =
    ApiRequest[IoK8sApiCoreV1Namespace](ApiMethods.POST, "https://localhost", "/api/v1/namespaces", "*/*")
      .withApiKey(apiKey, "authorization", HEADER)
      .withBody(body)
      .withQueryParam("pretty", pretty)
      .withSuccessResponse[IoK8sApiCoreV1Namespace](200)
      .withErrorResponse[IoK8sApiCoreV1Namespace](201)
      .withErrorResponse[IoK8sApiCoreV1Namespace](202)
      .withErrorResponse[Unit](401)
        /**
   * create a Binding
   * 
   * Expected answers:
   *   code 200 : IoK8sApiCoreV1Binding (OK)
   *   code 201 : IoK8sApiCoreV1Binding (Created)
   *   code 202 : IoK8sApiCoreV1Binding (Accepted)
   *   code 401 :  (Unauthorized)
   * 
   * Available security schemes:
   *   BearerToken (apiKey)
   * 
   * @param namespace object name and auth scope, such as for teams and projects
   * @param body 
   * @param pretty If &#39;true&#39;, then the output is pretty printed.
   */
  def createCoreV1NamespacedBinding(namespace: String, body: IoK8sApiCoreV1Binding, pretty: Option[String] = None)(implicit apiKey: ApiKeyValue): ApiRequest[IoK8sApiCoreV1Binding] =
    ApiRequest[IoK8sApiCoreV1Binding](ApiMethods.POST, "https://localhost", "/api/v1/namespaces/{namespace}/bindings", "*/*")
      .withApiKey(apiKey, "authorization", HEADER)
      .withBody(body)
      .withQueryParam("pretty", pretty)
      .withPathParam("namespace", namespace)
      .withSuccessResponse[IoK8sApiCoreV1Binding](200)
      .withErrorResponse[IoK8sApiCoreV1Binding](201)
      .withErrorResponse[IoK8sApiCoreV1Binding](202)
      .withErrorResponse[Unit](401)
        /**
   * create a ConfigMap
   * 
   * Expected answers:
   *   code 200 : IoK8sApiCoreV1ConfigMap (OK)
   *   code 201 : IoK8sApiCoreV1ConfigMap (Created)
   *   code 202 : IoK8sApiCoreV1ConfigMap (Accepted)
   *   code 401 :  (Unauthorized)
   * 
   * Available security schemes:
   *   BearerToken (apiKey)
   * 
   * @param namespace object name and auth scope, such as for teams and projects
   * @param body 
   * @param pretty If &#39;true&#39;, then the output is pretty printed.
   */
  def createCoreV1NamespacedConfigMap(namespace: String, body: IoK8sApiCoreV1ConfigMap, pretty: Option[String] = None)(implicit apiKey: ApiKeyValue): ApiRequest[IoK8sApiCoreV1ConfigMap] =
    ApiRequest[IoK8sApiCoreV1ConfigMap](ApiMethods.POST, "https://localhost", "/api/v1/namespaces/{namespace}/configmaps", "*/*")
      .withApiKey(apiKey, "authorization", HEADER)
      .withBody(body)
      .withQueryParam("pretty", pretty)
      .withPathParam("namespace", namespace)
      .withSuccessResponse[IoK8sApiCoreV1ConfigMap](200)
      .withErrorResponse[IoK8sApiCoreV1ConfigMap](201)
      .withErrorResponse[IoK8sApiCoreV1ConfigMap](202)
      .withErrorResponse[Unit](401)
        /**
   * create Endpoints
   * 
   * Expected answers:
   *   code 200 : IoK8sApiCoreV1Endpoints (OK)
   *   code 201 : IoK8sApiCoreV1Endpoints (Created)
   *   code 202 : IoK8sApiCoreV1Endpoints (Accepted)
   *   code 401 :  (Unauthorized)
   * 
   * Available security schemes:
   *   BearerToken (apiKey)
   * 
   * @param namespace object name and auth scope, such as for teams and projects
   * @param body 
   * @param pretty If &#39;true&#39;, then the output is pretty printed.
   */
  def createCoreV1NamespacedEndpoints(namespace: String, body: IoK8sApiCoreV1Endpoints, pretty: Option[String] = None)(implicit apiKey: ApiKeyValue): ApiRequest[IoK8sApiCoreV1Endpoints] =
    ApiRequest[IoK8sApiCoreV1Endpoints](ApiMethods.POST, "https://localhost", "/api/v1/namespaces/{namespace}/endpoints", "*/*")
      .withApiKey(apiKey, "authorization", HEADER)
      .withBody(body)
      .withQueryParam("pretty", pretty)
      .withPathParam("namespace", namespace)
      .withSuccessResponse[IoK8sApiCoreV1Endpoints](200)
      .withErrorResponse[IoK8sApiCoreV1Endpoints](201)
      .withErrorResponse[IoK8sApiCoreV1Endpoints](202)
      .withErrorResponse[Unit](401)
        /**
   * create an Event
   * 
   * Expected answers:
   *   code 200 : IoK8sApiCoreV1Event (OK)
   *   code 201 : IoK8sApiCoreV1Event (Created)
   *   code 202 : IoK8sApiCoreV1Event (Accepted)
   *   code 401 :  (Unauthorized)
   * 
   * Available security schemes:
   *   BearerToken (apiKey)
   * 
   * @param namespace object name and auth scope, such as for teams and projects
   * @param body 
   * @param pretty If &#39;true&#39;, then the output is pretty printed.
   */
  def createCoreV1NamespacedEvent(namespace: String, body: IoK8sApiCoreV1Event, pretty: Option[String] = None)(implicit apiKey: ApiKeyValue): ApiRequest[IoK8sApiCoreV1Event] =
    ApiRequest[IoK8sApiCoreV1Event](ApiMethods.POST, "https://localhost", "/api/v1/namespaces/{namespace}/events", "*/*")
      .withApiKey(apiKey, "authorization", HEADER)
      .withBody(body)
      .withQueryParam("pretty", pretty)
      .withPathParam("namespace", namespace)
      .withSuccessResponse[IoK8sApiCoreV1Event](200)
      .withErrorResponse[IoK8sApiCoreV1Event](201)
      .withErrorResponse[IoK8sApiCoreV1Event](202)
      .withErrorResponse[Unit](401)
        /**
   * create a LimitRange
   * 
   * Expected answers:
   *   code 200 : IoK8sApiCoreV1LimitRange (OK)
   *   code 201 : IoK8sApiCoreV1LimitRange (Created)
   *   code 202 : IoK8sApiCoreV1LimitRange (Accepted)
   *   code 401 :  (Unauthorized)
   * 
   * Available security schemes:
   *   BearerToken (apiKey)
   * 
   * @param namespace object name and auth scope, such as for teams and projects
   * @param body 
   * @param pretty If &#39;true&#39;, then the output is pretty printed.
   */
  def createCoreV1NamespacedLimitRange(namespace: String, body: IoK8sApiCoreV1LimitRange, pretty: Option[String] = None)(implicit apiKey: ApiKeyValue): ApiRequest[IoK8sApiCoreV1LimitRange] =
    ApiRequest[IoK8sApiCoreV1LimitRange](ApiMethods.POST, "https://localhost", "/api/v1/namespaces/{namespace}/limitranges", "*/*")
      .withApiKey(apiKey, "authorization", HEADER)
      .withBody(body)
      .withQueryParam("pretty", pretty)
      .withPathParam("namespace", namespace)
      .withSuccessResponse[IoK8sApiCoreV1LimitRange](200)
      .withErrorResponse[IoK8sApiCoreV1LimitRange](201)
      .withErrorResponse[IoK8sApiCoreV1LimitRange](202)
      .withErrorResponse[Unit](401)
        /**
   * create a PersistentVolumeClaim
   * 
   * Expected answers:
   *   code 200 : IoK8sApiCoreV1PersistentVolumeClaim (OK)
   *   code 201 : IoK8sApiCoreV1PersistentVolumeClaim (Created)
   *   code 202 : IoK8sApiCoreV1PersistentVolumeClaim (Accepted)
   *   code 401 :  (Unauthorized)
   * 
   * Available security schemes:
   *   BearerToken (apiKey)
   * 
   * @param namespace object name and auth scope, such as for teams and projects
   * @param body 
   * @param pretty If &#39;true&#39;, then the output is pretty printed.
   */
  def createCoreV1NamespacedPersistentVolumeClaim(namespace: String, body: IoK8sApiCoreV1PersistentVolumeClaim, pretty: Option[String] = None)(implicit apiKey: ApiKeyValue): ApiRequest[IoK8sApiCoreV1PersistentVolumeClaim] =
    ApiRequest[IoK8sApiCoreV1PersistentVolumeClaim](ApiMethods.POST, "https://localhost", "/api/v1/namespaces/{namespace}/persistentvolumeclaims", "*/*")
      .withApiKey(apiKey, "authorization", HEADER)
      .withBody(body)
      .withQueryParam("pretty", pretty)
      .withPathParam("namespace", namespace)
      .withSuccessResponse[IoK8sApiCoreV1PersistentVolumeClaim](200)
      .withErrorResponse[IoK8sApiCoreV1PersistentVolumeClaim](201)
      .withErrorResponse[IoK8sApiCoreV1PersistentVolumeClaim](202)
      .withErrorResponse[Unit](401)
        /**
   * create a Pod
   * 
   * Expected answers:
   *   code 200 : IoK8sApiCoreV1Pod (OK)
   *   code 201 : IoK8sApiCoreV1Pod (Created)
   *   code 202 : IoK8sApiCoreV1Pod (Accepted)
   *   code 401 :  (Unauthorized)
   * 
   * Available security schemes:
   *   BearerToken (apiKey)
   * 
   * @param namespace object name and auth scope, such as for teams and projects
   * @param body 
   * @param pretty If &#39;true&#39;, then the output is pretty printed.
   */
  def createCoreV1NamespacedPod(namespace: String, body: IoK8sApiCoreV1Pod, pretty: Option[String] = None)(implicit apiKey: ApiKeyValue): ApiRequest[IoK8sApiCoreV1Pod] =
    ApiRequest[IoK8sApiCoreV1Pod](ApiMethods.POST, "https://localhost", "/api/v1/namespaces/{namespace}/pods", "*/*")
      .withApiKey(apiKey, "authorization", HEADER)
      .withBody(body)
      .withQueryParam("pretty", pretty)
      .withPathParam("namespace", namespace)
      .withSuccessResponse[IoK8sApiCoreV1Pod](200)
      .withErrorResponse[IoK8sApiCoreV1Pod](201)
      .withErrorResponse[IoK8sApiCoreV1Pod](202)
      .withErrorResponse[Unit](401)
        /**
   * create binding of a Pod
   * 
   * Expected answers:
   *   code 200 : IoK8sApiCoreV1Binding (OK)
   *   code 201 : IoK8sApiCoreV1Binding (Created)
   *   code 202 : IoK8sApiCoreV1Binding (Accepted)
   *   code 401 :  (Unauthorized)
   * 
   * Available security schemes:
   *   BearerToken (apiKey)
   * 
   * @param name name of the Binding
   * @param namespace object name and auth scope, such as for teams and projects
   * @param body 
   * @param pretty If &#39;true&#39;, then the output is pretty printed.
   */
  def createCoreV1NamespacedPodBinding(name: String, namespace: String, body: IoK8sApiCoreV1Binding, pretty: Option[String] = None)(implicit apiKey: ApiKeyValue): ApiRequest[IoK8sApiCoreV1Binding] =
    ApiRequest[IoK8sApiCoreV1Binding](ApiMethods.POST, "https://localhost", "/api/v1/namespaces/{namespace}/pods/{name}/binding", "*/*")
      .withApiKey(apiKey, "authorization", HEADER)
      .withBody(body)
      .withQueryParam("pretty", pretty)
      .withPathParam("name", name)
      .withPathParam("namespace", namespace)
      .withSuccessResponse[IoK8sApiCoreV1Binding](200)
      .withErrorResponse[IoK8sApiCoreV1Binding](201)
      .withErrorResponse[IoK8sApiCoreV1Binding](202)
      .withErrorResponse[Unit](401)
        /**
   * create eviction of a Pod
   * 
   * Expected answers:
   *   code 200 : IoK8sApiPolicyV1beta1Eviction (OK)
   *   code 201 : IoK8sApiPolicyV1beta1Eviction (Created)
   *   code 202 : IoK8sApiPolicyV1beta1Eviction (Accepted)
   *   code 401 :  (Unauthorized)
   * 
   * Available security schemes:
   *   BearerToken (apiKey)
   * 
   * @param name name of the Eviction
   * @param namespace object name and auth scope, such as for teams and projects
   * @param body 
   * @param pretty If &#39;true&#39;, then the output is pretty printed.
   */
  def createCoreV1NamespacedPodEviction(name: String, namespace: String, body: IoK8sApiPolicyV1beta1Eviction, pretty: Option[String] = None)(implicit apiKey: ApiKeyValue): ApiRequest[IoK8sApiPolicyV1beta1Eviction] =
    ApiRequest[IoK8sApiPolicyV1beta1Eviction](ApiMethods.POST, "https://localhost", "/api/v1/namespaces/{namespace}/pods/{name}/eviction", "*/*")
      .withApiKey(apiKey, "authorization", HEADER)
      .withBody(body)
      .withQueryParam("pretty", pretty)
      .withPathParam("name", name)
      .withPathParam("namespace", namespace)
      .withSuccessResponse[IoK8sApiPolicyV1beta1Eviction](200)
      .withErrorResponse[IoK8sApiPolicyV1beta1Eviction](201)
      .withErrorResponse[IoK8sApiPolicyV1beta1Eviction](202)
      .withErrorResponse[Unit](401)
        /**
   * create a PodTemplate
   * 
   * Expected answers:
   *   code 200 : IoK8sApiCoreV1PodTemplate (OK)
   *   code 201 : IoK8sApiCoreV1PodTemplate (Created)
   *   code 202 : IoK8sApiCoreV1PodTemplate (Accepted)
   *   code 401 :  (Unauthorized)
   * 
   * Available security schemes:
   *   BearerToken (apiKey)
   * 
   * @param namespace object name and auth scope, such as for teams and projects
   * @param body 
   * @param pretty If &#39;true&#39;, then the output is pretty printed.
   */
  def createCoreV1NamespacedPodTemplate(namespace: String, body: IoK8sApiCoreV1PodTemplate, pretty: Option[String] = None)(implicit apiKey: ApiKeyValue): ApiRequest[IoK8sApiCoreV1PodTemplate] =
    ApiRequest[IoK8sApiCoreV1PodTemplate](ApiMethods.POST, "https://localhost", "/api/v1/namespaces/{namespace}/podtemplates", "*/*")
      .withApiKey(apiKey, "authorization", HEADER)
      .withBody(body)
      .withQueryParam("pretty", pretty)
      .withPathParam("namespace", namespace)
      .withSuccessResponse[IoK8sApiCoreV1PodTemplate](200)
      .withErrorResponse[IoK8sApiCoreV1PodTemplate](201)
      .withErrorResponse[IoK8sApiCoreV1PodTemplate](202)
      .withErrorResponse[Unit](401)
        /**
   * create a ReplicationController
   * 
   * Expected answers:
   *   code 200 : IoK8sApiCoreV1ReplicationController (OK)
   *   code 201 : IoK8sApiCoreV1ReplicationController (Created)
   *   code 202 : IoK8sApiCoreV1ReplicationController (Accepted)
   *   code 401 :  (Unauthorized)
   * 
   * Available security schemes:
   *   BearerToken (apiKey)
   * 
   * @param namespace object name and auth scope, such as for teams and projects
   * @param body 
   * @param pretty If &#39;true&#39;, then the output is pretty printed.
   */
  def createCoreV1NamespacedReplicationController(namespace: String, body: IoK8sApiCoreV1ReplicationController, pretty: Option[String] = None)(implicit apiKey: ApiKeyValue): ApiRequest[IoK8sApiCoreV1ReplicationController] =
    ApiRequest[IoK8sApiCoreV1ReplicationController](ApiMethods.POST, "https://localhost", "/api/v1/namespaces/{namespace}/replicationcontrollers", "*/*")
      .withApiKey(apiKey, "authorization", HEADER)
      .withBody(body)
      .withQueryParam("pretty", pretty)
      .withPathParam("namespace", namespace)
      .withSuccessResponse[IoK8sApiCoreV1ReplicationController](200)
      .withErrorResponse[IoK8sApiCoreV1ReplicationController](201)
      .withErrorResponse[IoK8sApiCoreV1ReplicationController](202)
      .withErrorResponse[Unit](401)
        /**
   * create a ResourceQuota
   * 
   * Expected answers:
   *   code 200 : IoK8sApiCoreV1ResourceQuota (OK)
   *   code 201 : IoK8sApiCoreV1ResourceQuota (Created)
   *   code 202 : IoK8sApiCoreV1ResourceQuota (Accepted)
   *   code 401 :  (Unauthorized)
   * 
   * Available security schemes:
   *   BearerToken (apiKey)
   * 
   * @param namespace object name and auth scope, such as for teams and projects
   * @param body 
   * @param pretty If &#39;true&#39;, then the output is pretty printed.
   */
  def createCoreV1NamespacedResourceQuota(namespace: String, body: IoK8sApiCoreV1ResourceQuota, pretty: Option[String] = None)(implicit apiKey: ApiKeyValue): ApiRequest[IoK8sApiCoreV1ResourceQuota] =
    ApiRequest[IoK8sApiCoreV1ResourceQuota](ApiMethods.POST, "https://localhost", "/api/v1/namespaces/{namespace}/resourcequotas", "*/*")
      .withApiKey(apiKey, "authorization", HEADER)
      .withBody(body)
      .withQueryParam("pretty", pretty)
      .withPathParam("namespace", namespace)
      .withSuccessResponse[IoK8sApiCoreV1ResourceQuota](200)
      .withErrorResponse[IoK8sApiCoreV1ResourceQuota](201)
      .withErrorResponse[IoK8sApiCoreV1ResourceQuota](202)
      .withErrorResponse[Unit](401)
        /**
   * create a Secret
   * 
   * Expected answers:
   *   code 200 : IoK8sApiCoreV1Secret (OK)
   *   code 201 : IoK8sApiCoreV1Secret (Created)
   *   code 202 : IoK8sApiCoreV1Secret (Accepted)
   *   code 401 :  (Unauthorized)
   * 
   * Available security schemes:
   *   BearerToken (apiKey)
   * 
   * @param namespace object name and auth scope, such as for teams and projects
   * @param body 
   * @param pretty If &#39;true&#39;, then the output is pretty printed.
   */
  def createCoreV1NamespacedSecret(namespace: String, body: IoK8sApiCoreV1Secret, pretty: Option[String] = None)(implicit apiKey: ApiKeyValue): ApiRequest[IoK8sApiCoreV1Secret] =
    ApiRequest[IoK8sApiCoreV1Secret](ApiMethods.POST, "https://localhost", "/api/v1/namespaces/{namespace}/secrets", "*/*")
      .withApiKey(apiKey, "authorization", HEADER)
      .withBody(body)
      .withQueryParam("pretty", pretty)
      .withPathParam("namespace", namespace)
      .withSuccessResponse[IoK8sApiCoreV1Secret](200)
      .withErrorResponse[IoK8sApiCoreV1Secret](201)
      .withErrorResponse[IoK8sApiCoreV1Secret](202)
      .withErrorResponse[Unit](401)
        /**
   * create a Service
   * 
   * Expected answers:
   *   code 200 : IoK8sApiCoreV1Service (OK)
   *   code 201 : IoK8sApiCoreV1Service (Created)
   *   code 202 : IoK8sApiCoreV1Service (Accepted)
   *   code 401 :  (Unauthorized)
   * 
   * Available security schemes:
   *   BearerToken (apiKey)
   * 
   * @param namespace object name and auth scope, such as for teams and projects
   * @param body 
   * @param pretty If &#39;true&#39;, then the output is pretty printed.
   */
  def createCoreV1NamespacedService(namespace: String, body: IoK8sApiCoreV1Service, pretty: Option[String] = None)(implicit apiKey: ApiKeyValue): ApiRequest[IoK8sApiCoreV1Service] =
    ApiRequest[IoK8sApiCoreV1Service](ApiMethods.POST, "https://localhost", "/api/v1/namespaces/{namespace}/services", "*/*")
      .withApiKey(apiKey, "authorization", HEADER)
      .withBody(body)
      .withQueryParam("pretty", pretty)
      .withPathParam("namespace", namespace)
      .withSuccessResponse[IoK8sApiCoreV1Service](200)
      .withErrorResponse[IoK8sApiCoreV1Service](201)
      .withErrorResponse[IoK8sApiCoreV1Service](202)
      .withErrorResponse[Unit](401)
        /**
   * create a ServiceAccount
   * 
   * Expected answers:
   *   code 200 : IoK8sApiCoreV1ServiceAccount (OK)
   *   code 201 : IoK8sApiCoreV1ServiceAccount (Created)
   *   code 202 : IoK8sApiCoreV1ServiceAccount (Accepted)
   *   code 401 :  (Unauthorized)
   * 
   * Available security schemes:
   *   BearerToken (apiKey)
   * 
   * @param namespace object name and auth scope, such as for teams and projects
   * @param body 
   * @param pretty If &#39;true&#39;, then the output is pretty printed.
   */
  def createCoreV1NamespacedServiceAccount(namespace: String, body: IoK8sApiCoreV1ServiceAccount, pretty: Option[String] = None)(implicit apiKey: ApiKeyValue): ApiRequest[IoK8sApiCoreV1ServiceAccount] =
    ApiRequest[IoK8sApiCoreV1ServiceAccount](ApiMethods.POST, "https://localhost", "/api/v1/namespaces/{namespace}/serviceaccounts", "*/*")
      .withApiKey(apiKey, "authorization", HEADER)
      .withBody(body)
      .withQueryParam("pretty", pretty)
      .withPathParam("namespace", namespace)
      .withSuccessResponse[IoK8sApiCoreV1ServiceAccount](200)
      .withErrorResponse[IoK8sApiCoreV1ServiceAccount](201)
      .withErrorResponse[IoK8sApiCoreV1ServiceAccount](202)
      .withErrorResponse[Unit](401)
        /**
   * create a Node
   * 
   * Expected answers:
   *   code 200 : IoK8sApiCoreV1Node (OK)
   *   code 201 : IoK8sApiCoreV1Node (Created)
   *   code 202 : IoK8sApiCoreV1Node (Accepted)
   *   code 401 :  (Unauthorized)
   * 
   * Available security schemes:
   *   BearerToken (apiKey)
   * 
   * @param body 
   * @param pretty If &#39;true&#39;, then the output is pretty printed.
   */
  def createCoreV1Node(body: IoK8sApiCoreV1Node, pretty: Option[String] = None)(implicit apiKey: ApiKeyValue): ApiRequest[IoK8sApiCoreV1Node] =
    ApiRequest[IoK8sApiCoreV1Node](ApiMethods.POST, "https://localhost", "/api/v1/nodes", "*/*")
      .withApiKey(apiKey, "authorization", HEADER)
      .withBody(body)
      .withQueryParam("pretty", pretty)
      .withSuccessResponse[IoK8sApiCoreV1Node](200)
      .withErrorResponse[IoK8sApiCoreV1Node](201)
      .withErrorResponse[IoK8sApiCoreV1Node](202)
      .withErrorResponse[Unit](401)
        /**
   * create a PersistentVolume
   * 
   * Expected answers:
   *   code 200 : IoK8sApiCoreV1PersistentVolume (OK)
   *   code 201 : IoK8sApiCoreV1PersistentVolume (Created)
   *   code 202 : IoK8sApiCoreV1PersistentVolume (Accepted)
   *   code 401 :  (Unauthorized)
   * 
   * Available security schemes:
   *   BearerToken (apiKey)
   * 
   * @param body 
   * @param pretty If &#39;true&#39;, then the output is pretty printed.
   */
  def createCoreV1PersistentVolume(body: IoK8sApiCoreV1PersistentVolume, pretty: Option[String] = None)(implicit apiKey: ApiKeyValue): ApiRequest[IoK8sApiCoreV1PersistentVolume] =
    ApiRequest[IoK8sApiCoreV1PersistentVolume](ApiMethods.POST, "https://localhost", "/api/v1/persistentvolumes", "*/*")
      .withApiKey(apiKey, "authorization", HEADER)
      .withBody(body)
      .withQueryParam("pretty", pretty)
      .withSuccessResponse[IoK8sApiCoreV1PersistentVolume](200)
      .withErrorResponse[IoK8sApiCoreV1PersistentVolume](201)
      .withErrorResponse[IoK8sApiCoreV1PersistentVolume](202)
      .withErrorResponse[Unit](401)
        /**
   * delete collection of ConfigMap
   * 
   * Expected answers:
   *   code 200 : IoK8sApimachineryPkgApisMetaV1Status (OK)
   *   code 401 :  (Unauthorized)
   * 
   * Available security schemes:
   *   BearerToken (apiKey)
   * 
   * @param namespace object name and auth scope, such as for teams and projects
   * @param pretty If &#39;true&#39;, then the output is pretty printed.
   * @param continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
   * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
   * @param includeUninitialized If true, partially initialized resources are included in the response.
   * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
   * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
   * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
   * @param timeoutSeconds Timeout for the list/watch call.
   * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
   */
  def deleteCoreV1CollectionNamespacedConfigMap(namespace: String, pretty: Option[String] = None, continue: Option[String] = None, fieldSelector: Option[String] = None, includeUninitialized: Option[Boolean] = None, labelSelector: Option[String] = None, limit: Option[Int] = None, resourceVersion: Option[String] = None, timeoutSeconds: Option[Int] = None, watch: Option[Boolean] = None)(implicit apiKey: ApiKeyValue): ApiRequest[IoK8sApimachineryPkgApisMetaV1Status] =
    ApiRequest[IoK8sApimachineryPkgApisMetaV1Status](ApiMethods.DELETE, "https://localhost", "/api/v1/namespaces/{namespace}/configmaps", "*/*")
      .withApiKey(apiKey, "authorization", HEADER)
      .withQueryParam("pretty", pretty)
      .withQueryParam("continue", continue)
      .withQueryParam("fieldSelector", fieldSelector)
      .withQueryParam("includeUninitialized", includeUninitialized)
      .withQueryParam("labelSelector", labelSelector)
      .withQueryParam("limit", limit)
      .withQueryParam("resourceVersion", resourceVersion)
      .withQueryParam("timeoutSeconds", timeoutSeconds)
      .withQueryParam("watch", watch)
      .withPathParam("namespace", namespace)
      .withSuccessResponse[IoK8sApimachineryPkgApisMetaV1Status](200)
      .withErrorResponse[Unit](401)
        /**
   * delete collection of Endpoints
   * 
   * Expected answers:
   *   code 200 : IoK8sApimachineryPkgApisMetaV1Status (OK)
   *   code 401 :  (Unauthorized)
   * 
   * Available security schemes:
   *   BearerToken (apiKey)
   * 
   * @param namespace object name and auth scope, such as for teams and projects
   * @param pretty If &#39;true&#39;, then the output is pretty printed.
   * @param continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
   * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
   * @param includeUninitialized If true, partially initialized resources are included in the response.
   * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
   * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
   * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
   * @param timeoutSeconds Timeout for the list/watch call.
   * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
   */
  def deleteCoreV1CollectionNamespacedEndpoints(namespace: String, pretty: Option[String] = None, continue: Option[String] = None, fieldSelector: Option[String] = None, includeUninitialized: Option[Boolean] = None, labelSelector: Option[String] = None, limit: Option[Int] = None, resourceVersion: Option[String] = None, timeoutSeconds: Option[Int] = None, watch: Option[Boolean] = None)(implicit apiKey: ApiKeyValue): ApiRequest[IoK8sApimachineryPkgApisMetaV1Status] =
    ApiRequest[IoK8sApimachineryPkgApisMetaV1Status](ApiMethods.DELETE, "https://localhost", "/api/v1/namespaces/{namespace}/endpoints", "*/*")
      .withApiKey(apiKey, "authorization", HEADER)
      .withQueryParam("pretty", pretty)
      .withQueryParam("continue", continue)
      .withQueryParam("fieldSelector", fieldSelector)
      .withQueryParam("includeUninitialized", includeUninitialized)
      .withQueryParam("labelSelector", labelSelector)
      .withQueryParam("limit", limit)
      .withQueryParam("resourceVersion", resourceVersion)
      .withQueryParam("timeoutSeconds", timeoutSeconds)
      .withQueryParam("watch", watch)
      .withPathParam("namespace", namespace)
      .withSuccessResponse[IoK8sApimachineryPkgApisMetaV1Status](200)
      .withErrorResponse[Unit](401)
        /**
   * delete collection of Event
   * 
   * Expected answers:
   *   code 200 : IoK8sApimachineryPkgApisMetaV1Status (OK)
   *   code 401 :  (Unauthorized)
   * 
   * Available security schemes:
   *   BearerToken (apiKey)
   * 
   * @param namespace object name and auth scope, such as for teams and projects
   * @param pretty If &#39;true&#39;, then the output is pretty printed.
   * @param continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
   * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
   * @param includeUninitialized If true, partially initialized resources are included in the response.
   * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
   * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
   * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
   * @param timeoutSeconds Timeout for the list/watch call.
   * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
   */
  def deleteCoreV1CollectionNamespacedEvent(namespace: String, pretty: Option[String] = None, continue: Option[String] = None, fieldSelector: Option[String] = None, includeUninitialized: Option[Boolean] = None, labelSelector: Option[String] = None, limit: Option[Int] = None, resourceVersion: Option[String] = None, timeoutSeconds: Option[Int] = None, watch: Option[Boolean] = None)(implicit apiKey: ApiKeyValue): ApiRequest[IoK8sApimachineryPkgApisMetaV1Status] =
    ApiRequest[IoK8sApimachineryPkgApisMetaV1Status](ApiMethods.DELETE, "https://localhost", "/api/v1/namespaces/{namespace}/events", "*/*")
      .withApiKey(apiKey, "authorization", HEADER)
      .withQueryParam("pretty", pretty)
      .withQueryParam("continue", continue)
      .withQueryParam("fieldSelector", fieldSelector)
      .withQueryParam("includeUninitialized", includeUninitialized)
      .withQueryParam("labelSelector", labelSelector)
      .withQueryParam("limit", limit)
      .withQueryParam("resourceVersion", resourceVersion)
      .withQueryParam("timeoutSeconds", timeoutSeconds)
      .withQueryParam("watch", watch)
      .withPathParam("namespace", namespace)
      .withSuccessResponse[IoK8sApimachineryPkgApisMetaV1Status](200)
      .withErrorResponse[Unit](401)
        /**
   * delete collection of LimitRange
   * 
   * Expected answers:
   *   code 200 : IoK8sApimachineryPkgApisMetaV1Status (OK)
   *   code 401 :  (Unauthorized)
   * 
   * Available security schemes:
   *   BearerToken (apiKey)
   * 
   * @param namespace object name and auth scope, such as for teams and projects
   * @param pretty If &#39;true&#39;, then the output is pretty printed.
   * @param continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
   * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
   * @param includeUninitialized If true, partially initialized resources are included in the response.
   * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
   * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
   * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
   * @param timeoutSeconds Timeout for the list/watch call.
   * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
   */
  def deleteCoreV1CollectionNamespacedLimitRange(namespace: String, pretty: Option[String] = None, continue: Option[String] = None, fieldSelector: Option[String] = None, includeUninitialized: Option[Boolean] = None, labelSelector: Option[String] = None, limit: Option[Int] = None, resourceVersion: Option[String] = None, timeoutSeconds: Option[Int] = None, watch: Option[Boolean] = None)(implicit apiKey: ApiKeyValue): ApiRequest[IoK8sApimachineryPkgApisMetaV1Status] =
    ApiRequest[IoK8sApimachineryPkgApisMetaV1Status](ApiMethods.DELETE, "https://localhost", "/api/v1/namespaces/{namespace}/limitranges", "*/*")
      .withApiKey(apiKey, "authorization", HEADER)
      .withQueryParam("pretty", pretty)
      .withQueryParam("continue", continue)
      .withQueryParam("fieldSelector", fieldSelector)
      .withQueryParam("includeUninitialized", includeUninitialized)
      .withQueryParam("labelSelector", labelSelector)
      .withQueryParam("limit", limit)
      .withQueryParam("resourceVersion", resourceVersion)
      .withQueryParam("timeoutSeconds", timeoutSeconds)
      .withQueryParam("watch", watch)
      .withPathParam("namespace", namespace)
      .withSuccessResponse[IoK8sApimachineryPkgApisMetaV1Status](200)
      .withErrorResponse[Unit](401)
        /**
   * delete collection of PersistentVolumeClaim
   * 
   * Expected answers:
   *   code 200 : IoK8sApimachineryPkgApisMetaV1Status (OK)
   *   code 401 :  (Unauthorized)
   * 
   * Available security schemes:
   *   BearerToken (apiKey)
   * 
   * @param namespace object name and auth scope, such as for teams and projects
   * @param pretty If &#39;true&#39;, then the output is pretty printed.
   * @param continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
   * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
   * @param includeUninitialized If true, partially initialized resources are included in the response.
   * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
   * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
   * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
   * @param timeoutSeconds Timeout for the list/watch call.
   * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
   */
  def deleteCoreV1CollectionNamespacedPersistentVolumeClaim(namespace: String, pretty: Option[String] = None, continue: Option[String] = None, fieldSelector: Option[String] = None, includeUninitialized: Option[Boolean] = None, labelSelector: Option[String] = None, limit: Option[Int] = None, resourceVersion: Option[String] = None, timeoutSeconds: Option[Int] = None, watch: Option[Boolean] = None)(implicit apiKey: ApiKeyValue): ApiRequest[IoK8sApimachineryPkgApisMetaV1Status] =
    ApiRequest[IoK8sApimachineryPkgApisMetaV1Status](ApiMethods.DELETE, "https://localhost", "/api/v1/namespaces/{namespace}/persistentvolumeclaims", "*/*")
      .withApiKey(apiKey, "authorization", HEADER)
      .withQueryParam("pretty", pretty)
      .withQueryParam("continue", continue)
      .withQueryParam("fieldSelector", fieldSelector)
      .withQueryParam("includeUninitialized", includeUninitialized)
      .withQueryParam("labelSelector", labelSelector)
      .withQueryParam("limit", limit)
      .withQueryParam("resourceVersion", resourceVersion)
      .withQueryParam("timeoutSeconds", timeoutSeconds)
      .withQueryParam("watch", watch)
      .withPathParam("namespace", namespace)
      .withSuccessResponse[IoK8sApimachineryPkgApisMetaV1Status](200)
      .withErrorResponse[Unit](401)
        /**
   * delete collection of Pod
   * 
   * Expected answers:
   *   code 200 : IoK8sApimachineryPkgApisMetaV1Status (OK)
   *   code 401 :  (Unauthorized)
   * 
   * Available security schemes:
   *   BearerToken (apiKey)
   * 
   * @param namespace object name and auth scope, such as for teams and projects
   * @param pretty If &#39;true&#39;, then the output is pretty printed.
   * @param continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
   * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
   * @param includeUninitialized If true, partially initialized resources are included in the response.
   * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
   * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
   * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
   * @param timeoutSeconds Timeout for the list/watch call.
   * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
   */
  def deleteCoreV1CollectionNamespacedPod(namespace: String, pretty: Option[String] = None, continue: Option[String] = None, fieldSelector: Option[String] = None, includeUninitialized: Option[Boolean] = None, labelSelector: Option[String] = None, limit: Option[Int] = None, resourceVersion: Option[String] = None, timeoutSeconds: Option[Int] = None, watch: Option[Boolean] = None)(implicit apiKey: ApiKeyValue): ApiRequest[IoK8sApimachineryPkgApisMetaV1Status] =
    ApiRequest[IoK8sApimachineryPkgApisMetaV1Status](ApiMethods.DELETE, "https://localhost", "/api/v1/namespaces/{namespace}/pods", "*/*")
      .withApiKey(apiKey, "authorization", HEADER)
      .withQueryParam("pretty", pretty)
      .withQueryParam("continue", continue)
      .withQueryParam("fieldSelector", fieldSelector)
      .withQueryParam("includeUninitialized", includeUninitialized)
      .withQueryParam("labelSelector", labelSelector)
      .withQueryParam("limit", limit)
      .withQueryParam("resourceVersion", resourceVersion)
      .withQueryParam("timeoutSeconds", timeoutSeconds)
      .withQueryParam("watch", watch)
      .withPathParam("namespace", namespace)
      .withSuccessResponse[IoK8sApimachineryPkgApisMetaV1Status](200)
      .withErrorResponse[Unit](401)
        /**
   * delete collection of PodTemplate
   * 
   * Expected answers:
   *   code 200 : IoK8sApimachineryPkgApisMetaV1Status (OK)
   *   code 401 :  (Unauthorized)
   * 
   * Available security schemes:
   *   BearerToken (apiKey)
   * 
   * @param namespace object name and auth scope, such as for teams and projects
   * @param pretty If &#39;true&#39;, then the output is pretty printed.
   * @param continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
   * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
   * @param includeUninitialized If true, partially initialized resources are included in the response.
   * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
   * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
   * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
   * @param timeoutSeconds Timeout for the list/watch call.
   * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
   */
  def deleteCoreV1CollectionNamespacedPodTemplate(namespace: String, pretty: Option[String] = None, continue: Option[String] = None, fieldSelector: Option[String] = None, includeUninitialized: Option[Boolean] = None, labelSelector: Option[String] = None, limit: Option[Int] = None, resourceVersion: Option[String] = None, timeoutSeconds: Option[Int] = None, watch: Option[Boolean] = None)(implicit apiKey: ApiKeyValue): ApiRequest[IoK8sApimachineryPkgApisMetaV1Status] =
    ApiRequest[IoK8sApimachineryPkgApisMetaV1Status](ApiMethods.DELETE, "https://localhost", "/api/v1/namespaces/{namespace}/podtemplates", "*/*")
      .withApiKey(apiKey, "authorization", HEADER)
      .withQueryParam("pretty", pretty)
      .withQueryParam("continue", continue)
      .withQueryParam("fieldSelector", fieldSelector)
      .withQueryParam("includeUninitialized", includeUninitialized)
      .withQueryParam("labelSelector", labelSelector)
      .withQueryParam("limit", limit)
      .withQueryParam("resourceVersion", resourceVersion)
      .withQueryParam("timeoutSeconds", timeoutSeconds)
      .withQueryParam("watch", watch)
      .withPathParam("namespace", namespace)
      .withSuccessResponse[IoK8sApimachineryPkgApisMetaV1Status](200)
      .withErrorResponse[Unit](401)
        /**
   * delete collection of ReplicationController
   * 
   * Expected answers:
   *   code 200 : IoK8sApimachineryPkgApisMetaV1Status (OK)
   *   code 401 :  (Unauthorized)
   * 
   * Available security schemes:
   *   BearerToken (apiKey)
   * 
   * @param namespace object name and auth scope, such as for teams and projects
   * @param pretty If &#39;true&#39;, then the output is pretty printed.
   * @param continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
   * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
   * @param includeUninitialized If true, partially initialized resources are included in the response.
   * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
   * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
   * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
   * @param timeoutSeconds Timeout for the list/watch call.
   * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
   */
  def deleteCoreV1CollectionNamespacedReplicationController(namespace: String, pretty: Option[String] = None, continue: Option[String] = None, fieldSelector: Option[String] = None, includeUninitialized: Option[Boolean] = None, labelSelector: Option[String] = None, limit: Option[Int] = None, resourceVersion: Option[String] = None, timeoutSeconds: Option[Int] = None, watch: Option[Boolean] = None)(implicit apiKey: ApiKeyValue): ApiRequest[IoK8sApimachineryPkgApisMetaV1Status] =
    ApiRequest[IoK8sApimachineryPkgApisMetaV1Status](ApiMethods.DELETE, "https://localhost", "/api/v1/namespaces/{namespace}/replicationcontrollers", "*/*")
      .withApiKey(apiKey, "authorization", HEADER)
      .withQueryParam("pretty", pretty)
      .withQueryParam("continue", continue)
      .withQueryParam("fieldSelector", fieldSelector)
      .withQueryParam("includeUninitialized", includeUninitialized)
      .withQueryParam("labelSelector", labelSelector)
      .withQueryParam("limit", limit)
      .withQueryParam("resourceVersion", resourceVersion)
      .withQueryParam("timeoutSeconds", timeoutSeconds)
      .withQueryParam("watch", watch)
      .withPathParam("namespace", namespace)
      .withSuccessResponse[IoK8sApimachineryPkgApisMetaV1Status](200)
      .withErrorResponse[Unit](401)
        /**
   * delete collection of ResourceQuota
   * 
   * Expected answers:
   *   code 200 : IoK8sApimachineryPkgApisMetaV1Status (OK)
   *   code 401 :  (Unauthorized)
   * 
   * Available security schemes:
   *   BearerToken (apiKey)
   * 
   * @param namespace object name and auth scope, such as for teams and projects
   * @param pretty If &#39;true&#39;, then the output is pretty printed.
   * @param continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
   * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
   * @param includeUninitialized If true, partially initialized resources are included in the response.
   * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
   * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
   * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
   * @param timeoutSeconds Timeout for the list/watch call.
   * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
   */
  def deleteCoreV1CollectionNamespacedResourceQuota(namespace: String, pretty: Option[String] = None, continue: Option[String] = None, fieldSelector: Option[String] = None, includeUninitialized: Option[Boolean] = None, labelSelector: Option[String] = None, limit: Option[Int] = None, resourceVersion: Option[String] = None, timeoutSeconds: Option[Int] = None, watch: Option[Boolean] = None)(implicit apiKey: ApiKeyValue): ApiRequest[IoK8sApimachineryPkgApisMetaV1Status] =
    ApiRequest[IoK8sApimachineryPkgApisMetaV1Status](ApiMethods.DELETE, "https://localhost", "/api/v1/namespaces/{namespace}/resourcequotas", "*/*")
      .withApiKey(apiKey, "authorization", HEADER)
      .withQueryParam("pretty", pretty)
      .withQueryParam("continue", continue)
      .withQueryParam("fieldSelector", fieldSelector)
      .withQueryParam("includeUninitialized", includeUninitialized)
      .withQueryParam("labelSelector", labelSelector)
      .withQueryParam("limit", limit)
      .withQueryParam("resourceVersion", resourceVersion)
      .withQueryParam("timeoutSeconds", timeoutSeconds)
      .withQueryParam("watch", watch)
      .withPathParam("namespace", namespace)
      .withSuccessResponse[IoK8sApimachineryPkgApisMetaV1Status](200)
      .withErrorResponse[Unit](401)
        /**
   * delete collection of Secret
   * 
   * Expected answers:
   *   code 200 : IoK8sApimachineryPkgApisMetaV1Status (OK)
   *   code 401 :  (Unauthorized)
   * 
   * Available security schemes:
   *   BearerToken (apiKey)
   * 
   * @param namespace object name and auth scope, such as for teams and projects
   * @param pretty If &#39;true&#39;, then the output is pretty printed.
   * @param continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
   * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
   * @param includeUninitialized If true, partially initialized resources are included in the response.
   * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
   * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
   * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
   * @param timeoutSeconds Timeout for the list/watch call.
   * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
   */
  def deleteCoreV1CollectionNamespacedSecret(namespace: String, pretty: Option[String] = None, continue: Option[String] = None, fieldSelector: Option[String] = None, includeUninitialized: Option[Boolean] = None, labelSelector: Option[String] = None, limit: Option[Int] = None, resourceVersion: Option[String] = None, timeoutSeconds: Option[Int] = None, watch: Option[Boolean] = None)(implicit apiKey: ApiKeyValue): ApiRequest[IoK8sApimachineryPkgApisMetaV1Status] =
    ApiRequest[IoK8sApimachineryPkgApisMetaV1Status](ApiMethods.DELETE, "https://localhost", "/api/v1/namespaces/{namespace}/secrets", "*/*")
      .withApiKey(apiKey, "authorization", HEADER)
      .withQueryParam("pretty", pretty)
      .withQueryParam("continue", continue)
      .withQueryParam("fieldSelector", fieldSelector)
      .withQueryParam("includeUninitialized", includeUninitialized)
      .withQueryParam("labelSelector", labelSelector)
      .withQueryParam("limit", limit)
      .withQueryParam("resourceVersion", resourceVersion)
      .withQueryParam("timeoutSeconds", timeoutSeconds)
      .withQueryParam("watch", watch)
      .withPathParam("namespace", namespace)
      .withSuccessResponse[IoK8sApimachineryPkgApisMetaV1Status](200)
      .withErrorResponse[Unit](401)
        /**
   * delete collection of ServiceAccount
   * 
   * Expected answers:
   *   code 200 : IoK8sApimachineryPkgApisMetaV1Status (OK)
   *   code 401 :  (Unauthorized)
   * 
   * Available security schemes:
   *   BearerToken (apiKey)
   * 
   * @param namespace object name and auth scope, such as for teams and projects
   * @param pretty If &#39;true&#39;, then the output is pretty printed.
   * @param continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
   * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
   * @param includeUninitialized If true, partially initialized resources are included in the response.
   * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
   * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
   * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
   * @param timeoutSeconds Timeout for the list/watch call.
   * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
   */
  def deleteCoreV1CollectionNamespacedServiceAccount(namespace: String, pretty: Option[String] = None, continue: Option[String] = None, fieldSelector: Option[String] = None, includeUninitialized: Option[Boolean] = None, labelSelector: Option[String] = None, limit: Option[Int] = None, resourceVersion: Option[String] = None, timeoutSeconds: Option[Int] = None, watch: Option[Boolean] = None)(implicit apiKey: ApiKeyValue): ApiRequest[IoK8sApimachineryPkgApisMetaV1Status] =
    ApiRequest[IoK8sApimachineryPkgApisMetaV1Status](ApiMethods.DELETE, "https://localhost", "/api/v1/namespaces/{namespace}/serviceaccounts", "*/*")
      .withApiKey(apiKey, "authorization", HEADER)
      .withQueryParam("pretty", pretty)
      .withQueryParam("continue", continue)
      .withQueryParam("fieldSelector", fieldSelector)
      .withQueryParam("includeUninitialized", includeUninitialized)
      .withQueryParam("labelSelector", labelSelector)
      .withQueryParam("limit", limit)
      .withQueryParam("resourceVersion", resourceVersion)
      .withQueryParam("timeoutSeconds", timeoutSeconds)
      .withQueryParam("watch", watch)
      .withPathParam("namespace", namespace)
      .withSuccessResponse[IoK8sApimachineryPkgApisMetaV1Status](200)
      .withErrorResponse[Unit](401)
        /**
   * delete collection of Node
   * 
   * Expected answers:
   *   code 200 : IoK8sApimachineryPkgApisMetaV1Status (OK)
   *   code 401 :  (Unauthorized)
   * 
   * Available security schemes:
   *   BearerToken (apiKey)
   * 
   * @param pretty If &#39;true&#39;, then the output is pretty printed.
   * @param continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
   * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
   * @param includeUninitialized If true, partially initialized resources are included in the response.
   * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
   * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
   * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
   * @param timeoutSeconds Timeout for the list/watch call.
   * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
   */
  def deleteCoreV1CollectionNode(pretty: Option[String] = None, continue: Option[String] = None, fieldSelector: Option[String] = None, includeUninitialized: Option[Boolean] = None, labelSelector: Option[String] = None, limit: Option[Int] = None, resourceVersion: Option[String] = None, timeoutSeconds: Option[Int] = None, watch: Option[Boolean] = None)(implicit apiKey: ApiKeyValue): ApiRequest[IoK8sApimachineryPkgApisMetaV1Status] =
    ApiRequest[IoK8sApimachineryPkgApisMetaV1Status](ApiMethods.DELETE, "https://localhost", "/api/v1/nodes", "*/*")
      .withApiKey(apiKey, "authorization", HEADER)
      .withQueryParam("pretty", pretty)
      .withQueryParam("continue", continue)
      .withQueryParam("fieldSelector", fieldSelector)
      .withQueryParam("includeUninitialized", includeUninitialized)
      .withQueryParam("labelSelector", labelSelector)
      .withQueryParam("limit", limit)
      .withQueryParam("resourceVersion", resourceVersion)
      .withQueryParam("timeoutSeconds", timeoutSeconds)
      .withQueryParam("watch", watch)
      .withSuccessResponse[IoK8sApimachineryPkgApisMetaV1Status](200)
      .withErrorResponse[Unit](401)
        /**
   * delete collection of PersistentVolume
   * 
   * Expected answers:
   *   code 200 : IoK8sApimachineryPkgApisMetaV1Status (OK)
   *   code 401 :  (Unauthorized)
   * 
   * Available security schemes:
   *   BearerToken (apiKey)
   * 
   * @param pretty If &#39;true&#39;, then the output is pretty printed.
   * @param continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
   * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
   * @param includeUninitialized If true, partially initialized resources are included in the response.
   * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
   * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
   * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
   * @param timeoutSeconds Timeout for the list/watch call.
   * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
   */
  def deleteCoreV1CollectionPersistentVolume(pretty: Option[String] = None, continue: Option[String] = None, fieldSelector: Option[String] = None, includeUninitialized: Option[Boolean] = None, labelSelector: Option[String] = None, limit: Option[Int] = None, resourceVersion: Option[String] = None, timeoutSeconds: Option[Int] = None, watch: Option[Boolean] = None)(implicit apiKey: ApiKeyValue): ApiRequest[IoK8sApimachineryPkgApisMetaV1Status] =
    ApiRequest[IoK8sApimachineryPkgApisMetaV1Status](ApiMethods.DELETE, "https://localhost", "/api/v1/persistentvolumes", "*/*")
      .withApiKey(apiKey, "authorization", HEADER)
      .withQueryParam("pretty", pretty)
      .withQueryParam("continue", continue)
      .withQueryParam("fieldSelector", fieldSelector)
      .withQueryParam("includeUninitialized", includeUninitialized)
      .withQueryParam("labelSelector", labelSelector)
      .withQueryParam("limit", limit)
      .withQueryParam("resourceVersion", resourceVersion)
      .withQueryParam("timeoutSeconds", timeoutSeconds)
      .withQueryParam("watch", watch)
      .withSuccessResponse[IoK8sApimachineryPkgApisMetaV1Status](200)
      .withErrorResponse[Unit](401)
        /**
   * delete a Namespace
   * 
   * Expected answers:
   *   code 200 : IoK8sApimachineryPkgApisMetaV1Status (OK)
   *   code 401 :  (Unauthorized)
   * 
   * Available security schemes:
   *   BearerToken (apiKey)
   * 
   * @param name name of the Namespace
   * @param body 
   * @param pretty If &#39;true&#39;, then the output is pretty printed.
   * @param gracePeriodSeconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
   * @param orphanDependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
   * @param propagationPolicy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy.
   */
  def deleteCoreV1Namespace(name: String, body: IoK8sApimachineryPkgApisMetaV1DeleteOptions, pretty: Option[String] = None, gracePeriodSeconds: Option[Int] = None, orphanDependents: Option[Boolean] = None, propagationPolicy: Option[String] = None)(implicit apiKey: ApiKeyValue): ApiRequest[IoK8sApimachineryPkgApisMetaV1Status] =
    ApiRequest[IoK8sApimachineryPkgApisMetaV1Status](ApiMethods.DELETE, "https://localhost", "/api/v1/namespaces/{name}", "*/*")
      .withApiKey(apiKey, "authorization", HEADER)
      .withBody(body)
      .withQueryParam("pretty", pretty)
      .withQueryParam("gracePeriodSeconds", gracePeriodSeconds)
      .withQueryParam("orphanDependents", orphanDependents)
      .withQueryParam("propagationPolicy", propagationPolicy)
      .withPathParam("name", name)
      .withSuccessResponse[IoK8sApimachineryPkgApisMetaV1Status](200)
      .withErrorResponse[Unit](401)
        /**
   * delete a ConfigMap
   * 
   * Expected answers:
   *   code 200 : IoK8sApimachineryPkgApisMetaV1Status (OK)
   *   code 401 :  (Unauthorized)
   * 
   * Available security schemes:
   *   BearerToken (apiKey)
   * 
   * @param name name of the ConfigMap
   * @param namespace object name and auth scope, such as for teams and projects
   * @param body 
   * @param pretty If &#39;true&#39;, then the output is pretty printed.
   * @param gracePeriodSeconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
   * @param orphanDependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
   * @param propagationPolicy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy.
   */
  def deleteCoreV1NamespacedConfigMap(name: String, namespace: String, body: IoK8sApimachineryPkgApisMetaV1DeleteOptions, pretty: Option[String] = None, gracePeriodSeconds: Option[Int] = None, orphanDependents: Option[Boolean] = None, propagationPolicy: Option[String] = None)(implicit apiKey: ApiKeyValue): ApiRequest[IoK8sApimachineryPkgApisMetaV1Status] =
    ApiRequest[IoK8sApimachineryPkgApisMetaV1Status](ApiMethods.DELETE, "https://localhost", "/api/v1/namespaces/{namespace}/configmaps/{name}", "*/*")
      .withApiKey(apiKey, "authorization", HEADER)
      .withBody(body)
      .withQueryParam("pretty", pretty)
      .withQueryParam("gracePeriodSeconds", gracePeriodSeconds)
      .withQueryParam("orphanDependents", orphanDependents)
      .withQueryParam("propagationPolicy", propagationPolicy)
      .withPathParam("name", name)
      .withPathParam("namespace", namespace)
      .withSuccessResponse[IoK8sApimachineryPkgApisMetaV1Status](200)
      .withErrorResponse[Unit](401)
        /**
   * delete Endpoints
   * 
   * Expected answers:
   *   code 200 : IoK8sApimachineryPkgApisMetaV1Status (OK)
   *   code 401 :  (Unauthorized)
   * 
   * Available security schemes:
   *   BearerToken (apiKey)
   * 
   * @param name name of the Endpoints
   * @param namespace object name and auth scope, such as for teams and projects
   * @param body 
   * @param pretty If &#39;true&#39;, then the output is pretty printed.
   * @param gracePeriodSeconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
   * @param orphanDependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
   * @param propagationPolicy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy.
   */
  def deleteCoreV1NamespacedEndpoints(name: String, namespace: String, body: IoK8sApimachineryPkgApisMetaV1DeleteOptions, pretty: Option[String] = None, gracePeriodSeconds: Option[Int] = None, orphanDependents: Option[Boolean] = None, propagationPolicy: Option[String] = None)(implicit apiKey: ApiKeyValue): ApiRequest[IoK8sApimachineryPkgApisMetaV1Status] =
    ApiRequest[IoK8sApimachineryPkgApisMetaV1Status](ApiMethods.DELETE, "https://localhost", "/api/v1/namespaces/{namespace}/endpoints/{name}", "*/*")
      .withApiKey(apiKey, "authorization", HEADER)
      .withBody(body)
      .withQueryParam("pretty", pretty)
      .withQueryParam("gracePeriodSeconds", gracePeriodSeconds)
      .withQueryParam("orphanDependents", orphanDependents)
      .withQueryParam("propagationPolicy", propagationPolicy)
      .withPathParam("name", name)
      .withPathParam("namespace", namespace)
      .withSuccessResponse[IoK8sApimachineryPkgApisMetaV1Status](200)
      .withErrorResponse[Unit](401)
        /**
   * delete an Event
   * 
   * Expected answers:
   *   code 200 : IoK8sApimachineryPkgApisMetaV1Status (OK)
   *   code 401 :  (Unauthorized)
   * 
   * Available security schemes:
   *   BearerToken (apiKey)
   * 
   * @param name name of the Event
   * @param namespace object name and auth scope, such as for teams and projects
   * @param body 
   * @param pretty If &#39;true&#39;, then the output is pretty printed.
   * @param gracePeriodSeconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
   * @param orphanDependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
   * @param propagationPolicy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy.
   */
  def deleteCoreV1NamespacedEvent(name: String, namespace: String, body: IoK8sApimachineryPkgApisMetaV1DeleteOptions, pretty: Option[String] = None, gracePeriodSeconds: Option[Int] = None, orphanDependents: Option[Boolean] = None, propagationPolicy: Option[String] = None)(implicit apiKey: ApiKeyValue): ApiRequest[IoK8sApimachineryPkgApisMetaV1Status] =
    ApiRequest[IoK8sApimachineryPkgApisMetaV1Status](ApiMethods.DELETE, "https://localhost", "/api/v1/namespaces/{namespace}/events/{name}", "*/*")
      .withApiKey(apiKey, "authorization", HEADER)
      .withBody(body)
      .withQueryParam("pretty", pretty)
      .withQueryParam("gracePeriodSeconds", gracePeriodSeconds)
      .withQueryParam("orphanDependents", orphanDependents)
      .withQueryParam("propagationPolicy", propagationPolicy)
      .withPathParam("name", name)
      .withPathParam("namespace", namespace)
      .withSuccessResponse[IoK8sApimachineryPkgApisMetaV1Status](200)
      .withErrorResponse[Unit](401)
        /**
   * delete a LimitRange
   * 
   * Expected answers:
   *   code 200 : IoK8sApimachineryPkgApisMetaV1Status (OK)
   *   code 401 :  (Unauthorized)
   * 
   * Available security schemes:
   *   BearerToken (apiKey)
   * 
   * @param name name of the LimitRange
   * @param namespace object name and auth scope, such as for teams and projects
   * @param body 
   * @param pretty If &#39;true&#39;, then the output is pretty printed.
   * @param gracePeriodSeconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
   * @param orphanDependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
   * @param propagationPolicy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy.
   */
  def deleteCoreV1NamespacedLimitRange(name: String, namespace: String, body: IoK8sApimachineryPkgApisMetaV1DeleteOptions, pretty: Option[String] = None, gracePeriodSeconds: Option[Int] = None, orphanDependents: Option[Boolean] = None, propagationPolicy: Option[String] = None)(implicit apiKey: ApiKeyValue): ApiRequest[IoK8sApimachineryPkgApisMetaV1Status] =
    ApiRequest[IoK8sApimachineryPkgApisMetaV1Status](ApiMethods.DELETE, "https://localhost", "/api/v1/namespaces/{namespace}/limitranges/{name}", "*/*")
      .withApiKey(apiKey, "authorization", HEADER)
      .withBody(body)
      .withQueryParam("pretty", pretty)
      .withQueryParam("gracePeriodSeconds", gracePeriodSeconds)
      .withQueryParam("orphanDependents", orphanDependents)
      .withQueryParam("propagationPolicy", propagationPolicy)
      .withPathParam("name", name)
      .withPathParam("namespace", namespace)
      .withSuccessResponse[IoK8sApimachineryPkgApisMetaV1Status](200)
      .withErrorResponse[Unit](401)
        /**
   * delete a PersistentVolumeClaim
   * 
   * Expected answers:
   *   code 200 : IoK8sApimachineryPkgApisMetaV1Status (OK)
   *   code 401 :  (Unauthorized)
   * 
   * Available security schemes:
   *   BearerToken (apiKey)
   * 
   * @param name name of the PersistentVolumeClaim
   * @param namespace object name and auth scope, such as for teams and projects
   * @param body 
   * @param pretty If &#39;true&#39;, then the output is pretty printed.
   * @param gracePeriodSeconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
   * @param orphanDependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
   * @param propagationPolicy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy.
   */
  def deleteCoreV1NamespacedPersistentVolumeClaim(name: String, namespace: String, body: IoK8sApimachineryPkgApisMetaV1DeleteOptions, pretty: Option[String] = None, gracePeriodSeconds: Option[Int] = None, orphanDependents: Option[Boolean] = None, propagationPolicy: Option[String] = None)(implicit apiKey: ApiKeyValue): ApiRequest[IoK8sApimachineryPkgApisMetaV1Status] =
    ApiRequest[IoK8sApimachineryPkgApisMetaV1Status](ApiMethods.DELETE, "https://localhost", "/api/v1/namespaces/{namespace}/persistentvolumeclaims/{name}", "*/*")
      .withApiKey(apiKey, "authorization", HEADER)
      .withBody(body)
      .withQueryParam("pretty", pretty)
      .withQueryParam("gracePeriodSeconds", gracePeriodSeconds)
      .withQueryParam("orphanDependents", orphanDependents)
      .withQueryParam("propagationPolicy", propagationPolicy)
      .withPathParam("name", name)
      .withPathParam("namespace", namespace)
      .withSuccessResponse[IoK8sApimachineryPkgApisMetaV1Status](200)
      .withErrorResponse[Unit](401)
        /**
   * delete a Pod
   * 
   * Expected answers:
   *   code 200 : IoK8sApimachineryPkgApisMetaV1Status (OK)
   *   code 401 :  (Unauthorized)
   * 
   * Available security schemes:
   *   BearerToken (apiKey)
   * 
   * @param name name of the Pod
   * @param namespace object name and auth scope, such as for teams and projects
   * @param body 
   * @param pretty If &#39;true&#39;, then the output is pretty printed.
   * @param gracePeriodSeconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
   * @param orphanDependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
   * @param propagationPolicy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy.
   */
  def deleteCoreV1NamespacedPod(name: String, namespace: String, body: IoK8sApimachineryPkgApisMetaV1DeleteOptions, pretty: Option[String] = None, gracePeriodSeconds: Option[Int] = None, orphanDependents: Option[Boolean] = None, propagationPolicy: Option[String] = None)(implicit apiKey: ApiKeyValue): ApiRequest[IoK8sApimachineryPkgApisMetaV1Status] =
    ApiRequest[IoK8sApimachineryPkgApisMetaV1Status](ApiMethods.DELETE, "https://localhost", "/api/v1/namespaces/{namespace}/pods/{name}", "*/*")
      .withApiKey(apiKey, "authorization", HEADER)
      .withBody(body)
      .withQueryParam("pretty", pretty)
      .withQueryParam("gracePeriodSeconds", gracePeriodSeconds)
      .withQueryParam("orphanDependents", orphanDependents)
      .withQueryParam("propagationPolicy", propagationPolicy)
      .withPathParam("name", name)
      .withPathParam("namespace", namespace)
      .withSuccessResponse[IoK8sApimachineryPkgApisMetaV1Status](200)
      .withErrorResponse[Unit](401)
        /**
   * delete a PodTemplate
   * 
   * Expected answers:
   *   code 200 : IoK8sApimachineryPkgApisMetaV1Status (OK)
   *   code 401 :  (Unauthorized)
   * 
   * Available security schemes:
   *   BearerToken (apiKey)
   * 
   * @param name name of the PodTemplate
   * @param namespace object name and auth scope, such as for teams and projects
   * @param body 
   * @param pretty If &#39;true&#39;, then the output is pretty printed.
   * @param gracePeriodSeconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
   * @param orphanDependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
   * @param propagationPolicy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy.
   */
  def deleteCoreV1NamespacedPodTemplate(name: String, namespace: String, body: IoK8sApimachineryPkgApisMetaV1DeleteOptions, pretty: Option[String] = None, gracePeriodSeconds: Option[Int] = None, orphanDependents: Option[Boolean] = None, propagationPolicy: Option[String] = None)(implicit apiKey: ApiKeyValue): ApiRequest[IoK8sApimachineryPkgApisMetaV1Status] =
    ApiRequest[IoK8sApimachineryPkgApisMetaV1Status](ApiMethods.DELETE, "https://localhost", "/api/v1/namespaces/{namespace}/podtemplates/{name}", "*/*")
      .withApiKey(apiKey, "authorization", HEADER)
      .withBody(body)
      .withQueryParam("pretty", pretty)
      .withQueryParam("gracePeriodSeconds", gracePeriodSeconds)
      .withQueryParam("orphanDependents", orphanDependents)
      .withQueryParam("propagationPolicy", propagationPolicy)
      .withPathParam("name", name)
      .withPathParam("namespace", namespace)
      .withSuccessResponse[IoK8sApimachineryPkgApisMetaV1Status](200)
      .withErrorResponse[Unit](401)
        /**
   * delete a ReplicationController
   * 
   * Expected answers:
   *   code 200 : IoK8sApimachineryPkgApisMetaV1Status (OK)
   *   code 401 :  (Unauthorized)
   * 
   * Available security schemes:
   *   BearerToken (apiKey)
   * 
   * @param name name of the ReplicationController
   * @param namespace object name and auth scope, such as for teams and projects
   * @param body 
   * @param pretty If &#39;true&#39;, then the output is pretty printed.
   * @param gracePeriodSeconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
   * @param orphanDependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
   * @param propagationPolicy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy.
   */
  def deleteCoreV1NamespacedReplicationController(name: String, namespace: String, body: IoK8sApimachineryPkgApisMetaV1DeleteOptions, pretty: Option[String] = None, gracePeriodSeconds: Option[Int] = None, orphanDependents: Option[Boolean] = None, propagationPolicy: Option[String] = None)(implicit apiKey: ApiKeyValue): ApiRequest[IoK8sApimachineryPkgApisMetaV1Status] =
    ApiRequest[IoK8sApimachineryPkgApisMetaV1Status](ApiMethods.DELETE, "https://localhost", "/api/v1/namespaces/{namespace}/replicationcontrollers/{name}", "*/*")
      .withApiKey(apiKey, "authorization", HEADER)
      .withBody(body)
      .withQueryParam("pretty", pretty)
      .withQueryParam("gracePeriodSeconds", gracePeriodSeconds)
      .withQueryParam("orphanDependents", orphanDependents)
      .withQueryParam("propagationPolicy", propagationPolicy)
      .withPathParam("name", name)
      .withPathParam("namespace", namespace)
      .withSuccessResponse[IoK8sApimachineryPkgApisMetaV1Status](200)
      .withErrorResponse[Unit](401)
        /**
   * delete a ResourceQuota
   * 
   * Expected answers:
   *   code 200 : IoK8sApimachineryPkgApisMetaV1Status (OK)
   *   code 401 :  (Unauthorized)
   * 
   * Available security schemes:
   *   BearerToken (apiKey)
   * 
   * @param name name of the ResourceQuota
   * @param namespace object name and auth scope, such as for teams and projects
   * @param body 
   * @param pretty If &#39;true&#39;, then the output is pretty printed.
   * @param gracePeriodSeconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
   * @param orphanDependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
   * @param propagationPolicy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy.
   */
  def deleteCoreV1NamespacedResourceQuota(name: String, namespace: String, body: IoK8sApimachineryPkgApisMetaV1DeleteOptions, pretty: Option[String] = None, gracePeriodSeconds: Option[Int] = None, orphanDependents: Option[Boolean] = None, propagationPolicy: Option[String] = None)(implicit apiKey: ApiKeyValue): ApiRequest[IoK8sApimachineryPkgApisMetaV1Status] =
    ApiRequest[IoK8sApimachineryPkgApisMetaV1Status](ApiMethods.DELETE, "https://localhost", "/api/v1/namespaces/{namespace}/resourcequotas/{name}", "*/*")
      .withApiKey(apiKey, "authorization", HEADER)
      .withBody(body)
      .withQueryParam("pretty", pretty)
      .withQueryParam("gracePeriodSeconds", gracePeriodSeconds)
      .withQueryParam("orphanDependents", orphanDependents)
      .withQueryParam("propagationPolicy", propagationPolicy)
      .withPathParam("name", name)
      .withPathParam("namespace", namespace)
      .withSuccessResponse[IoK8sApimachineryPkgApisMetaV1Status](200)
      .withErrorResponse[Unit](401)
        /**
   * delete a Secret
   * 
   * Expected answers:
   *   code 200 : IoK8sApimachineryPkgApisMetaV1Status (OK)
   *   code 401 :  (Unauthorized)
   * 
   * Available security schemes:
   *   BearerToken (apiKey)
   * 
   * @param name name of the Secret
   * @param namespace object name and auth scope, such as for teams and projects
   * @param body 
   * @param pretty If &#39;true&#39;, then the output is pretty printed.
   * @param gracePeriodSeconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
   * @param orphanDependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
   * @param propagationPolicy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy.
   */
  def deleteCoreV1NamespacedSecret(name: String, namespace: String, body: IoK8sApimachineryPkgApisMetaV1DeleteOptions, pretty: Option[String] = None, gracePeriodSeconds: Option[Int] = None, orphanDependents: Option[Boolean] = None, propagationPolicy: Option[String] = None)(implicit apiKey: ApiKeyValue): ApiRequest[IoK8sApimachineryPkgApisMetaV1Status] =
    ApiRequest[IoK8sApimachineryPkgApisMetaV1Status](ApiMethods.DELETE, "https://localhost", "/api/v1/namespaces/{namespace}/secrets/{name}", "*/*")
      .withApiKey(apiKey, "authorization", HEADER)
      .withBody(body)
      .withQueryParam("pretty", pretty)
      .withQueryParam("gracePeriodSeconds", gracePeriodSeconds)
      .withQueryParam("orphanDependents", orphanDependents)
      .withQueryParam("propagationPolicy", propagationPolicy)
      .withPathParam("name", name)
      .withPathParam("namespace", namespace)
      .withSuccessResponse[IoK8sApimachineryPkgApisMetaV1Status](200)
      .withErrorResponse[Unit](401)
        /**
   * delete a Service
   * 
   * Expected answers:
   *   code 200 : IoK8sApimachineryPkgApisMetaV1Status (OK)
   *   code 401 :  (Unauthorized)
   * 
   * Available security schemes:
   *   BearerToken (apiKey)
   * 
   * @param name name of the Service
   * @param namespace object name and auth scope, such as for teams and projects
   * @param pretty If &#39;true&#39;, then the output is pretty printed.
   */
  def deleteCoreV1NamespacedService(name: String, namespace: String, pretty: Option[String] = None)(implicit apiKey: ApiKeyValue): ApiRequest[IoK8sApimachineryPkgApisMetaV1Status] =
    ApiRequest[IoK8sApimachineryPkgApisMetaV1Status](ApiMethods.DELETE, "https://localhost", "/api/v1/namespaces/{namespace}/services/{name}", "*/*")
      .withApiKey(apiKey, "authorization", HEADER)
      .withQueryParam("pretty", pretty)
      .withPathParam("name", name)
      .withPathParam("namespace", namespace)
      .withSuccessResponse[IoK8sApimachineryPkgApisMetaV1Status](200)
      .withErrorResponse[Unit](401)
        /**
   * delete a ServiceAccount
   * 
   * Expected answers:
   *   code 200 : IoK8sApimachineryPkgApisMetaV1Status (OK)
   *   code 401 :  (Unauthorized)
   * 
   * Available security schemes:
   *   BearerToken (apiKey)
   * 
   * @param name name of the ServiceAccount
   * @param namespace object name and auth scope, such as for teams and projects
   * @param body 
   * @param pretty If &#39;true&#39;, then the output is pretty printed.
   * @param gracePeriodSeconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
   * @param orphanDependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
   * @param propagationPolicy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy.
   */
  def deleteCoreV1NamespacedServiceAccount(name: String, namespace: String, body: IoK8sApimachineryPkgApisMetaV1DeleteOptions, pretty: Option[String] = None, gracePeriodSeconds: Option[Int] = None, orphanDependents: Option[Boolean] = None, propagationPolicy: Option[String] = None)(implicit apiKey: ApiKeyValue): ApiRequest[IoK8sApimachineryPkgApisMetaV1Status] =
    ApiRequest[IoK8sApimachineryPkgApisMetaV1Status](ApiMethods.DELETE, "https://localhost", "/api/v1/namespaces/{namespace}/serviceaccounts/{name}", "*/*")
      .withApiKey(apiKey, "authorization", HEADER)
      .withBody(body)
      .withQueryParam("pretty", pretty)
      .withQueryParam("gracePeriodSeconds", gracePeriodSeconds)
      .withQueryParam("orphanDependents", orphanDependents)
      .withQueryParam("propagationPolicy", propagationPolicy)
      .withPathParam("name", name)
      .withPathParam("namespace", namespace)
      .withSuccessResponse[IoK8sApimachineryPkgApisMetaV1Status](200)
      .withErrorResponse[Unit](401)
        /**
   * delete a Node
   * 
   * Expected answers:
   *   code 200 : IoK8sApimachineryPkgApisMetaV1Status (OK)
   *   code 401 :  (Unauthorized)
   * 
   * Available security schemes:
   *   BearerToken (apiKey)
   * 
   * @param name name of the Node
   * @param body 
   * @param pretty If &#39;true&#39;, then the output is pretty printed.
   * @param gracePeriodSeconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
   * @param orphanDependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
   * @param propagationPolicy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy.
   */
  def deleteCoreV1Node(name: String, body: IoK8sApimachineryPkgApisMetaV1DeleteOptions, pretty: Option[String] = None, gracePeriodSeconds: Option[Int] = None, orphanDependents: Option[Boolean] = None, propagationPolicy: Option[String] = None)(implicit apiKey: ApiKeyValue): ApiRequest[IoK8sApimachineryPkgApisMetaV1Status] =
    ApiRequest[IoK8sApimachineryPkgApisMetaV1Status](ApiMethods.DELETE, "https://localhost", "/api/v1/nodes/{name}", "*/*")
      .withApiKey(apiKey, "authorization", HEADER)
      .withBody(body)
      .withQueryParam("pretty", pretty)
      .withQueryParam("gracePeriodSeconds", gracePeriodSeconds)
      .withQueryParam("orphanDependents", orphanDependents)
      .withQueryParam("propagationPolicy", propagationPolicy)
      .withPathParam("name", name)
      .withSuccessResponse[IoK8sApimachineryPkgApisMetaV1Status](200)
      .withErrorResponse[Unit](401)
        /**
   * delete a PersistentVolume
   * 
   * Expected answers:
   *   code 200 : IoK8sApimachineryPkgApisMetaV1Status (OK)
   *   code 401 :  (Unauthorized)
   * 
   * Available security schemes:
   *   BearerToken (apiKey)
   * 
   * @param name name of the PersistentVolume
   * @param body 
   * @param pretty If &#39;true&#39;, then the output is pretty printed.
   * @param gracePeriodSeconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
   * @param orphanDependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
   * @param propagationPolicy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy.
   */
  def deleteCoreV1PersistentVolume(name: String, body: IoK8sApimachineryPkgApisMetaV1DeleteOptions, pretty: Option[String] = None, gracePeriodSeconds: Option[Int] = None, orphanDependents: Option[Boolean] = None, propagationPolicy: Option[String] = None)(implicit apiKey: ApiKeyValue): ApiRequest[IoK8sApimachineryPkgApisMetaV1Status] =
    ApiRequest[IoK8sApimachineryPkgApisMetaV1Status](ApiMethods.DELETE, "https://localhost", "/api/v1/persistentvolumes/{name}", "*/*")
      .withApiKey(apiKey, "authorization", HEADER)
      .withBody(body)
      .withQueryParam("pretty", pretty)
      .withQueryParam("gracePeriodSeconds", gracePeriodSeconds)
      .withQueryParam("orphanDependents", orphanDependents)
      .withQueryParam("propagationPolicy", propagationPolicy)
      .withPathParam("name", name)
      .withSuccessResponse[IoK8sApimachineryPkgApisMetaV1Status](200)
      .withErrorResponse[Unit](401)
        /**
   * get available resources
   * 
   * Expected answers:
   *   code 200 : IoK8sApimachineryPkgApisMetaV1APIResourceList (OK)
   *   code 401 :  (Unauthorized)
   * 
   * Available security schemes:
   *   BearerToken (apiKey)
   */
  def getCoreV1APIResources()(implicit apiKey: ApiKeyValue): ApiRequest[IoK8sApimachineryPkgApisMetaV1APIResourceList] =
    ApiRequest[IoK8sApimachineryPkgApisMetaV1APIResourceList](ApiMethods.GET, "https://localhost", "/api/v1/", "application/json")
      .withApiKey(apiKey, "authorization", HEADER)
      .withSuccessResponse[IoK8sApimachineryPkgApisMetaV1APIResourceList](200)
      .withErrorResponse[Unit](401)
        /**
   * list objects of kind ComponentStatus
   * 
   * Expected answers:
   *   code 200 : IoK8sApiCoreV1ComponentStatusList (OK)
   *   code 401 :  (Unauthorized)
   * 
   * Available security schemes:
   *   BearerToken (apiKey)
   * 
   * @param continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
   * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
   * @param includeUninitialized If true, partially initialized resources are included in the response.
   * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
   * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
   * @param pretty If &#39;true&#39;, then the output is pretty printed.
   * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
   * @param timeoutSeconds Timeout for the list/watch call.
   * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
   */
  def listCoreV1ComponentStatus(continue: Option[String] = None, fieldSelector: Option[String] = None, includeUninitialized: Option[Boolean] = None, labelSelector: Option[String] = None, limit: Option[Int] = None, pretty: Option[String] = None, resourceVersion: Option[String] = None, timeoutSeconds: Option[Int] = None, watch: Option[Boolean] = None)(implicit apiKey: ApiKeyValue): ApiRequest[IoK8sApiCoreV1ComponentStatusList] =
    ApiRequest[IoK8sApiCoreV1ComponentStatusList](ApiMethods.GET, "https://localhost", "/api/v1/componentstatuses", "*/*")
      .withApiKey(apiKey, "authorization", HEADER)
      .withQueryParam("continue", continue)
      .withQueryParam("fieldSelector", fieldSelector)
      .withQueryParam("includeUninitialized", includeUninitialized)
      .withQueryParam("labelSelector", labelSelector)
      .withQueryParam("limit", limit)
      .withQueryParam("pretty", pretty)
      .withQueryParam("resourceVersion", resourceVersion)
      .withQueryParam("timeoutSeconds", timeoutSeconds)
      .withQueryParam("watch", watch)
      .withSuccessResponse[IoK8sApiCoreV1ComponentStatusList](200)
      .withErrorResponse[Unit](401)
        /**
   * list or watch objects of kind ConfigMap
   * 
   * Expected answers:
   *   code 200 : IoK8sApiCoreV1ConfigMapList (OK)
   *   code 401 :  (Unauthorized)
   * 
   * Available security schemes:
   *   BearerToken (apiKey)
   * 
   * @param continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
   * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
   * @param includeUninitialized If true, partially initialized resources are included in the response.
   * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
   * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
   * @param pretty If &#39;true&#39;, then the output is pretty printed.
   * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
   * @param timeoutSeconds Timeout for the list/watch call.
   * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
   */
  def listCoreV1ConfigMapForAllNamespaces(continue: Option[String] = None, fieldSelector: Option[String] = None, includeUninitialized: Option[Boolean] = None, labelSelector: Option[String] = None, limit: Option[Int] = None, pretty: Option[String] = None, resourceVersion: Option[String] = None, timeoutSeconds: Option[Int] = None, watch: Option[Boolean] = None)(implicit apiKey: ApiKeyValue): ApiRequest[IoK8sApiCoreV1ConfigMapList] =
    ApiRequest[IoK8sApiCoreV1ConfigMapList](ApiMethods.GET, "https://localhost", "/api/v1/configmaps", "*/*")
      .withApiKey(apiKey, "authorization", HEADER)
      .withQueryParam("continue", continue)
      .withQueryParam("fieldSelector", fieldSelector)
      .withQueryParam("includeUninitialized", includeUninitialized)
      .withQueryParam("labelSelector", labelSelector)
      .withQueryParam("limit", limit)
      .withQueryParam("pretty", pretty)
      .withQueryParam("resourceVersion", resourceVersion)
      .withQueryParam("timeoutSeconds", timeoutSeconds)
      .withQueryParam("watch", watch)
      .withSuccessResponse[IoK8sApiCoreV1ConfigMapList](200)
      .withErrorResponse[Unit](401)
        /**
   * list or watch objects of kind Endpoints
   * 
   * Expected answers:
   *   code 200 : IoK8sApiCoreV1EndpointsList (OK)
   *   code 401 :  (Unauthorized)
   * 
   * Available security schemes:
   *   BearerToken (apiKey)
   * 
   * @param continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
   * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
   * @param includeUninitialized If true, partially initialized resources are included in the response.
   * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
   * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
   * @param pretty If &#39;true&#39;, then the output is pretty printed.
   * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
   * @param timeoutSeconds Timeout for the list/watch call.
   * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
   */
  def listCoreV1EndpointsForAllNamespaces(continue: Option[String] = None, fieldSelector: Option[String] = None, includeUninitialized: Option[Boolean] = None, labelSelector: Option[String] = None, limit: Option[Int] = None, pretty: Option[String] = None, resourceVersion: Option[String] = None, timeoutSeconds: Option[Int] = None, watch: Option[Boolean] = None)(implicit apiKey: ApiKeyValue): ApiRequest[IoK8sApiCoreV1EndpointsList] =
    ApiRequest[IoK8sApiCoreV1EndpointsList](ApiMethods.GET, "https://localhost", "/api/v1/endpoints", "*/*")
      .withApiKey(apiKey, "authorization", HEADER)
      .withQueryParam("continue", continue)
      .withQueryParam("fieldSelector", fieldSelector)
      .withQueryParam("includeUninitialized", includeUninitialized)
      .withQueryParam("labelSelector", labelSelector)
      .withQueryParam("limit", limit)
      .withQueryParam("pretty", pretty)
      .withQueryParam("resourceVersion", resourceVersion)
      .withQueryParam("timeoutSeconds", timeoutSeconds)
      .withQueryParam("watch", watch)
      .withSuccessResponse[IoK8sApiCoreV1EndpointsList](200)
      .withErrorResponse[Unit](401)
        /**
   * list or watch objects of kind Event
   * 
   * Expected answers:
   *   code 200 : IoK8sApiCoreV1EventList (OK)
   *   code 401 :  (Unauthorized)
   * 
   * Available security schemes:
   *   BearerToken (apiKey)
   * 
   * @param continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
   * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
   * @param includeUninitialized If true, partially initialized resources are included in the response.
   * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
   * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
   * @param pretty If &#39;true&#39;, then the output is pretty printed.
   * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
   * @param timeoutSeconds Timeout for the list/watch call.
   * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
   */
  def listCoreV1EventForAllNamespaces(continue: Option[String] = None, fieldSelector: Option[String] = None, includeUninitialized: Option[Boolean] = None, labelSelector: Option[String] = None, limit: Option[Int] = None, pretty: Option[String] = None, resourceVersion: Option[String] = None, timeoutSeconds: Option[Int] = None, watch: Option[Boolean] = None)(implicit apiKey: ApiKeyValue): ApiRequest[IoK8sApiCoreV1EventList] =
    ApiRequest[IoK8sApiCoreV1EventList](ApiMethods.GET, "https://localhost", "/api/v1/events", "*/*")
      .withApiKey(apiKey, "authorization", HEADER)
      .withQueryParam("continue", continue)
      .withQueryParam("fieldSelector", fieldSelector)
      .withQueryParam("includeUninitialized", includeUninitialized)
      .withQueryParam("labelSelector", labelSelector)
      .withQueryParam("limit", limit)
      .withQueryParam("pretty", pretty)
      .withQueryParam("resourceVersion", resourceVersion)
      .withQueryParam("timeoutSeconds", timeoutSeconds)
      .withQueryParam("watch", watch)
      .withSuccessResponse[IoK8sApiCoreV1EventList](200)
      .withErrorResponse[Unit](401)
        /**
   * list or watch objects of kind LimitRange
   * 
   * Expected answers:
   *   code 200 : IoK8sApiCoreV1LimitRangeList (OK)
   *   code 401 :  (Unauthorized)
   * 
   * Available security schemes:
   *   BearerToken (apiKey)
   * 
   * @param continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
   * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
   * @param includeUninitialized If true, partially initialized resources are included in the response.
   * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
   * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
   * @param pretty If &#39;true&#39;, then the output is pretty printed.
   * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
   * @param timeoutSeconds Timeout for the list/watch call.
   * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
   */
  def listCoreV1LimitRangeForAllNamespaces(continue: Option[String] = None, fieldSelector: Option[String] = None, includeUninitialized: Option[Boolean] = None, labelSelector: Option[String] = None, limit: Option[Int] = None, pretty: Option[String] = None, resourceVersion: Option[String] = None, timeoutSeconds: Option[Int] = None, watch: Option[Boolean] = None)(implicit apiKey: ApiKeyValue): ApiRequest[IoK8sApiCoreV1LimitRangeList] =
    ApiRequest[IoK8sApiCoreV1LimitRangeList](ApiMethods.GET, "https://localhost", "/api/v1/limitranges", "*/*")
      .withApiKey(apiKey, "authorization", HEADER)
      .withQueryParam("continue", continue)
      .withQueryParam("fieldSelector", fieldSelector)
      .withQueryParam("includeUninitialized", includeUninitialized)
      .withQueryParam("labelSelector", labelSelector)
      .withQueryParam("limit", limit)
      .withQueryParam("pretty", pretty)
      .withQueryParam("resourceVersion", resourceVersion)
      .withQueryParam("timeoutSeconds", timeoutSeconds)
      .withQueryParam("watch", watch)
      .withSuccessResponse[IoK8sApiCoreV1LimitRangeList](200)
      .withErrorResponse[Unit](401)
        /**
   * list or watch objects of kind Namespace
   * 
   * Expected answers:
   *   code 200 : IoK8sApiCoreV1NamespaceList (OK)
   *   code 401 :  (Unauthorized)
   * 
   * Available security schemes:
   *   BearerToken (apiKey)
   * 
   * @param pretty If &#39;true&#39;, then the output is pretty printed.
   * @param continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
   * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
   * @param includeUninitialized If true, partially initialized resources are included in the response.
   * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
   * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
   * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
   * @param timeoutSeconds Timeout for the list/watch call.
   * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
   */
  def listCoreV1Namespace(pretty: Option[String] = None, continue: Option[String] = None, fieldSelector: Option[String] = None, includeUninitialized: Option[Boolean] = None, labelSelector: Option[String] = None, limit: Option[Int] = None, resourceVersion: Option[String] = None, timeoutSeconds: Option[Int] = None, watch: Option[Boolean] = None)(implicit apiKey: ApiKeyValue): ApiRequest[IoK8sApiCoreV1NamespaceList] =
    ApiRequest[IoK8sApiCoreV1NamespaceList](ApiMethods.GET, "https://localhost", "/api/v1/namespaces", "*/*")
      .withApiKey(apiKey, "authorization", HEADER)
      .withQueryParam("pretty", pretty)
      .withQueryParam("continue", continue)
      .withQueryParam("fieldSelector", fieldSelector)
      .withQueryParam("includeUninitialized", includeUninitialized)
      .withQueryParam("labelSelector", labelSelector)
      .withQueryParam("limit", limit)
      .withQueryParam("resourceVersion", resourceVersion)
      .withQueryParam("timeoutSeconds", timeoutSeconds)
      .withQueryParam("watch", watch)
      .withSuccessResponse[IoK8sApiCoreV1NamespaceList](200)
      .withErrorResponse[Unit](401)
        /**
   * list or watch objects of kind ConfigMap
   * 
   * Expected answers:
   *   code 200 : IoK8sApiCoreV1ConfigMapList (OK)
   *   code 401 :  (Unauthorized)
   * 
   * Available security schemes:
   *   BearerToken (apiKey)
   * 
   * @param namespace object name and auth scope, such as for teams and projects
   * @param pretty If &#39;true&#39;, then the output is pretty printed.
   * @param continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
   * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
   * @param includeUninitialized If true, partially initialized resources are included in the response.
   * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
   * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
   * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
   * @param timeoutSeconds Timeout for the list/watch call.
   * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
   */
  def listCoreV1NamespacedConfigMap(namespace: String, pretty: Option[String] = None, continue: Option[String] = None, fieldSelector: Option[String] = None, includeUninitialized: Option[Boolean] = None, labelSelector: Option[String] = None, limit: Option[Int] = None, resourceVersion: Option[String] = None, timeoutSeconds: Option[Int] = None, watch: Option[Boolean] = None)(implicit apiKey: ApiKeyValue): ApiRequest[IoK8sApiCoreV1ConfigMapList] =
    ApiRequest[IoK8sApiCoreV1ConfigMapList](ApiMethods.GET, "https://localhost", "/api/v1/namespaces/{namespace}/configmaps", "*/*")
      .withApiKey(apiKey, "authorization", HEADER)
      .withQueryParam("pretty", pretty)
      .withQueryParam("continue", continue)
      .withQueryParam("fieldSelector", fieldSelector)
      .withQueryParam("includeUninitialized", includeUninitialized)
      .withQueryParam("labelSelector", labelSelector)
      .withQueryParam("limit", limit)
      .withQueryParam("resourceVersion", resourceVersion)
      .withQueryParam("timeoutSeconds", timeoutSeconds)
      .withQueryParam("watch", watch)
      .withPathParam("namespace", namespace)
      .withSuccessResponse[IoK8sApiCoreV1ConfigMapList](200)
      .withErrorResponse[Unit](401)
        /**
   * list or watch objects of kind Endpoints
   * 
   * Expected answers:
   *   code 200 : IoK8sApiCoreV1EndpointsList (OK)
   *   code 401 :  (Unauthorized)
   * 
   * Available security schemes:
   *   BearerToken (apiKey)
   * 
   * @param namespace object name and auth scope, such as for teams and projects
   * @param pretty If &#39;true&#39;, then the output is pretty printed.
   * @param continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
   * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
   * @param includeUninitialized If true, partially initialized resources are included in the response.
   * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
   * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
   * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
   * @param timeoutSeconds Timeout for the list/watch call.
   * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
   */
  def listCoreV1NamespacedEndpoints(namespace: String, pretty: Option[String] = None, continue: Option[String] = None, fieldSelector: Option[String] = None, includeUninitialized: Option[Boolean] = None, labelSelector: Option[String] = None, limit: Option[Int] = None, resourceVersion: Option[String] = None, timeoutSeconds: Option[Int] = None, watch: Option[Boolean] = None)(implicit apiKey: ApiKeyValue): ApiRequest[IoK8sApiCoreV1EndpointsList] =
    ApiRequest[IoK8sApiCoreV1EndpointsList](ApiMethods.GET, "https://localhost", "/api/v1/namespaces/{namespace}/endpoints", "*/*")
      .withApiKey(apiKey, "authorization", HEADER)
      .withQueryParam("pretty", pretty)
      .withQueryParam("continue", continue)
      .withQueryParam("fieldSelector", fieldSelector)
      .withQueryParam("includeUninitialized", includeUninitialized)
      .withQueryParam("labelSelector", labelSelector)
      .withQueryParam("limit", limit)
      .withQueryParam("resourceVersion", resourceVersion)
      .withQueryParam("timeoutSeconds", timeoutSeconds)
      .withQueryParam("watch", watch)
      .withPathParam("namespace", namespace)
      .withSuccessResponse[IoK8sApiCoreV1EndpointsList](200)
      .withErrorResponse[Unit](401)
        /**
   * list or watch objects of kind Event
   * 
   * Expected answers:
   *   code 200 : IoK8sApiCoreV1EventList (OK)
   *   code 401 :  (Unauthorized)
   * 
   * Available security schemes:
   *   BearerToken (apiKey)
   * 
   * @param namespace object name and auth scope, such as for teams and projects
   * @param pretty If &#39;true&#39;, then the output is pretty printed.
   * @param continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
   * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
   * @param includeUninitialized If true, partially initialized resources are included in the response.
   * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
   * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
   * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
   * @param timeoutSeconds Timeout for the list/watch call.
   * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
   */
  def listCoreV1NamespacedEvent(namespace: String, pretty: Option[String] = None, continue: Option[String] = None, fieldSelector: Option[String] = None, includeUninitialized: Option[Boolean] = None, labelSelector: Option[String] = None, limit: Option[Int] = None, resourceVersion: Option[String] = None, timeoutSeconds: Option[Int] = None, watch: Option[Boolean] = None)(implicit apiKey: ApiKeyValue): ApiRequest[IoK8sApiCoreV1EventList] =
    ApiRequest[IoK8sApiCoreV1EventList](ApiMethods.GET, "https://localhost", "/api/v1/namespaces/{namespace}/events", "*/*")
      .withApiKey(apiKey, "authorization", HEADER)
      .withQueryParam("pretty", pretty)
      .withQueryParam("continue", continue)
      .withQueryParam("fieldSelector", fieldSelector)
      .withQueryParam("includeUninitialized", includeUninitialized)
      .withQueryParam("labelSelector", labelSelector)
      .withQueryParam("limit", limit)
      .withQueryParam("resourceVersion", resourceVersion)
      .withQueryParam("timeoutSeconds", timeoutSeconds)
      .withQueryParam("watch", watch)
      .withPathParam("namespace", namespace)
      .withSuccessResponse[IoK8sApiCoreV1EventList](200)
      .withErrorResponse[Unit](401)
        /**
   * list or watch objects of kind LimitRange
   * 
   * Expected answers:
   *   code 200 : IoK8sApiCoreV1LimitRangeList (OK)
   *   code 401 :  (Unauthorized)
   * 
   * Available security schemes:
   *   BearerToken (apiKey)
   * 
   * @param namespace object name and auth scope, such as for teams and projects
   * @param pretty If &#39;true&#39;, then the output is pretty printed.
   * @param continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
   * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
   * @param includeUninitialized If true, partially initialized resources are included in the response.
   * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
   * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
   * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
   * @param timeoutSeconds Timeout for the list/watch call.
   * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
   */
  def listCoreV1NamespacedLimitRange(namespace: String, pretty: Option[String] = None, continue: Option[String] = None, fieldSelector: Option[String] = None, includeUninitialized: Option[Boolean] = None, labelSelector: Option[String] = None, limit: Option[Int] = None, resourceVersion: Option[String] = None, timeoutSeconds: Option[Int] = None, watch: Option[Boolean] = None)(implicit apiKey: ApiKeyValue): ApiRequest[IoK8sApiCoreV1LimitRangeList] =
    ApiRequest[IoK8sApiCoreV1LimitRangeList](ApiMethods.GET, "https://localhost", "/api/v1/namespaces/{namespace}/limitranges", "*/*")
      .withApiKey(apiKey, "authorization", HEADER)
      .withQueryParam("pretty", pretty)
      .withQueryParam("continue", continue)
      .withQueryParam("fieldSelector", fieldSelector)
      .withQueryParam("includeUninitialized", includeUninitialized)
      .withQueryParam("labelSelector", labelSelector)
      .withQueryParam("limit", limit)
      .withQueryParam("resourceVersion", resourceVersion)
      .withQueryParam("timeoutSeconds", timeoutSeconds)
      .withQueryParam("watch", watch)
      .withPathParam("namespace", namespace)
      .withSuccessResponse[IoK8sApiCoreV1LimitRangeList](200)
      .withErrorResponse[Unit](401)
        /**
   * list or watch objects of kind PersistentVolumeClaim
   * 
   * Expected answers:
   *   code 200 : IoK8sApiCoreV1PersistentVolumeClaimList (OK)
   *   code 401 :  (Unauthorized)
   * 
   * Available security schemes:
   *   BearerToken (apiKey)
   * 
   * @param namespace object name and auth scope, such as for teams and projects
   * @param pretty If &#39;true&#39;, then the output is pretty printed.
   * @param continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
   * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
   * @param includeUninitialized If true, partially initialized resources are included in the response.
   * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
   * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
   * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
   * @param timeoutSeconds Timeout for the list/watch call.
   * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
   */
  def listCoreV1NamespacedPersistentVolumeClaim(namespace: String, pretty: Option[String] = None, continue: Option[String] = None, fieldSelector: Option[String] = None, includeUninitialized: Option[Boolean] = None, labelSelector: Option[String] = None, limit: Option[Int] = None, resourceVersion: Option[String] = None, timeoutSeconds: Option[Int] = None, watch: Option[Boolean] = None)(implicit apiKey: ApiKeyValue): ApiRequest[IoK8sApiCoreV1PersistentVolumeClaimList] =
    ApiRequest[IoK8sApiCoreV1PersistentVolumeClaimList](ApiMethods.GET, "https://localhost", "/api/v1/namespaces/{namespace}/persistentvolumeclaims", "*/*")
      .withApiKey(apiKey, "authorization", HEADER)
      .withQueryParam("pretty", pretty)
      .withQueryParam("continue", continue)
      .withQueryParam("fieldSelector", fieldSelector)
      .withQueryParam("includeUninitialized", includeUninitialized)
      .withQueryParam("labelSelector", labelSelector)
      .withQueryParam("limit", limit)
      .withQueryParam("resourceVersion", resourceVersion)
      .withQueryParam("timeoutSeconds", timeoutSeconds)
      .withQueryParam("watch", watch)
      .withPathParam("namespace", namespace)
      .withSuccessResponse[IoK8sApiCoreV1PersistentVolumeClaimList](200)
      .withErrorResponse[Unit](401)
        /**
   * list or watch objects of kind Pod
   * 
   * Expected answers:
   *   code 200 : IoK8sApiCoreV1PodList (OK)
   *   code 401 :  (Unauthorized)
   * 
   * Available security schemes:
   *   BearerToken (apiKey)
   * 
   * @param namespace object name and auth scope, such as for teams and projects
   * @param pretty If &#39;true&#39;, then the output is pretty printed.
   * @param continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
   * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
   * @param includeUninitialized If true, partially initialized resources are included in the response.
   * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
   * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
   * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
   * @param timeoutSeconds Timeout for the list/watch call.
   * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
   */
  def listCoreV1NamespacedPod(namespace: String, pretty: Option[String] = None, continue: Option[String] = None, fieldSelector: Option[String] = None, includeUninitialized: Option[Boolean] = None, labelSelector: Option[String] = None, limit: Option[Int] = None, resourceVersion: Option[String] = None, timeoutSeconds: Option[Int] = None, watch: Option[Boolean] = None)(implicit apiKey: ApiKeyValue): ApiRequest[IoK8sApiCoreV1PodList] =
    ApiRequest[IoK8sApiCoreV1PodList](ApiMethods.GET, "https://localhost", "/api/v1/namespaces/{namespace}/pods", "*/*")
      .withApiKey(apiKey, "authorization", HEADER)
      .withQueryParam("pretty", pretty)
      .withQueryParam("continue", continue)
      .withQueryParam("fieldSelector", fieldSelector)
      .withQueryParam("includeUninitialized", includeUninitialized)
      .withQueryParam("labelSelector", labelSelector)
      .withQueryParam("limit", limit)
      .withQueryParam("resourceVersion", resourceVersion)
      .withQueryParam("timeoutSeconds", timeoutSeconds)
      .withQueryParam("watch", watch)
      .withPathParam("namespace", namespace)
      .withSuccessResponse[IoK8sApiCoreV1PodList](200)
      .withErrorResponse[Unit](401)
        /**
   * list or watch objects of kind PodTemplate
   * 
   * Expected answers:
   *   code 200 : IoK8sApiCoreV1PodTemplateList (OK)
   *   code 401 :  (Unauthorized)
   * 
   * Available security schemes:
   *   BearerToken (apiKey)
   * 
   * @param namespace object name and auth scope, such as for teams and projects
   * @param pretty If &#39;true&#39;, then the output is pretty printed.
   * @param continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
   * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
   * @param includeUninitialized If true, partially initialized resources are included in the response.
   * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
   * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
   * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
   * @param timeoutSeconds Timeout for the list/watch call.
   * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
   */
  def listCoreV1NamespacedPodTemplate(namespace: String, pretty: Option[String] = None, continue: Option[String] = None, fieldSelector: Option[String] = None, includeUninitialized: Option[Boolean] = None, labelSelector: Option[String] = None, limit: Option[Int] = None, resourceVersion: Option[String] = None, timeoutSeconds: Option[Int] = None, watch: Option[Boolean] = None)(implicit apiKey: ApiKeyValue): ApiRequest[IoK8sApiCoreV1PodTemplateList] =
    ApiRequest[IoK8sApiCoreV1PodTemplateList](ApiMethods.GET, "https://localhost", "/api/v1/namespaces/{namespace}/podtemplates", "*/*")
      .withApiKey(apiKey, "authorization", HEADER)
      .withQueryParam("pretty", pretty)
      .withQueryParam("continue", continue)
      .withQueryParam("fieldSelector", fieldSelector)
      .withQueryParam("includeUninitialized", includeUninitialized)
      .withQueryParam("labelSelector", labelSelector)
      .withQueryParam("limit", limit)
      .withQueryParam("resourceVersion", resourceVersion)
      .withQueryParam("timeoutSeconds", timeoutSeconds)
      .withQueryParam("watch", watch)
      .withPathParam("namespace", namespace)
      .withSuccessResponse[IoK8sApiCoreV1PodTemplateList](200)
      .withErrorResponse[Unit](401)
        /**
   * list or watch objects of kind ReplicationController
   * 
   * Expected answers:
   *   code 200 : IoK8sApiCoreV1ReplicationControllerList (OK)
   *   code 401 :  (Unauthorized)
   * 
   * Available security schemes:
   *   BearerToken (apiKey)
   * 
   * @param namespace object name and auth scope, such as for teams and projects
   * @param pretty If &#39;true&#39;, then the output is pretty printed.
   * @param continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
   * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
   * @param includeUninitialized If true, partially initialized resources are included in the response.
   * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
   * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
   * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
   * @param timeoutSeconds Timeout for the list/watch call.
   * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
   */
  def listCoreV1NamespacedReplicationController(namespace: String, pretty: Option[String] = None, continue: Option[String] = None, fieldSelector: Option[String] = None, includeUninitialized: Option[Boolean] = None, labelSelector: Option[String] = None, limit: Option[Int] = None, resourceVersion: Option[String] = None, timeoutSeconds: Option[Int] = None, watch: Option[Boolean] = None)(implicit apiKey: ApiKeyValue): ApiRequest[IoK8sApiCoreV1ReplicationControllerList] =
    ApiRequest[IoK8sApiCoreV1ReplicationControllerList](ApiMethods.GET, "https://localhost", "/api/v1/namespaces/{namespace}/replicationcontrollers", "*/*")
      .withApiKey(apiKey, "authorization", HEADER)
      .withQueryParam("pretty", pretty)
      .withQueryParam("continue", continue)
      .withQueryParam("fieldSelector", fieldSelector)
      .withQueryParam("includeUninitialized", includeUninitialized)
      .withQueryParam("labelSelector", labelSelector)
      .withQueryParam("limit", limit)
      .withQueryParam("resourceVersion", resourceVersion)
      .withQueryParam("timeoutSeconds", timeoutSeconds)
      .withQueryParam("watch", watch)
      .withPathParam("namespace", namespace)
      .withSuccessResponse[IoK8sApiCoreV1ReplicationControllerList](200)
      .withErrorResponse[Unit](401)
        /**
   * list or watch objects of kind ResourceQuota
   * 
   * Expected answers:
   *   code 200 : IoK8sApiCoreV1ResourceQuotaList (OK)
   *   code 401 :  (Unauthorized)
   * 
   * Available security schemes:
   *   BearerToken (apiKey)
   * 
   * @param namespace object name and auth scope, such as for teams and projects
   * @param pretty If &#39;true&#39;, then the output is pretty printed.
   * @param continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
   * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
   * @param includeUninitialized If true, partially initialized resources are included in the response.
   * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
   * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
   * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
   * @param timeoutSeconds Timeout for the list/watch call.
   * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
   */
  def listCoreV1NamespacedResourceQuota(namespace: String, pretty: Option[String] = None, continue: Option[String] = None, fieldSelector: Option[String] = None, includeUninitialized: Option[Boolean] = None, labelSelector: Option[String] = None, limit: Option[Int] = None, resourceVersion: Option[String] = None, timeoutSeconds: Option[Int] = None, watch: Option[Boolean] = None)(implicit apiKey: ApiKeyValue): ApiRequest[IoK8sApiCoreV1ResourceQuotaList] =
    ApiRequest[IoK8sApiCoreV1ResourceQuotaList](ApiMethods.GET, "https://localhost", "/api/v1/namespaces/{namespace}/resourcequotas", "*/*")
      .withApiKey(apiKey, "authorization", HEADER)
      .withQueryParam("pretty", pretty)
      .withQueryParam("continue", continue)
      .withQueryParam("fieldSelector", fieldSelector)
      .withQueryParam("includeUninitialized", includeUninitialized)
      .withQueryParam("labelSelector", labelSelector)
      .withQueryParam("limit", limit)
      .withQueryParam("resourceVersion", resourceVersion)
      .withQueryParam("timeoutSeconds", timeoutSeconds)
      .withQueryParam("watch", watch)
      .withPathParam("namespace", namespace)
      .withSuccessResponse[IoK8sApiCoreV1ResourceQuotaList](200)
      .withErrorResponse[Unit](401)
        /**
   * list or watch objects of kind Secret
   * 
   * Expected answers:
   *   code 200 : IoK8sApiCoreV1SecretList (OK)
   *   code 401 :  (Unauthorized)
   * 
   * Available security schemes:
   *   BearerToken (apiKey)
   * 
   * @param namespace object name and auth scope, such as for teams and projects
   * @param pretty If &#39;true&#39;, then the output is pretty printed.
   * @param continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
   * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
   * @param includeUninitialized If true, partially initialized resources are included in the response.
   * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
   * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
   * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
   * @param timeoutSeconds Timeout for the list/watch call.
   * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
   */
  def listCoreV1NamespacedSecret(namespace: String, pretty: Option[String] = None, continue: Option[String] = None, fieldSelector: Option[String] = None, includeUninitialized: Option[Boolean] = None, labelSelector: Option[String] = None, limit: Option[Int] = None, resourceVersion: Option[String] = None, timeoutSeconds: Option[Int] = None, watch: Option[Boolean] = None)(implicit apiKey: ApiKeyValue): ApiRequest[IoK8sApiCoreV1SecretList] =
    ApiRequest[IoK8sApiCoreV1SecretList](ApiMethods.GET, "https://localhost", "/api/v1/namespaces/{namespace}/secrets", "*/*")
      .withApiKey(apiKey, "authorization", HEADER)
      .withQueryParam("pretty", pretty)
      .withQueryParam("continue", continue)
      .withQueryParam("fieldSelector", fieldSelector)
      .withQueryParam("includeUninitialized", includeUninitialized)
      .withQueryParam("labelSelector", labelSelector)
      .withQueryParam("limit", limit)
      .withQueryParam("resourceVersion", resourceVersion)
      .withQueryParam("timeoutSeconds", timeoutSeconds)
      .withQueryParam("watch", watch)
      .withPathParam("namespace", namespace)
      .withSuccessResponse[IoK8sApiCoreV1SecretList](200)
      .withErrorResponse[Unit](401)
        /**
   * list or watch objects of kind Service
   * 
   * Expected answers:
   *   code 200 : IoK8sApiCoreV1ServiceList (OK)
   *   code 401 :  (Unauthorized)
   * 
   * Available security schemes:
   *   BearerToken (apiKey)
   * 
   * @param namespace object name and auth scope, such as for teams and projects
   * @param pretty If &#39;true&#39;, then the output is pretty printed.
   * @param continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
   * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
   * @param includeUninitialized If true, partially initialized resources are included in the response.
   * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
   * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
   * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
   * @param timeoutSeconds Timeout for the list/watch call.
   * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
   */
  def listCoreV1NamespacedService(namespace: String, pretty: Option[String] = None, continue: Option[String] = None, fieldSelector: Option[String] = None, includeUninitialized: Option[Boolean] = None, labelSelector: Option[String] = None, limit: Option[Int] = None, resourceVersion: Option[String] = None, timeoutSeconds: Option[Int] = None, watch: Option[Boolean] = None)(implicit apiKey: ApiKeyValue): ApiRequest[IoK8sApiCoreV1ServiceList] =
    ApiRequest[IoK8sApiCoreV1ServiceList](ApiMethods.GET, "https://localhost", "/api/v1/namespaces/{namespace}/services", "*/*")
      .withApiKey(apiKey, "authorization", HEADER)
      .withQueryParam("pretty", pretty)
      .withQueryParam("continue", continue)
      .withQueryParam("fieldSelector", fieldSelector)
      .withQueryParam("includeUninitialized", includeUninitialized)
      .withQueryParam("labelSelector", labelSelector)
      .withQueryParam("limit", limit)
      .withQueryParam("resourceVersion", resourceVersion)
      .withQueryParam("timeoutSeconds", timeoutSeconds)
      .withQueryParam("watch", watch)
      .withPathParam("namespace", namespace)
      .withSuccessResponse[IoK8sApiCoreV1ServiceList](200)
      .withErrorResponse[Unit](401)
        /**
   * list or watch objects of kind ServiceAccount
   * 
   * Expected answers:
   *   code 200 : IoK8sApiCoreV1ServiceAccountList (OK)
   *   code 401 :  (Unauthorized)
   * 
   * Available security schemes:
   *   BearerToken (apiKey)
   * 
   * @param namespace object name and auth scope, such as for teams and projects
   * @param pretty If &#39;true&#39;, then the output is pretty printed.
   * @param continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
   * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
   * @param includeUninitialized If true, partially initialized resources are included in the response.
   * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
   * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
   * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
   * @param timeoutSeconds Timeout for the list/watch call.
   * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
   */
  def listCoreV1NamespacedServiceAccount(namespace: String, pretty: Option[String] = None, continue: Option[String] = None, fieldSelector: Option[String] = None, includeUninitialized: Option[Boolean] = None, labelSelector: Option[String] = None, limit: Option[Int] = None, resourceVersion: Option[String] = None, timeoutSeconds: Option[Int] = None, watch: Option[Boolean] = None)(implicit apiKey: ApiKeyValue): ApiRequest[IoK8sApiCoreV1ServiceAccountList] =
    ApiRequest[IoK8sApiCoreV1ServiceAccountList](ApiMethods.GET, "https://localhost", "/api/v1/namespaces/{namespace}/serviceaccounts", "*/*")
      .withApiKey(apiKey, "authorization", HEADER)
      .withQueryParam("pretty", pretty)
      .withQueryParam("continue", continue)
      .withQueryParam("fieldSelector", fieldSelector)
      .withQueryParam("includeUninitialized", includeUninitialized)
      .withQueryParam("labelSelector", labelSelector)
      .withQueryParam("limit", limit)
      .withQueryParam("resourceVersion", resourceVersion)
      .withQueryParam("timeoutSeconds", timeoutSeconds)
      .withQueryParam("watch", watch)
      .withPathParam("namespace", namespace)
      .withSuccessResponse[IoK8sApiCoreV1ServiceAccountList](200)
      .withErrorResponse[Unit](401)
        /**
   * list or watch objects of kind Node
   * 
   * Expected answers:
   *   code 200 : IoK8sApiCoreV1NodeList (OK)
   *   code 401 :  (Unauthorized)
   * 
   * Available security schemes:
   *   BearerToken (apiKey)
   * 
   * @param pretty If &#39;true&#39;, then the output is pretty printed.
   * @param continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
   * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
   * @param includeUninitialized If true, partially initialized resources are included in the response.
   * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
   * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
   * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
   * @param timeoutSeconds Timeout for the list/watch call.
   * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
   */
  def listCoreV1Node(pretty: Option[String] = None, continue: Option[String] = None, fieldSelector: Option[String] = None, includeUninitialized: Option[Boolean] = None, labelSelector: Option[String] = None, limit: Option[Int] = None, resourceVersion: Option[String] = None, timeoutSeconds: Option[Int] = None, watch: Option[Boolean] = None)(implicit apiKey: ApiKeyValue): ApiRequest[IoK8sApiCoreV1NodeList] =
    ApiRequest[IoK8sApiCoreV1NodeList](ApiMethods.GET, "https://localhost", "/api/v1/nodes", "*/*")
      .withApiKey(apiKey, "authorization", HEADER)
      .withQueryParam("pretty", pretty)
      .withQueryParam("continue", continue)
      .withQueryParam("fieldSelector", fieldSelector)
      .withQueryParam("includeUninitialized", includeUninitialized)
      .withQueryParam("labelSelector", labelSelector)
      .withQueryParam("limit", limit)
      .withQueryParam("resourceVersion", resourceVersion)
      .withQueryParam("timeoutSeconds", timeoutSeconds)
      .withQueryParam("watch", watch)
      .withSuccessResponse[IoK8sApiCoreV1NodeList](200)
      .withErrorResponse[Unit](401)
        /**
   * list or watch objects of kind PersistentVolume
   * 
   * Expected answers:
   *   code 200 : IoK8sApiCoreV1PersistentVolumeList (OK)
   *   code 401 :  (Unauthorized)
   * 
   * Available security schemes:
   *   BearerToken (apiKey)
   * 
   * @param pretty If &#39;true&#39;, then the output is pretty printed.
   * @param continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
   * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
   * @param includeUninitialized If true, partially initialized resources are included in the response.
   * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
   * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
   * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
   * @param timeoutSeconds Timeout for the list/watch call.
   * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
   */
  def listCoreV1PersistentVolume(pretty: Option[String] = None, continue: Option[String] = None, fieldSelector: Option[String] = None, includeUninitialized: Option[Boolean] = None, labelSelector: Option[String] = None, limit: Option[Int] = None, resourceVersion: Option[String] = None, timeoutSeconds: Option[Int] = None, watch: Option[Boolean] = None)(implicit apiKey: ApiKeyValue): ApiRequest[IoK8sApiCoreV1PersistentVolumeList] =
    ApiRequest[IoK8sApiCoreV1PersistentVolumeList](ApiMethods.GET, "https://localhost", "/api/v1/persistentvolumes", "*/*")
      .withApiKey(apiKey, "authorization", HEADER)
      .withQueryParam("pretty", pretty)
      .withQueryParam("continue", continue)
      .withQueryParam("fieldSelector", fieldSelector)
      .withQueryParam("includeUninitialized", includeUninitialized)
      .withQueryParam("labelSelector", labelSelector)
      .withQueryParam("limit", limit)
      .withQueryParam("resourceVersion", resourceVersion)
      .withQueryParam("timeoutSeconds", timeoutSeconds)
      .withQueryParam("watch", watch)
      .withSuccessResponse[IoK8sApiCoreV1PersistentVolumeList](200)
      .withErrorResponse[Unit](401)
        /**
   * list or watch objects of kind PersistentVolumeClaim
   * 
   * Expected answers:
   *   code 200 : IoK8sApiCoreV1PersistentVolumeClaimList (OK)
   *   code 401 :  (Unauthorized)
   * 
   * Available security schemes:
   *   BearerToken (apiKey)
   * 
   * @param continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
   * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
   * @param includeUninitialized If true, partially initialized resources are included in the response.
   * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
   * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
   * @param pretty If &#39;true&#39;, then the output is pretty printed.
   * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
   * @param timeoutSeconds Timeout for the list/watch call.
   * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
   */
  def listCoreV1PersistentVolumeClaimForAllNamespaces(continue: Option[String] = None, fieldSelector: Option[String] = None, includeUninitialized: Option[Boolean] = None, labelSelector: Option[String] = None, limit: Option[Int] = None, pretty: Option[String] = None, resourceVersion: Option[String] = None, timeoutSeconds: Option[Int] = None, watch: Option[Boolean] = None)(implicit apiKey: ApiKeyValue): ApiRequest[IoK8sApiCoreV1PersistentVolumeClaimList] =
    ApiRequest[IoK8sApiCoreV1PersistentVolumeClaimList](ApiMethods.GET, "https://localhost", "/api/v1/persistentvolumeclaims", "*/*")
      .withApiKey(apiKey, "authorization", HEADER)
      .withQueryParam("continue", continue)
      .withQueryParam("fieldSelector", fieldSelector)
      .withQueryParam("includeUninitialized", includeUninitialized)
      .withQueryParam("labelSelector", labelSelector)
      .withQueryParam("limit", limit)
      .withQueryParam("pretty", pretty)
      .withQueryParam("resourceVersion", resourceVersion)
      .withQueryParam("timeoutSeconds", timeoutSeconds)
      .withQueryParam("watch", watch)
      .withSuccessResponse[IoK8sApiCoreV1PersistentVolumeClaimList](200)
      .withErrorResponse[Unit](401)
        /**
   * list or watch objects of kind Pod
   * 
   * Expected answers:
   *   code 200 : IoK8sApiCoreV1PodList (OK)
   *   code 401 :  (Unauthorized)
   * 
   * Available security schemes:
   *   BearerToken (apiKey)
   * 
   * @param continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
   * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
   * @param includeUninitialized If true, partially initialized resources are included in the response.
   * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
   * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
   * @param pretty If &#39;true&#39;, then the output is pretty printed.
   * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
   * @param timeoutSeconds Timeout for the list/watch call.
   * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
   */
  def listCoreV1PodForAllNamespaces(continue: Option[String] = None, fieldSelector: Option[String] = None, includeUninitialized: Option[Boolean] = None, labelSelector: Option[String] = None, limit: Option[Int] = None, pretty: Option[String] = None, resourceVersion: Option[String] = None, timeoutSeconds: Option[Int] = None, watch: Option[Boolean] = None)(implicit apiKey: ApiKeyValue): ApiRequest[IoK8sApiCoreV1PodList] =
    ApiRequest[IoK8sApiCoreV1PodList](ApiMethods.GET, "https://localhost", "/api/v1/pods", "*/*")
      .withApiKey(apiKey, "authorization", HEADER)
      .withQueryParam("continue", continue)
      .withQueryParam("fieldSelector", fieldSelector)
      .withQueryParam("includeUninitialized", includeUninitialized)
      .withQueryParam("labelSelector", labelSelector)
      .withQueryParam("limit", limit)
      .withQueryParam("pretty", pretty)
      .withQueryParam("resourceVersion", resourceVersion)
      .withQueryParam("timeoutSeconds", timeoutSeconds)
      .withQueryParam("watch", watch)
      .withSuccessResponse[IoK8sApiCoreV1PodList](200)
      .withErrorResponse[Unit](401)
        /**
   * list or watch objects of kind PodTemplate
   * 
   * Expected answers:
   *   code 200 : IoK8sApiCoreV1PodTemplateList (OK)
   *   code 401 :  (Unauthorized)
   * 
   * Available security schemes:
   *   BearerToken (apiKey)
   * 
   * @param continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
   * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
   * @param includeUninitialized If true, partially initialized resources are included in the response.
   * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
   * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
   * @param pretty If &#39;true&#39;, then the output is pretty printed.
   * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
   * @param timeoutSeconds Timeout for the list/watch call.
   * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
   */
  def listCoreV1PodTemplateForAllNamespaces(continue: Option[String] = None, fieldSelector: Option[String] = None, includeUninitialized: Option[Boolean] = None, labelSelector: Option[String] = None, limit: Option[Int] = None, pretty: Option[String] = None, resourceVersion: Option[String] = None, timeoutSeconds: Option[Int] = None, watch: Option[Boolean] = None)(implicit apiKey: ApiKeyValue): ApiRequest[IoK8sApiCoreV1PodTemplateList] =
    ApiRequest[IoK8sApiCoreV1PodTemplateList](ApiMethods.GET, "https://localhost", "/api/v1/podtemplates", "*/*")
      .withApiKey(apiKey, "authorization", HEADER)
      .withQueryParam("continue", continue)
      .withQueryParam("fieldSelector", fieldSelector)
      .withQueryParam("includeUninitialized", includeUninitialized)
      .withQueryParam("labelSelector", labelSelector)
      .withQueryParam("limit", limit)
      .withQueryParam("pretty", pretty)
      .withQueryParam("resourceVersion", resourceVersion)
      .withQueryParam("timeoutSeconds", timeoutSeconds)
      .withQueryParam("watch", watch)
      .withSuccessResponse[IoK8sApiCoreV1PodTemplateList](200)
      .withErrorResponse[Unit](401)
        /**
   * list or watch objects of kind ReplicationController
   * 
   * Expected answers:
   *   code 200 : IoK8sApiCoreV1ReplicationControllerList (OK)
   *   code 401 :  (Unauthorized)
   * 
   * Available security schemes:
   *   BearerToken (apiKey)
   * 
   * @param continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
   * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
   * @param includeUninitialized If true, partially initialized resources are included in the response.
   * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
   * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
   * @param pretty If &#39;true&#39;, then the output is pretty printed.
   * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
   * @param timeoutSeconds Timeout for the list/watch call.
   * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
   */
  def listCoreV1ReplicationControllerForAllNamespaces(continue: Option[String] = None, fieldSelector: Option[String] = None, includeUninitialized: Option[Boolean] = None, labelSelector: Option[String] = None, limit: Option[Int] = None, pretty: Option[String] = None, resourceVersion: Option[String] = None, timeoutSeconds: Option[Int] = None, watch: Option[Boolean] = None)(implicit apiKey: ApiKeyValue): ApiRequest[IoK8sApiCoreV1ReplicationControllerList] =
    ApiRequest[IoK8sApiCoreV1ReplicationControllerList](ApiMethods.GET, "https://localhost", "/api/v1/replicationcontrollers", "*/*")
      .withApiKey(apiKey, "authorization", HEADER)
      .withQueryParam("continue", continue)
      .withQueryParam("fieldSelector", fieldSelector)
      .withQueryParam("includeUninitialized", includeUninitialized)
      .withQueryParam("labelSelector", labelSelector)
      .withQueryParam("limit", limit)
      .withQueryParam("pretty", pretty)
      .withQueryParam("resourceVersion", resourceVersion)
      .withQueryParam("timeoutSeconds", timeoutSeconds)
      .withQueryParam("watch", watch)
      .withSuccessResponse[IoK8sApiCoreV1ReplicationControllerList](200)
      .withErrorResponse[Unit](401)
        /**
   * list or watch objects of kind ResourceQuota
   * 
   * Expected answers:
   *   code 200 : IoK8sApiCoreV1ResourceQuotaList (OK)
   *   code 401 :  (Unauthorized)
   * 
   * Available security schemes:
   *   BearerToken (apiKey)
   * 
   * @param continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
   * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
   * @param includeUninitialized If true, partially initialized resources are included in the response.
   * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
   * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
   * @param pretty If &#39;true&#39;, then the output is pretty printed.
   * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
   * @param timeoutSeconds Timeout for the list/watch call.
   * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
   */
  def listCoreV1ResourceQuotaForAllNamespaces(continue: Option[String] = None, fieldSelector: Option[String] = None, includeUninitialized: Option[Boolean] = None, labelSelector: Option[String] = None, limit: Option[Int] = None, pretty: Option[String] = None, resourceVersion: Option[String] = None, timeoutSeconds: Option[Int] = None, watch: Option[Boolean] = None)(implicit apiKey: ApiKeyValue): ApiRequest[IoK8sApiCoreV1ResourceQuotaList] =
    ApiRequest[IoK8sApiCoreV1ResourceQuotaList](ApiMethods.GET, "https://localhost", "/api/v1/resourcequotas", "*/*")
      .withApiKey(apiKey, "authorization", HEADER)
      .withQueryParam("continue", continue)
      .withQueryParam("fieldSelector", fieldSelector)
      .withQueryParam("includeUninitialized", includeUninitialized)
      .withQueryParam("labelSelector", labelSelector)
      .withQueryParam("limit", limit)
      .withQueryParam("pretty", pretty)
      .withQueryParam("resourceVersion", resourceVersion)
      .withQueryParam("timeoutSeconds", timeoutSeconds)
      .withQueryParam("watch", watch)
      .withSuccessResponse[IoK8sApiCoreV1ResourceQuotaList](200)
      .withErrorResponse[Unit](401)
        /**
   * list or watch objects of kind Secret
   * 
   * Expected answers:
   *   code 200 : IoK8sApiCoreV1SecretList (OK)
   *   code 401 :  (Unauthorized)
   * 
   * Available security schemes:
   *   BearerToken (apiKey)
   * 
   * @param continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
   * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
   * @param includeUninitialized If true, partially initialized resources are included in the response.
   * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
   * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
   * @param pretty If &#39;true&#39;, then the output is pretty printed.
   * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
   * @param timeoutSeconds Timeout for the list/watch call.
   * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
   */
  def listCoreV1SecretForAllNamespaces(continue: Option[String] = None, fieldSelector: Option[String] = None, includeUninitialized: Option[Boolean] = None, labelSelector: Option[String] = None, limit: Option[Int] = None, pretty: Option[String] = None, resourceVersion: Option[String] = None, timeoutSeconds: Option[Int] = None, watch: Option[Boolean] = None)(implicit apiKey: ApiKeyValue): ApiRequest[IoK8sApiCoreV1SecretList] =
    ApiRequest[IoK8sApiCoreV1SecretList](ApiMethods.GET, "https://localhost", "/api/v1/secrets", "*/*")
      .withApiKey(apiKey, "authorization", HEADER)
      .withQueryParam("continue", continue)
      .withQueryParam("fieldSelector", fieldSelector)
      .withQueryParam("includeUninitialized", includeUninitialized)
      .withQueryParam("labelSelector", labelSelector)
      .withQueryParam("limit", limit)
      .withQueryParam("pretty", pretty)
      .withQueryParam("resourceVersion", resourceVersion)
      .withQueryParam("timeoutSeconds", timeoutSeconds)
      .withQueryParam("watch", watch)
      .withSuccessResponse[IoK8sApiCoreV1SecretList](200)
      .withErrorResponse[Unit](401)
        /**
   * list or watch objects of kind ServiceAccount
   * 
   * Expected answers:
   *   code 200 : IoK8sApiCoreV1ServiceAccountList (OK)
   *   code 401 :  (Unauthorized)
   * 
   * Available security schemes:
   *   BearerToken (apiKey)
   * 
   * @param continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
   * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
   * @param includeUninitialized If true, partially initialized resources are included in the response.
   * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
   * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
   * @param pretty If &#39;true&#39;, then the output is pretty printed.
   * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
   * @param timeoutSeconds Timeout for the list/watch call.
   * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
   */
  def listCoreV1ServiceAccountForAllNamespaces(continue: Option[String] = None, fieldSelector: Option[String] = None, includeUninitialized: Option[Boolean] = None, labelSelector: Option[String] = None, limit: Option[Int] = None, pretty: Option[String] = None, resourceVersion: Option[String] = None, timeoutSeconds: Option[Int] = None, watch: Option[Boolean] = None)(implicit apiKey: ApiKeyValue): ApiRequest[IoK8sApiCoreV1ServiceAccountList] =
    ApiRequest[IoK8sApiCoreV1ServiceAccountList](ApiMethods.GET, "https://localhost", "/api/v1/serviceaccounts", "*/*")
      .withApiKey(apiKey, "authorization", HEADER)
      .withQueryParam("continue", continue)
      .withQueryParam("fieldSelector", fieldSelector)
      .withQueryParam("includeUninitialized", includeUninitialized)
      .withQueryParam("labelSelector", labelSelector)
      .withQueryParam("limit", limit)
      .withQueryParam("pretty", pretty)
      .withQueryParam("resourceVersion", resourceVersion)
      .withQueryParam("timeoutSeconds", timeoutSeconds)
      .withQueryParam("watch", watch)
      .withSuccessResponse[IoK8sApiCoreV1ServiceAccountList](200)
      .withErrorResponse[Unit](401)
        /**
   * list or watch objects of kind Service
   * 
   * Expected answers:
   *   code 200 : IoK8sApiCoreV1ServiceList (OK)
   *   code 401 :  (Unauthorized)
   * 
   * Available security schemes:
   *   BearerToken (apiKey)
   * 
   * @param continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
   * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
   * @param includeUninitialized If true, partially initialized resources are included in the response.
   * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
   * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
   * @param pretty If &#39;true&#39;, then the output is pretty printed.
   * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
   * @param timeoutSeconds Timeout for the list/watch call.
   * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
   */
  def listCoreV1ServiceForAllNamespaces(continue: Option[String] = None, fieldSelector: Option[String] = None, includeUninitialized: Option[Boolean] = None, labelSelector: Option[String] = None, limit: Option[Int] = None, pretty: Option[String] = None, resourceVersion: Option[String] = None, timeoutSeconds: Option[Int] = None, watch: Option[Boolean] = None)(implicit apiKey: ApiKeyValue): ApiRequest[IoK8sApiCoreV1ServiceList] =
    ApiRequest[IoK8sApiCoreV1ServiceList](ApiMethods.GET, "https://localhost", "/api/v1/services", "*/*")
      .withApiKey(apiKey, "authorization", HEADER)
      .withQueryParam("continue", continue)
      .withQueryParam("fieldSelector", fieldSelector)
      .withQueryParam("includeUninitialized", includeUninitialized)
      .withQueryParam("labelSelector", labelSelector)
      .withQueryParam("limit", limit)
      .withQueryParam("pretty", pretty)
      .withQueryParam("resourceVersion", resourceVersion)
      .withQueryParam("timeoutSeconds", timeoutSeconds)
      .withQueryParam("watch", watch)
      .withSuccessResponse[IoK8sApiCoreV1ServiceList](200)
      .withErrorResponse[Unit](401)
        /**
   * partially update the specified Namespace
   * 
   * Expected answers:
   *   code 200 : IoK8sApiCoreV1Namespace (OK)
   *   code 401 :  (Unauthorized)
   * 
   * Available security schemes:
   *   BearerToken (apiKey)
   * 
   * @param name name of the Namespace
   * @param body 
   * @param pretty If &#39;true&#39;, then the output is pretty printed.
   */
  def patchCoreV1Namespace(name: String, body: IoK8sApimachineryPkgApisMetaV1Patch, pretty: Option[String] = None)(implicit apiKey: ApiKeyValue): ApiRequest[IoK8sApiCoreV1Namespace] =
    ApiRequest[IoK8sApiCoreV1Namespace](ApiMethods.PATCH, "https://localhost", "/api/v1/namespaces/{name}", "application/json-patch+json")
      .withApiKey(apiKey, "authorization", HEADER)
      .withBody(body)
      .withQueryParam("pretty", pretty)
      .withPathParam("name", name)
      .withSuccessResponse[IoK8sApiCoreV1Namespace](200)
      .withErrorResponse[Unit](401)
        /**
   * partially update status of the specified Namespace
   * 
   * Expected answers:
   *   code 200 : IoK8sApiCoreV1Namespace (OK)
   *   code 401 :  (Unauthorized)
   * 
   * Available security schemes:
   *   BearerToken (apiKey)
   * 
   * @param name name of the Namespace
   * @param body 
   * @param pretty If &#39;true&#39;, then the output is pretty printed.
   */
  def patchCoreV1NamespaceStatus(name: String, body: IoK8sApimachineryPkgApisMetaV1Patch, pretty: Option[String] = None)(implicit apiKey: ApiKeyValue): ApiRequest[IoK8sApiCoreV1Namespace] =
    ApiRequest[IoK8sApiCoreV1Namespace](ApiMethods.PATCH, "https://localhost", "/api/v1/namespaces/{name}/status", "application/json-patch+json")
      .withApiKey(apiKey, "authorization", HEADER)
      .withBody(body)
      .withQueryParam("pretty", pretty)
      .withPathParam("name", name)
      .withSuccessResponse[IoK8sApiCoreV1Namespace](200)
      .withErrorResponse[Unit](401)
        /**
   * partially update the specified ConfigMap
   * 
   * Expected answers:
   *   code 200 : IoK8sApiCoreV1ConfigMap (OK)
   *   code 401 :  (Unauthorized)
   * 
   * Available security schemes:
   *   BearerToken (apiKey)
   * 
   * @param name name of the ConfigMap
   * @param namespace object name and auth scope, such as for teams and projects
   * @param body 
   * @param pretty If &#39;true&#39;, then the output is pretty printed.
   */
  def patchCoreV1NamespacedConfigMap(name: String, namespace: String, body: IoK8sApimachineryPkgApisMetaV1Patch, pretty: Option[String] = None)(implicit apiKey: ApiKeyValue): ApiRequest[IoK8sApiCoreV1ConfigMap] =
    ApiRequest[IoK8sApiCoreV1ConfigMap](ApiMethods.PATCH, "https://localhost", "/api/v1/namespaces/{namespace}/configmaps/{name}", "application/json-patch+json")
      .withApiKey(apiKey, "authorization", HEADER)
      .withBody(body)
      .withQueryParam("pretty", pretty)
      .withPathParam("name", name)
      .withPathParam("namespace", namespace)
      .withSuccessResponse[IoK8sApiCoreV1ConfigMap](200)
      .withErrorResponse[Unit](401)
        /**
   * partially update the specified Endpoints
   * 
   * Expected answers:
   *   code 200 : IoK8sApiCoreV1Endpoints (OK)
   *   code 401 :  (Unauthorized)
   * 
   * Available security schemes:
   *   BearerToken (apiKey)
   * 
   * @param name name of the Endpoints
   * @param namespace object name and auth scope, such as for teams and projects
   * @param body 
   * @param pretty If &#39;true&#39;, then the output is pretty printed.
   */
  def patchCoreV1NamespacedEndpoints(name: String, namespace: String, body: IoK8sApimachineryPkgApisMetaV1Patch, pretty: Option[String] = None)(implicit apiKey: ApiKeyValue): ApiRequest[IoK8sApiCoreV1Endpoints] =
    ApiRequest[IoK8sApiCoreV1Endpoints](ApiMethods.PATCH, "https://localhost", "/api/v1/namespaces/{namespace}/endpoints/{name}", "application/json-patch+json")
      .withApiKey(apiKey, "authorization", HEADER)
      .withBody(body)
      .withQueryParam("pretty", pretty)
      .withPathParam("name", name)
      .withPathParam("namespace", namespace)
      .withSuccessResponse[IoK8sApiCoreV1Endpoints](200)
      .withErrorResponse[Unit](401)
        /**
   * partially update the specified Event
   * 
   * Expected answers:
   *   code 200 : IoK8sApiCoreV1Event (OK)
   *   code 401 :  (Unauthorized)
   * 
   * Available security schemes:
   *   BearerToken (apiKey)
   * 
   * @param name name of the Event
   * @param namespace object name and auth scope, such as for teams and projects
   * @param body 
   * @param pretty If &#39;true&#39;, then the output is pretty printed.
   */
  def patchCoreV1NamespacedEvent(name: String, namespace: String, body: IoK8sApimachineryPkgApisMetaV1Patch, pretty: Option[String] = None)(implicit apiKey: ApiKeyValue): ApiRequest[IoK8sApiCoreV1Event] =
    ApiRequest[IoK8sApiCoreV1Event](ApiMethods.PATCH, "https://localhost", "/api/v1/namespaces/{namespace}/events/{name}", "application/json-patch+json")
      .withApiKey(apiKey, "authorization", HEADER)
      .withBody(body)
      .withQueryParam("pretty", pretty)
      .withPathParam("name", name)
      .withPathParam("namespace", namespace)
      .withSuccessResponse[IoK8sApiCoreV1Event](200)
      .withErrorResponse[Unit](401)
        /**
   * partially update the specified LimitRange
   * 
   * Expected answers:
   *   code 200 : IoK8sApiCoreV1LimitRange (OK)
   *   code 401 :  (Unauthorized)
   * 
   * Available security schemes:
   *   BearerToken (apiKey)
   * 
   * @param name name of the LimitRange
   * @param namespace object name and auth scope, such as for teams and projects
   * @param body 
   * @param pretty If &#39;true&#39;, then the output is pretty printed.
   */
  def patchCoreV1NamespacedLimitRange(name: String, namespace: String, body: IoK8sApimachineryPkgApisMetaV1Patch, pretty: Option[String] = None)(implicit apiKey: ApiKeyValue): ApiRequest[IoK8sApiCoreV1LimitRange] =
    ApiRequest[IoK8sApiCoreV1LimitRange](ApiMethods.PATCH, "https://localhost", "/api/v1/namespaces/{namespace}/limitranges/{name}", "application/json-patch+json")
      .withApiKey(apiKey, "authorization", HEADER)
      .withBody(body)
      .withQueryParam("pretty", pretty)
      .withPathParam("name", name)
      .withPathParam("namespace", namespace)
      .withSuccessResponse[IoK8sApiCoreV1LimitRange](200)
      .withErrorResponse[Unit](401)
        /**
   * partially update the specified PersistentVolumeClaim
   * 
   * Expected answers:
   *   code 200 : IoK8sApiCoreV1PersistentVolumeClaim (OK)
   *   code 401 :  (Unauthorized)
   * 
   * Available security schemes:
   *   BearerToken (apiKey)
   * 
   * @param name name of the PersistentVolumeClaim
   * @param namespace object name and auth scope, such as for teams and projects
   * @param body 
   * @param pretty If &#39;true&#39;, then the output is pretty printed.
   */
  def patchCoreV1NamespacedPersistentVolumeClaim(name: String, namespace: String, body: IoK8sApimachineryPkgApisMetaV1Patch, pretty: Option[String] = None)(implicit apiKey: ApiKeyValue): ApiRequest[IoK8sApiCoreV1PersistentVolumeClaim] =
    ApiRequest[IoK8sApiCoreV1PersistentVolumeClaim](ApiMethods.PATCH, "https://localhost", "/api/v1/namespaces/{namespace}/persistentvolumeclaims/{name}", "application/json-patch+json")
      .withApiKey(apiKey, "authorization", HEADER)
      .withBody(body)
      .withQueryParam("pretty", pretty)
      .withPathParam("name", name)
      .withPathParam("namespace", namespace)
      .withSuccessResponse[IoK8sApiCoreV1PersistentVolumeClaim](200)
      .withErrorResponse[Unit](401)
        /**
   * partially update status of the specified PersistentVolumeClaim
   * 
   * Expected answers:
   *   code 200 : IoK8sApiCoreV1PersistentVolumeClaim (OK)
   *   code 401 :  (Unauthorized)
   * 
   * Available security schemes:
   *   BearerToken (apiKey)
   * 
   * @param name name of the PersistentVolumeClaim
   * @param namespace object name and auth scope, such as for teams and projects
   * @param body 
   * @param pretty If &#39;true&#39;, then the output is pretty printed.
   */
  def patchCoreV1NamespacedPersistentVolumeClaimStatus(name: String, namespace: String, body: IoK8sApimachineryPkgApisMetaV1Patch, pretty: Option[String] = None)(implicit apiKey: ApiKeyValue): ApiRequest[IoK8sApiCoreV1PersistentVolumeClaim] =
    ApiRequest[IoK8sApiCoreV1PersistentVolumeClaim](ApiMethods.PATCH, "https://localhost", "/api/v1/namespaces/{namespace}/persistentvolumeclaims/{name}/status", "application/json-patch+json")
      .withApiKey(apiKey, "authorization", HEADER)
      .withBody(body)
      .withQueryParam("pretty", pretty)
      .withPathParam("name", name)
      .withPathParam("namespace", namespace)
      .withSuccessResponse[IoK8sApiCoreV1PersistentVolumeClaim](200)
      .withErrorResponse[Unit](401)
        /**
   * partially update the specified Pod
   * 
   * Expected answers:
   *   code 200 : IoK8sApiCoreV1Pod (OK)
   *   code 401 :  (Unauthorized)
   * 
   * Available security schemes:
   *   BearerToken (apiKey)
   * 
   * @param name name of the Pod
   * @param namespace object name and auth scope, such as for teams and projects
   * @param body 
   * @param pretty If &#39;true&#39;, then the output is pretty printed.
   */
  def patchCoreV1NamespacedPod(name: String, namespace: String, body: IoK8sApimachineryPkgApisMetaV1Patch, pretty: Option[String] = None)(implicit apiKey: ApiKeyValue): ApiRequest[IoK8sApiCoreV1Pod] =
    ApiRequest[IoK8sApiCoreV1Pod](ApiMethods.PATCH, "https://localhost", "/api/v1/namespaces/{namespace}/pods/{name}", "application/json-patch+json")
      .withApiKey(apiKey, "authorization", HEADER)
      .withBody(body)
      .withQueryParam("pretty", pretty)
      .withPathParam("name", name)
      .withPathParam("namespace", namespace)
      .withSuccessResponse[IoK8sApiCoreV1Pod](200)
      .withErrorResponse[Unit](401)
        /**
   * partially update status of the specified Pod
   * 
   * Expected answers:
   *   code 200 : IoK8sApiCoreV1Pod (OK)
   *   code 401 :  (Unauthorized)
   * 
   * Available security schemes:
   *   BearerToken (apiKey)
   * 
   * @param name name of the Pod
   * @param namespace object name and auth scope, such as for teams and projects
   * @param body 
   * @param pretty If &#39;true&#39;, then the output is pretty printed.
   */
  def patchCoreV1NamespacedPodStatus(name: String, namespace: String, body: IoK8sApimachineryPkgApisMetaV1Patch, pretty: Option[String] = None)(implicit apiKey: ApiKeyValue): ApiRequest[IoK8sApiCoreV1Pod] =
    ApiRequest[IoK8sApiCoreV1Pod](ApiMethods.PATCH, "https://localhost", "/api/v1/namespaces/{namespace}/pods/{name}/status", "application/json-patch+json")
      .withApiKey(apiKey, "authorization", HEADER)
      .withBody(body)
      .withQueryParam("pretty", pretty)
      .withPathParam("name", name)
      .withPathParam("namespace", namespace)
      .withSuccessResponse[IoK8sApiCoreV1Pod](200)
      .withErrorResponse[Unit](401)
        /**
   * partially update the specified PodTemplate
   * 
   * Expected answers:
   *   code 200 : IoK8sApiCoreV1PodTemplate (OK)
   *   code 401 :  (Unauthorized)
   * 
   * Available security schemes:
   *   BearerToken (apiKey)
   * 
   * @param name name of the PodTemplate
   * @param namespace object name and auth scope, such as for teams and projects
   * @param body 
   * @param pretty If &#39;true&#39;, then the output is pretty printed.
   */
  def patchCoreV1NamespacedPodTemplate(name: String, namespace: String, body: IoK8sApimachineryPkgApisMetaV1Patch, pretty: Option[String] = None)(implicit apiKey: ApiKeyValue): ApiRequest[IoK8sApiCoreV1PodTemplate] =
    ApiRequest[IoK8sApiCoreV1PodTemplate](ApiMethods.PATCH, "https://localhost", "/api/v1/namespaces/{namespace}/podtemplates/{name}", "application/json-patch+json")
      .withApiKey(apiKey, "authorization", HEADER)
      .withBody(body)
      .withQueryParam("pretty", pretty)
      .withPathParam("name", name)
      .withPathParam("namespace", namespace)
      .withSuccessResponse[IoK8sApiCoreV1PodTemplate](200)
      .withErrorResponse[Unit](401)
        /**
   * partially update the specified ReplicationController
   * 
   * Expected answers:
   *   code 200 : IoK8sApiCoreV1ReplicationController (OK)
   *   code 401 :  (Unauthorized)
   * 
   * Available security schemes:
   *   BearerToken (apiKey)
   * 
   * @param name name of the ReplicationController
   * @param namespace object name and auth scope, such as for teams and projects
   * @param body 
   * @param pretty If &#39;true&#39;, then the output is pretty printed.
   */
  def patchCoreV1NamespacedReplicationController(name: String, namespace: String, body: IoK8sApimachineryPkgApisMetaV1Patch, pretty: Option[String] = None)(implicit apiKey: ApiKeyValue): ApiRequest[IoK8sApiCoreV1ReplicationController] =
    ApiRequest[IoK8sApiCoreV1ReplicationController](ApiMethods.PATCH, "https://localhost", "/api/v1/namespaces/{namespace}/replicationcontrollers/{name}", "application/json-patch+json")
      .withApiKey(apiKey, "authorization", HEADER)
      .withBody(body)
      .withQueryParam("pretty", pretty)
      .withPathParam("name", name)
      .withPathParam("namespace", namespace)
      .withSuccessResponse[IoK8sApiCoreV1ReplicationController](200)
      .withErrorResponse[Unit](401)
        /**
   * partially update scale of the specified ReplicationController
   * 
   * Expected answers:
   *   code 200 : IoK8sApiAutoscalingV1Scale (OK)
   *   code 401 :  (Unauthorized)
   * 
   * Available security schemes:
   *   BearerToken (apiKey)
   * 
   * @param name name of the Scale
   * @param namespace object name and auth scope, such as for teams and projects
   * @param body 
   * @param pretty If &#39;true&#39;, then the output is pretty printed.
   */
  def patchCoreV1NamespacedReplicationControllerScale(name: String, namespace: String, body: IoK8sApimachineryPkgApisMetaV1Patch, pretty: Option[String] = None)(implicit apiKey: ApiKeyValue): ApiRequest[IoK8sApiAutoscalingV1Scale] =
    ApiRequest[IoK8sApiAutoscalingV1Scale](ApiMethods.PATCH, "https://localhost", "/api/v1/namespaces/{namespace}/replicationcontrollers/{name}/scale", "application/json-patch+json")
      .withApiKey(apiKey, "authorization", HEADER)
      .withBody(body)
      .withQueryParam("pretty", pretty)
      .withPathParam("name", name)
      .withPathParam("namespace", namespace)
      .withSuccessResponse[IoK8sApiAutoscalingV1Scale](200)
      .withErrorResponse[Unit](401)
        /**
   * partially update status of the specified ReplicationController
   * 
   * Expected answers:
   *   code 200 : IoK8sApiCoreV1ReplicationController (OK)
   *   code 401 :  (Unauthorized)
   * 
   * Available security schemes:
   *   BearerToken (apiKey)
   * 
   * @param name name of the ReplicationController
   * @param namespace object name and auth scope, such as for teams and projects
   * @param body 
   * @param pretty If &#39;true&#39;, then the output is pretty printed.
   */
  def patchCoreV1NamespacedReplicationControllerStatus(name: String, namespace: String, body: IoK8sApimachineryPkgApisMetaV1Patch, pretty: Option[String] = None)(implicit apiKey: ApiKeyValue): ApiRequest[IoK8sApiCoreV1ReplicationController] =
    ApiRequest[IoK8sApiCoreV1ReplicationController](ApiMethods.PATCH, "https://localhost", "/api/v1/namespaces/{namespace}/replicationcontrollers/{name}/status", "application/json-patch+json")
      .withApiKey(apiKey, "authorization", HEADER)
      .withBody(body)
      .withQueryParam("pretty", pretty)
      .withPathParam("name", name)
      .withPathParam("namespace", namespace)
      .withSuccessResponse[IoK8sApiCoreV1ReplicationController](200)
      .withErrorResponse[Unit](401)
        /**
   * partially update the specified ResourceQuota
   * 
   * Expected answers:
   *   code 200 : IoK8sApiCoreV1ResourceQuota (OK)
   *   code 401 :  (Unauthorized)
   * 
   * Available security schemes:
   *   BearerToken (apiKey)
   * 
   * @param name name of the ResourceQuota
   * @param namespace object name and auth scope, such as for teams and projects
   * @param body 
   * @param pretty If &#39;true&#39;, then the output is pretty printed.
   */
  def patchCoreV1NamespacedResourceQuota(name: String, namespace: String, body: IoK8sApimachineryPkgApisMetaV1Patch, pretty: Option[String] = None)(implicit apiKey: ApiKeyValue): ApiRequest[IoK8sApiCoreV1ResourceQuota] =
    ApiRequest[IoK8sApiCoreV1ResourceQuota](ApiMethods.PATCH, "https://localhost", "/api/v1/namespaces/{namespace}/resourcequotas/{name}", "application/json-patch+json")
      .withApiKey(apiKey, "authorization", HEADER)
      .withBody(body)
      .withQueryParam("pretty", pretty)
      .withPathParam("name", name)
      .withPathParam("namespace", namespace)
      .withSuccessResponse[IoK8sApiCoreV1ResourceQuota](200)
      .withErrorResponse[Unit](401)
        /**
   * partially update status of the specified ResourceQuota
   * 
   * Expected answers:
   *   code 200 : IoK8sApiCoreV1ResourceQuota (OK)
   *   code 401 :  (Unauthorized)
   * 
   * Available security schemes:
   *   BearerToken (apiKey)
   * 
   * @param name name of the ResourceQuota
   * @param namespace object name and auth scope, such as for teams and projects
   * @param body 
   * @param pretty If &#39;true&#39;, then the output is pretty printed.
   */
  def patchCoreV1NamespacedResourceQuotaStatus(name: String, namespace: String, body: IoK8sApimachineryPkgApisMetaV1Patch, pretty: Option[String] = None)(implicit apiKey: ApiKeyValue): ApiRequest[IoK8sApiCoreV1ResourceQuota] =
    ApiRequest[IoK8sApiCoreV1ResourceQuota](ApiMethods.PATCH, "https://localhost", "/api/v1/namespaces/{namespace}/resourcequotas/{name}/status", "application/json-patch+json")
      .withApiKey(apiKey, "authorization", HEADER)
      .withBody(body)
      .withQueryParam("pretty", pretty)
      .withPathParam("name", name)
      .withPathParam("namespace", namespace)
      .withSuccessResponse[IoK8sApiCoreV1ResourceQuota](200)
      .withErrorResponse[Unit](401)
        /**
   * partially update the specified Secret
   * 
   * Expected answers:
   *   code 200 : IoK8sApiCoreV1Secret (OK)
   *   code 401 :  (Unauthorized)
   * 
   * Available security schemes:
   *   BearerToken (apiKey)
   * 
   * @param name name of the Secret
   * @param namespace object name and auth scope, such as for teams and projects
   * @param body 
   * @param pretty If &#39;true&#39;, then the output is pretty printed.
   */
  def patchCoreV1NamespacedSecret(name: String, namespace: String, body: IoK8sApimachineryPkgApisMetaV1Patch, pretty: Option[String] = None)(implicit apiKey: ApiKeyValue): ApiRequest[IoK8sApiCoreV1Secret] =
    ApiRequest[IoK8sApiCoreV1Secret](ApiMethods.PATCH, "https://localhost", "/api/v1/namespaces/{namespace}/secrets/{name}", "application/json-patch+json")
      .withApiKey(apiKey, "authorization", HEADER)
      .withBody(body)
      .withQueryParam("pretty", pretty)
      .withPathParam("name", name)
      .withPathParam("namespace", namespace)
      .withSuccessResponse[IoK8sApiCoreV1Secret](200)
      .withErrorResponse[Unit](401)
        /**
   * partially update the specified Service
   * 
   * Expected answers:
   *   code 200 : IoK8sApiCoreV1Service (OK)
   *   code 401 :  (Unauthorized)
   * 
   * Available security schemes:
   *   BearerToken (apiKey)
   * 
   * @param name name of the Service
   * @param namespace object name and auth scope, such as for teams and projects
   * @param body 
   * @param pretty If &#39;true&#39;, then the output is pretty printed.
   */
  def patchCoreV1NamespacedService(name: String, namespace: String, body: IoK8sApimachineryPkgApisMetaV1Patch, pretty: Option[String] = None)(implicit apiKey: ApiKeyValue): ApiRequest[IoK8sApiCoreV1Service] =
    ApiRequest[IoK8sApiCoreV1Service](ApiMethods.PATCH, "https://localhost", "/api/v1/namespaces/{namespace}/services/{name}", "application/json-patch+json")
      .withApiKey(apiKey, "authorization", HEADER)
      .withBody(body)
      .withQueryParam("pretty", pretty)
      .withPathParam("name", name)
      .withPathParam("namespace", namespace)
      .withSuccessResponse[IoK8sApiCoreV1Service](200)
      .withErrorResponse[Unit](401)
        /**
   * partially update the specified ServiceAccount
   * 
   * Expected answers:
   *   code 200 : IoK8sApiCoreV1ServiceAccount (OK)
   *   code 401 :  (Unauthorized)
   * 
   * Available security schemes:
   *   BearerToken (apiKey)
   * 
   * @param name name of the ServiceAccount
   * @param namespace object name and auth scope, such as for teams and projects
   * @param body 
   * @param pretty If &#39;true&#39;, then the output is pretty printed.
   */
  def patchCoreV1NamespacedServiceAccount(name: String, namespace: String, body: IoK8sApimachineryPkgApisMetaV1Patch, pretty: Option[String] = None)(implicit apiKey: ApiKeyValue): ApiRequest[IoK8sApiCoreV1ServiceAccount] =
    ApiRequest[IoK8sApiCoreV1ServiceAccount](ApiMethods.PATCH, "https://localhost", "/api/v1/namespaces/{namespace}/serviceaccounts/{name}", "application/json-patch+json")
      .withApiKey(apiKey, "authorization", HEADER)
      .withBody(body)
      .withQueryParam("pretty", pretty)
      .withPathParam("name", name)
      .withPathParam("namespace", namespace)
      .withSuccessResponse[IoK8sApiCoreV1ServiceAccount](200)
      .withErrorResponse[Unit](401)
        /**
   * partially update status of the specified Service
   * 
   * Expected answers:
   *   code 200 : IoK8sApiCoreV1Service (OK)
   *   code 401 :  (Unauthorized)
   * 
   * Available security schemes:
   *   BearerToken (apiKey)
   * 
   * @param name name of the Service
   * @param namespace object name and auth scope, such as for teams and projects
   * @param body 
   * @param pretty If &#39;true&#39;, then the output is pretty printed.
   */
  def patchCoreV1NamespacedServiceStatus(name: String, namespace: String, body: IoK8sApimachineryPkgApisMetaV1Patch, pretty: Option[String] = None)(implicit apiKey: ApiKeyValue): ApiRequest[IoK8sApiCoreV1Service] =
    ApiRequest[IoK8sApiCoreV1Service](ApiMethods.PATCH, "https://localhost", "/api/v1/namespaces/{namespace}/services/{name}/status", "application/json-patch+json")
      .withApiKey(apiKey, "authorization", HEADER)
      .withBody(body)
      .withQueryParam("pretty", pretty)
      .withPathParam("name", name)
      .withPathParam("namespace", namespace)
      .withSuccessResponse[IoK8sApiCoreV1Service](200)
      .withErrorResponse[Unit](401)
        /**
   * partially update the specified Node
   * 
   * Expected answers:
   *   code 200 : IoK8sApiCoreV1Node (OK)
   *   code 401 :  (Unauthorized)
   * 
   * Available security schemes:
   *   BearerToken (apiKey)
   * 
   * @param name name of the Node
   * @param body 
   * @param pretty If &#39;true&#39;, then the output is pretty printed.
   */
  def patchCoreV1Node(name: String, body: IoK8sApimachineryPkgApisMetaV1Patch, pretty: Option[String] = None)(implicit apiKey: ApiKeyValue): ApiRequest[IoK8sApiCoreV1Node] =
    ApiRequest[IoK8sApiCoreV1Node](ApiMethods.PATCH, "https://localhost", "/api/v1/nodes/{name}", "application/json-patch+json")
      .withApiKey(apiKey, "authorization", HEADER)
      .withBody(body)
      .withQueryParam("pretty", pretty)
      .withPathParam("name", name)
      .withSuccessResponse[IoK8sApiCoreV1Node](200)
      .withErrorResponse[Unit](401)
        /**
   * partially update status of the specified Node
   * 
   * Expected answers:
   *   code 200 : IoK8sApiCoreV1Node (OK)
   *   code 401 :  (Unauthorized)
   * 
   * Available security schemes:
   *   BearerToken (apiKey)
   * 
   * @param name name of the Node
   * @param body 
   * @param pretty If &#39;true&#39;, then the output is pretty printed.
   */
  def patchCoreV1NodeStatus(name: String, body: IoK8sApimachineryPkgApisMetaV1Patch, pretty: Option[String] = None)(implicit apiKey: ApiKeyValue): ApiRequest[IoK8sApiCoreV1Node] =
    ApiRequest[IoK8sApiCoreV1Node](ApiMethods.PATCH, "https://localhost", "/api/v1/nodes/{name}/status", "application/json-patch+json")
      .withApiKey(apiKey, "authorization", HEADER)
      .withBody(body)
      .withQueryParam("pretty", pretty)
      .withPathParam("name", name)
      .withSuccessResponse[IoK8sApiCoreV1Node](200)
      .withErrorResponse[Unit](401)
        /**
   * partially update the specified PersistentVolume
   * 
   * Expected answers:
   *   code 200 : IoK8sApiCoreV1PersistentVolume (OK)
   *   code 401 :  (Unauthorized)
   * 
   * Available security schemes:
   *   BearerToken (apiKey)
   * 
   * @param name name of the PersistentVolume
   * @param body 
   * @param pretty If &#39;true&#39;, then the output is pretty printed.
   */
  def patchCoreV1PersistentVolume(name: String, body: IoK8sApimachineryPkgApisMetaV1Patch, pretty: Option[String] = None)(implicit apiKey: ApiKeyValue): ApiRequest[IoK8sApiCoreV1PersistentVolume] =
    ApiRequest[IoK8sApiCoreV1PersistentVolume](ApiMethods.PATCH, "https://localhost", "/api/v1/persistentvolumes/{name}", "application/json-patch+json")
      .withApiKey(apiKey, "authorization", HEADER)
      .withBody(body)
      .withQueryParam("pretty", pretty)
      .withPathParam("name", name)
      .withSuccessResponse[IoK8sApiCoreV1PersistentVolume](200)
      .withErrorResponse[Unit](401)
        /**
   * partially update status of the specified PersistentVolume
   * 
   * Expected answers:
   *   code 200 : IoK8sApiCoreV1PersistentVolume (OK)
   *   code 401 :  (Unauthorized)
   * 
   * Available security schemes:
   *   BearerToken (apiKey)
   * 
   * @param name name of the PersistentVolume
   * @param body 
   * @param pretty If &#39;true&#39;, then the output is pretty printed.
   */
  def patchCoreV1PersistentVolumeStatus(name: String, body: IoK8sApimachineryPkgApisMetaV1Patch, pretty: Option[String] = None)(implicit apiKey: ApiKeyValue): ApiRequest[IoK8sApiCoreV1PersistentVolume] =
    ApiRequest[IoK8sApiCoreV1PersistentVolume](ApiMethods.PATCH, "https://localhost", "/api/v1/persistentvolumes/{name}/status", "application/json-patch+json")
      .withApiKey(apiKey, "authorization", HEADER)
      .withBody(body)
      .withQueryParam("pretty", pretty)
      .withPathParam("name", name)
      .withSuccessResponse[IoK8sApiCoreV1PersistentVolume](200)
      .withErrorResponse[Unit](401)
        /**
   * proxy DELETE requests to Pod
   * 
   * Expected answers:
   *   code 200 : String (OK)
   *   code 401 :  (Unauthorized)
   * 
   * Available security schemes:
   *   BearerToken (apiKey)
   * 
   * @param name name of the Pod
   * @param namespace object name and auth scope, such as for teams and projects
   */
  def proxyCoreV1DELETENamespacedPod(name: String, namespace: String)(implicit apiKey: ApiKeyValue): ApiRequest[String] =
    ApiRequest[String](ApiMethods.DELETE, "https://localhost", "/api/v1/proxy/namespaces/{namespace}/pods/{name}", "*/*")
      .withApiKey(apiKey, "authorization", HEADER)
      .withPathParam("name", name)
      .withPathParam("namespace", namespace)
      .withSuccessResponse[String](200)
      .withErrorResponse[Unit](401)
        /**
   * proxy DELETE requests to Pod
   * 
   * Expected answers:
   *   code 200 : String (OK)
   *   code 401 :  (Unauthorized)
   * 
   * Available security schemes:
   *   BearerToken (apiKey)
   * 
   * @param name name of the Pod
   * @param namespace object name and auth scope, such as for teams and projects
   * @param path path to the resource
   */
  def proxyCoreV1DELETENamespacedPodWithPath(name: String, namespace: String, path: String)(implicit apiKey: ApiKeyValue): ApiRequest[String] =
    ApiRequest[String](ApiMethods.DELETE, "https://localhost", "/api/v1/proxy/namespaces/{namespace}/pods/{name}/{path}", "*/*")
      .withApiKey(apiKey, "authorization", HEADER)
      .withPathParam("name", name)
      .withPathParam("namespace", namespace)
      .withPathParam("path", path)
      .withSuccessResponse[String](200)
      .withErrorResponse[Unit](401)
        /**
   * proxy DELETE requests to Service
   * 
   * Expected answers:
   *   code 200 : String (OK)
   *   code 401 :  (Unauthorized)
   * 
   * Available security schemes:
   *   BearerToken (apiKey)
   * 
   * @param name name of the Service
   * @param namespace object name and auth scope, such as for teams and projects
   */
  def proxyCoreV1DELETENamespacedService(name: String, namespace: String)(implicit apiKey: ApiKeyValue): ApiRequest[String] =
    ApiRequest[String](ApiMethods.DELETE, "https://localhost", "/api/v1/proxy/namespaces/{namespace}/services/{name}", "*/*")
      .withApiKey(apiKey, "authorization", HEADER)
      .withPathParam("name", name)
      .withPathParam("namespace", namespace)
      .withSuccessResponse[String](200)
      .withErrorResponse[Unit](401)
        /**
   * proxy DELETE requests to Service
   * 
   * Expected answers:
   *   code 200 : String (OK)
   *   code 401 :  (Unauthorized)
   * 
   * Available security schemes:
   *   BearerToken (apiKey)
   * 
   * @param name name of the Service
   * @param namespace object name and auth scope, such as for teams and projects
   * @param path path to the resource
   */
  def proxyCoreV1DELETENamespacedServiceWithPath(name: String, namespace: String, path: String)(implicit apiKey: ApiKeyValue): ApiRequest[String] =
    ApiRequest[String](ApiMethods.DELETE, "https://localhost", "/api/v1/proxy/namespaces/{namespace}/services/{name}/{path}", "*/*")
      .withApiKey(apiKey, "authorization", HEADER)
      .withPathParam("name", name)
      .withPathParam("namespace", namespace)
      .withPathParam("path", path)
      .withSuccessResponse[String](200)
      .withErrorResponse[Unit](401)
        /**
   * proxy DELETE requests to Node
   * 
   * Expected answers:
   *   code 200 : String (OK)
   *   code 401 :  (Unauthorized)
   * 
   * Available security schemes:
   *   BearerToken (apiKey)
   * 
   * @param name name of the Node
   */
  def proxyCoreV1DELETENode(name: String)(implicit apiKey: ApiKeyValue): ApiRequest[String] =
    ApiRequest[String](ApiMethods.DELETE, "https://localhost", "/api/v1/proxy/nodes/{name}", "*/*")
      .withApiKey(apiKey, "authorization", HEADER)
      .withPathParam("name", name)
      .withSuccessResponse[String](200)
      .withErrorResponse[Unit](401)
        /**
   * proxy DELETE requests to Node
   * 
   * Expected answers:
   *   code 200 : String (OK)
   *   code 401 :  (Unauthorized)
   * 
   * Available security schemes:
   *   BearerToken (apiKey)
   * 
   * @param name name of the Node
   * @param path path to the resource
   */
  def proxyCoreV1DELETENodeWithPath(name: String, path: String)(implicit apiKey: ApiKeyValue): ApiRequest[String] =
    ApiRequest[String](ApiMethods.DELETE, "https://localhost", "/api/v1/proxy/nodes/{name}/{path}", "*/*")
      .withApiKey(apiKey, "authorization", HEADER)
      .withPathParam("name", name)
      .withPathParam("path", path)
      .withSuccessResponse[String](200)
      .withErrorResponse[Unit](401)
        /**
   * proxy GET requests to Pod
   * 
   * Expected answers:
   *   code 200 : String (OK)
   *   code 401 :  (Unauthorized)
   * 
   * Available security schemes:
   *   BearerToken (apiKey)
   * 
   * @param name name of the Pod
   * @param namespace object name and auth scope, such as for teams and projects
   */
  def proxyCoreV1GETNamespacedPod(name: String, namespace: String)(implicit apiKey: ApiKeyValue): ApiRequest[String] =
    ApiRequest[String](ApiMethods.GET, "https://localhost", "/api/v1/proxy/namespaces/{namespace}/pods/{name}", "*/*")
      .withApiKey(apiKey, "authorization", HEADER)
      .withPathParam("name", name)
      .withPathParam("namespace", namespace)
      .withSuccessResponse[String](200)
      .withErrorResponse[Unit](401)
        /**
   * proxy GET requests to Pod
   * 
   * Expected answers:
   *   code 200 : String (OK)
   *   code 401 :  (Unauthorized)
   * 
   * Available security schemes:
   *   BearerToken (apiKey)
   * 
   * @param name name of the Pod
   * @param namespace object name and auth scope, such as for teams and projects
   * @param path path to the resource
   */
  def proxyCoreV1GETNamespacedPodWithPath(name: String, namespace: String, path: String)(implicit apiKey: ApiKeyValue): ApiRequest[String] =
    ApiRequest[String](ApiMethods.GET, "https://localhost", "/api/v1/proxy/namespaces/{namespace}/pods/{name}/{path}", "*/*")
      .withApiKey(apiKey, "authorization", HEADER)
      .withPathParam("name", name)
      .withPathParam("namespace", namespace)
      .withPathParam("path", path)
      .withSuccessResponse[String](200)
      .withErrorResponse[Unit](401)
        /**
   * proxy GET requests to Service
   * 
   * Expected answers:
   *   code 200 : String (OK)
   *   code 401 :  (Unauthorized)
   * 
   * Available security schemes:
   *   BearerToken (apiKey)
   * 
   * @param name name of the Service
   * @param namespace object name and auth scope, such as for teams and projects
   */
  def proxyCoreV1GETNamespacedService(name: String, namespace: String)(implicit apiKey: ApiKeyValue): ApiRequest[String] =
    ApiRequest[String](ApiMethods.GET, "https://localhost", "/api/v1/proxy/namespaces/{namespace}/services/{name}", "*/*")
      .withApiKey(apiKey, "authorization", HEADER)
      .withPathParam("name", name)
      .withPathParam("namespace", namespace)
      .withSuccessResponse[String](200)
      .withErrorResponse[Unit](401)
        /**
   * proxy GET requests to Service
   * 
   * Expected answers:
   *   code 200 : String (OK)
   *   code 401 :  (Unauthorized)
   * 
   * Available security schemes:
   *   BearerToken (apiKey)
   * 
   * @param name name of the Service
   * @param namespace object name and auth scope, such as for teams and projects
   * @param path path to the resource
   */
  def proxyCoreV1GETNamespacedServiceWithPath(name: String, namespace: String, path: String)(implicit apiKey: ApiKeyValue): ApiRequest[String] =
    ApiRequest[String](ApiMethods.GET, "https://localhost", "/api/v1/proxy/namespaces/{namespace}/services/{name}/{path}", "*/*")
      .withApiKey(apiKey, "authorization", HEADER)
      .withPathParam("name", name)
      .withPathParam("namespace", namespace)
      .withPathParam("path", path)
      .withSuccessResponse[String](200)
      .withErrorResponse[Unit](401)
        /**
   * proxy GET requests to Node
   * 
   * Expected answers:
   *   code 200 : String (OK)
   *   code 401 :  (Unauthorized)
   * 
   * Available security schemes:
   *   BearerToken (apiKey)
   * 
   * @param name name of the Node
   */
  def proxyCoreV1GETNode(name: String)(implicit apiKey: ApiKeyValue): ApiRequest[String] =
    ApiRequest[String](ApiMethods.GET, "https://localhost", "/api/v1/proxy/nodes/{name}", "*/*")
      .withApiKey(apiKey, "authorization", HEADER)
      .withPathParam("name", name)
      .withSuccessResponse[String](200)
      .withErrorResponse[Unit](401)
        /**
   * proxy GET requests to Node
   * 
   * Expected answers:
   *   code 200 : String (OK)
   *   code 401 :  (Unauthorized)
   * 
   * Available security schemes:
   *   BearerToken (apiKey)
   * 
   * @param name name of the Node
   * @param path path to the resource
   */
  def proxyCoreV1GETNodeWithPath(name: String, path: String)(implicit apiKey: ApiKeyValue): ApiRequest[String] =
    ApiRequest[String](ApiMethods.GET, "https://localhost", "/api/v1/proxy/nodes/{name}/{path}", "*/*")
      .withApiKey(apiKey, "authorization", HEADER)
      .withPathParam("name", name)
      .withPathParam("path", path)
      .withSuccessResponse[String](200)
      .withErrorResponse[Unit](401)
        /**
   * proxy HEAD requests to Pod
   * 
   * Expected answers:
   *   code 200 : String (OK)
   *   code 401 :  (Unauthorized)
   * 
   * Available security schemes:
   *   BearerToken (apiKey)
   * 
   * @param name name of the Pod
   * @param namespace object name and auth scope, such as for teams and projects
   */
  def proxyCoreV1HEADNamespacedPod(name: String, namespace: String)(implicit apiKey: ApiKeyValue): ApiRequest[String] =
    ApiRequest[String](ApiMethods.HEAD, "https://localhost", "/api/v1/proxy/namespaces/{namespace}/pods/{name}", "*/*")
      .withApiKey(apiKey, "authorization", HEADER)
      .withPathParam("name", name)
      .withPathParam("namespace", namespace)
      .withSuccessResponse[String](200)
      .withErrorResponse[Unit](401)
        /**
   * proxy HEAD requests to Pod
   * 
   * Expected answers:
   *   code 200 : String (OK)
   *   code 401 :  (Unauthorized)
   * 
   * Available security schemes:
   *   BearerToken (apiKey)
   * 
   * @param name name of the Pod
   * @param namespace object name and auth scope, such as for teams and projects
   * @param path path to the resource
   */
  def proxyCoreV1HEADNamespacedPodWithPath(name: String, namespace: String, path: String)(implicit apiKey: ApiKeyValue): ApiRequest[String] =
    ApiRequest[String](ApiMethods.HEAD, "https://localhost", "/api/v1/proxy/namespaces/{namespace}/pods/{name}/{path}", "*/*")
      .withApiKey(apiKey, "authorization", HEADER)
      .withPathParam("name", name)
      .withPathParam("namespace", namespace)
      .withPathParam("path", path)
      .withSuccessResponse[String](200)
      .withErrorResponse[Unit](401)
        /**
   * proxy HEAD requests to Service
   * 
   * Expected answers:
   *   code 200 : String (OK)
   *   code 401 :  (Unauthorized)
   * 
   * Available security schemes:
   *   BearerToken (apiKey)
   * 
   * @param name name of the Service
   * @param namespace object name and auth scope, such as for teams and projects
   */
  def proxyCoreV1HEADNamespacedService(name: String, namespace: String)(implicit apiKey: ApiKeyValue): ApiRequest[String] =
    ApiRequest[String](ApiMethods.HEAD, "https://localhost", "/api/v1/proxy/namespaces/{namespace}/services/{name}", "*/*")
      .withApiKey(apiKey, "authorization", HEADER)
      .withPathParam("name", name)
      .withPathParam("namespace", namespace)
      .withSuccessResponse[String](200)
      .withErrorResponse[Unit](401)
        /**
   * proxy HEAD requests to Service
   * 
   * Expected answers:
   *   code 200 : String (OK)
   *   code 401 :  (Unauthorized)
   * 
   * Available security schemes:
   *   BearerToken (apiKey)
   * 
   * @param name name of the Service
   * @param namespace object name and auth scope, such as for teams and projects
   * @param path path to the resource
   */
  def proxyCoreV1HEADNamespacedServiceWithPath(name: String, namespace: String, path: String)(implicit apiKey: ApiKeyValue): ApiRequest[String] =
    ApiRequest[String](ApiMethods.HEAD, "https://localhost", "/api/v1/proxy/namespaces/{namespace}/services/{name}/{path}", "*/*")
      .withApiKey(apiKey, "authorization", HEADER)
      .withPathParam("name", name)
      .withPathParam("namespace", namespace)
      .withPathParam("path", path)
      .withSuccessResponse[String](200)
      .withErrorResponse[Unit](401)
        /**
   * proxy HEAD requests to Node
   * 
   * Expected answers:
   *   code 200 : String (OK)
   *   code 401 :  (Unauthorized)
   * 
   * Available security schemes:
   *   BearerToken (apiKey)
   * 
   * @param name name of the Node
   */
  def proxyCoreV1HEADNode(name: String)(implicit apiKey: ApiKeyValue): ApiRequest[String] =
    ApiRequest[String](ApiMethods.HEAD, "https://localhost", "/api/v1/proxy/nodes/{name}", "*/*")
      .withApiKey(apiKey, "authorization", HEADER)
      .withPathParam("name", name)
      .withSuccessResponse[String](200)
      .withErrorResponse[Unit](401)
        /**
   * proxy HEAD requests to Node
   * 
   * Expected answers:
   *   code 200 : String (OK)
   *   code 401 :  (Unauthorized)
   * 
   * Available security schemes:
   *   BearerToken (apiKey)
   * 
   * @param name name of the Node
   * @param path path to the resource
   */
  def proxyCoreV1HEADNodeWithPath(name: String, path: String)(implicit apiKey: ApiKeyValue): ApiRequest[String] =
    ApiRequest[String](ApiMethods.HEAD, "https://localhost", "/api/v1/proxy/nodes/{name}/{path}", "*/*")
      .withApiKey(apiKey, "authorization", HEADER)
      .withPathParam("name", name)
      .withPathParam("path", path)
      .withSuccessResponse[String](200)
      .withErrorResponse[Unit](401)
        /**
   * proxy OPTIONS requests to Pod
   * 
   * Expected answers:
   *   code 200 : String (OK)
   *   code 401 :  (Unauthorized)
   * 
   * Available security schemes:
   *   BearerToken (apiKey)
   * 
   * @param name name of the Pod
   * @param namespace object name and auth scope, such as for teams and projects
   */
  def proxyCoreV1OPTIONSNamespacedPod(name: String, namespace: String)(implicit apiKey: ApiKeyValue): ApiRequest[String] =
    ApiRequest[String](ApiMethods.OPTIONS, "https://localhost", "/api/v1/proxy/namespaces/{namespace}/pods/{name}", "*/*")
      .withApiKey(apiKey, "authorization", HEADER)
      .withPathParam("name", name)
      .withPathParam("namespace", namespace)
      .withSuccessResponse[String](200)
      .withErrorResponse[Unit](401)
        /**
   * proxy OPTIONS requests to Pod
   * 
   * Expected answers:
   *   code 200 : String (OK)
   *   code 401 :  (Unauthorized)
   * 
   * Available security schemes:
   *   BearerToken (apiKey)
   * 
   * @param name name of the Pod
   * @param namespace object name and auth scope, such as for teams and projects
   * @param path path to the resource
   */
  def proxyCoreV1OPTIONSNamespacedPodWithPath(name: String, namespace: String, path: String)(implicit apiKey: ApiKeyValue): ApiRequest[String] =
    ApiRequest[String](ApiMethods.OPTIONS, "https://localhost", "/api/v1/proxy/namespaces/{namespace}/pods/{name}/{path}", "*/*")
      .withApiKey(apiKey, "authorization", HEADER)
      .withPathParam("name", name)
      .withPathParam("namespace", namespace)
      .withPathParam("path", path)
      .withSuccessResponse[String](200)
      .withErrorResponse[Unit](401)
        /**
   * proxy OPTIONS requests to Service
   * 
   * Expected answers:
   *   code 200 : String (OK)
   *   code 401 :  (Unauthorized)
   * 
   * Available security schemes:
   *   BearerToken (apiKey)
   * 
   * @param name name of the Service
   * @param namespace object name and auth scope, such as for teams and projects
   */
  def proxyCoreV1OPTIONSNamespacedService(name: String, namespace: String)(implicit apiKey: ApiKeyValue): ApiRequest[String] =
    ApiRequest[String](ApiMethods.OPTIONS, "https://localhost", "/api/v1/proxy/namespaces/{namespace}/services/{name}", "*/*")
      .withApiKey(apiKey, "authorization", HEADER)
      .withPathParam("name", name)
      .withPathParam("namespace", namespace)
      .withSuccessResponse[String](200)
      .withErrorResponse[Unit](401)
        /**
   * proxy OPTIONS requests to Service
   * 
   * Expected answers:
   *   code 200 : String (OK)
   *   code 401 :  (Unauthorized)
   * 
   * Available security schemes:
   *   BearerToken (apiKey)
   * 
   * @param name name of the Service
   * @param namespace object name and auth scope, such as for teams and projects
   * @param path path to the resource
   */
  def proxyCoreV1OPTIONSNamespacedServiceWithPath(name: String, namespace: String, path: String)(implicit apiKey: ApiKeyValue): ApiRequest[String] =
    ApiRequest[String](ApiMethods.OPTIONS, "https://localhost", "/api/v1/proxy/namespaces/{namespace}/services/{name}/{path}", "*/*")
      .withApiKey(apiKey, "authorization", HEADER)
      .withPathParam("name", name)
      .withPathParam("namespace", namespace)
      .withPathParam("path", path)
      .withSuccessResponse[String](200)
      .withErrorResponse[Unit](401)
        /**
   * proxy OPTIONS requests to Node
   * 
   * Expected answers:
   *   code 200 : String (OK)
   *   code 401 :  (Unauthorized)
   * 
   * Available security schemes:
   *   BearerToken (apiKey)
   * 
   * @param name name of the Node
   */
  def proxyCoreV1OPTIONSNode(name: String)(implicit apiKey: ApiKeyValue): ApiRequest[String] =
    ApiRequest[String](ApiMethods.OPTIONS, "https://localhost", "/api/v1/proxy/nodes/{name}", "*/*")
      .withApiKey(apiKey, "authorization", HEADER)
      .withPathParam("name", name)
      .withSuccessResponse[String](200)
      .withErrorResponse[Unit](401)
        /**
   * proxy OPTIONS requests to Node
   * 
   * Expected answers:
   *   code 200 : String (OK)
   *   code 401 :  (Unauthorized)
   * 
   * Available security schemes:
   *   BearerToken (apiKey)
   * 
   * @param name name of the Node
   * @param path path to the resource
   */
  def proxyCoreV1OPTIONSNodeWithPath(name: String, path: String)(implicit apiKey: ApiKeyValue): ApiRequest[String] =
    ApiRequest[String](ApiMethods.OPTIONS, "https://localhost", "/api/v1/proxy/nodes/{name}/{path}", "*/*")
      .withApiKey(apiKey, "authorization", HEADER)
      .withPathParam("name", name)
      .withPathParam("path", path)
      .withSuccessResponse[String](200)
      .withErrorResponse[Unit](401)
        /**
   * proxy PATCH requests to Pod
   * 
   * Expected answers:
   *   code 200 : String (OK)
   *   code 401 :  (Unauthorized)
   * 
   * Available security schemes:
   *   BearerToken (apiKey)
   * 
   * @param name name of the Pod
   * @param namespace object name and auth scope, such as for teams and projects
   */
  def proxyCoreV1PATCHNamespacedPod(name: String, namespace: String)(implicit apiKey: ApiKeyValue): ApiRequest[String] =
    ApiRequest[String](ApiMethods.PATCH, "https://localhost", "/api/v1/proxy/namespaces/{namespace}/pods/{name}", "*/*")
      .withApiKey(apiKey, "authorization", HEADER)
      .withPathParam("name", name)
      .withPathParam("namespace", namespace)
      .withSuccessResponse[String](200)
      .withErrorResponse[Unit](401)
        /**
   * proxy PATCH requests to Pod
   * 
   * Expected answers:
   *   code 200 : String (OK)
   *   code 401 :  (Unauthorized)
   * 
   * Available security schemes:
   *   BearerToken (apiKey)
   * 
   * @param name name of the Pod
   * @param namespace object name and auth scope, such as for teams and projects
   * @param path path to the resource
   */
  def proxyCoreV1PATCHNamespacedPodWithPath(name: String, namespace: String, path: String)(implicit apiKey: ApiKeyValue): ApiRequest[String] =
    ApiRequest[String](ApiMethods.PATCH, "https://localhost", "/api/v1/proxy/namespaces/{namespace}/pods/{name}/{path}", "*/*")
      .withApiKey(apiKey, "authorization", HEADER)
      .withPathParam("name", name)
      .withPathParam("namespace", namespace)
      .withPathParam("path", path)
      .withSuccessResponse[String](200)
      .withErrorResponse[Unit](401)
        /**
   * proxy PATCH requests to Service
   * 
   * Expected answers:
   *   code 200 : String (OK)
   *   code 401 :  (Unauthorized)
   * 
   * Available security schemes:
   *   BearerToken (apiKey)
   * 
   * @param name name of the Service
   * @param namespace object name and auth scope, such as for teams and projects
   */
  def proxyCoreV1PATCHNamespacedService(name: String, namespace: String)(implicit apiKey: ApiKeyValue): ApiRequest[String] =
    ApiRequest[String](ApiMethods.PATCH, "https://localhost", "/api/v1/proxy/namespaces/{namespace}/services/{name}", "*/*")
      .withApiKey(apiKey, "authorization", HEADER)
      .withPathParam("name", name)
      .withPathParam("namespace", namespace)
      .withSuccessResponse[String](200)
      .withErrorResponse[Unit](401)
        /**
   * proxy PATCH requests to Service
   * 
   * Expected answers:
   *   code 200 : String (OK)
   *   code 401 :  (Unauthorized)
   * 
   * Available security schemes:
   *   BearerToken (apiKey)
   * 
   * @param name name of the Service
   * @param namespace object name and auth scope, such as for teams and projects
   * @param path path to the resource
   */
  def proxyCoreV1PATCHNamespacedServiceWithPath(name: String, namespace: String, path: String)(implicit apiKey: ApiKeyValue): ApiRequest[String] =
    ApiRequest[String](ApiMethods.PATCH, "https://localhost", "/api/v1/proxy/namespaces/{namespace}/services/{name}/{path}", "*/*")
      .withApiKey(apiKey, "authorization", HEADER)
      .withPathParam("name", name)
      .withPathParam("namespace", namespace)
      .withPathParam("path", path)
      .withSuccessResponse[String](200)
      .withErrorResponse[Unit](401)
        /**
   * proxy PATCH requests to Node
   * 
   * Expected answers:
   *   code 200 : String (OK)
   *   code 401 :  (Unauthorized)
   * 
   * Available security schemes:
   *   BearerToken (apiKey)
   * 
   * @param name name of the Node
   */
  def proxyCoreV1PATCHNode(name: String)(implicit apiKey: ApiKeyValue): ApiRequest[String] =
    ApiRequest[String](ApiMethods.PATCH, "https://localhost", "/api/v1/proxy/nodes/{name}", "*/*")
      .withApiKey(apiKey, "authorization", HEADER)
      .withPathParam("name", name)
      .withSuccessResponse[String](200)
      .withErrorResponse[Unit](401)
        /**
   * proxy PATCH requests to Node
   * 
   * Expected answers:
   *   code 200 : String (OK)
   *   code 401 :  (Unauthorized)
   * 
   * Available security schemes:
   *   BearerToken (apiKey)
   * 
   * @param name name of the Node
   * @param path path to the resource
   */
  def proxyCoreV1PATCHNodeWithPath(name: String, path: String)(implicit apiKey: ApiKeyValue): ApiRequest[String] =
    ApiRequest[String](ApiMethods.PATCH, "https://localhost", "/api/v1/proxy/nodes/{name}/{path}", "*/*")
      .withApiKey(apiKey, "authorization", HEADER)
      .withPathParam("name", name)
      .withPathParam("path", path)
      .withSuccessResponse[String](200)
      .withErrorResponse[Unit](401)
        /**
   * proxy POST requests to Pod
   * 
   * Expected answers:
   *   code 200 : String (OK)
   *   code 401 :  (Unauthorized)
   * 
   * Available security schemes:
   *   BearerToken (apiKey)
   * 
   * @param name name of the Pod
   * @param namespace object name and auth scope, such as for teams and projects
   */
  def proxyCoreV1POSTNamespacedPod(name: String, namespace: String)(implicit apiKey: ApiKeyValue): ApiRequest[String] =
    ApiRequest[String](ApiMethods.POST, "https://localhost", "/api/v1/proxy/namespaces/{namespace}/pods/{name}", "*/*")
      .withApiKey(apiKey, "authorization", HEADER)
      .withPathParam("name", name)
      .withPathParam("namespace", namespace)
      .withSuccessResponse[String](200)
      .withErrorResponse[Unit](401)
        /**
   * proxy POST requests to Pod
   * 
   * Expected answers:
   *   code 200 : String (OK)
   *   code 401 :  (Unauthorized)
   * 
   * Available security schemes:
   *   BearerToken (apiKey)
   * 
   * @param name name of the Pod
   * @param namespace object name and auth scope, such as for teams and projects
   * @param path path to the resource
   */
  def proxyCoreV1POSTNamespacedPodWithPath(name: String, namespace: String, path: String)(implicit apiKey: ApiKeyValue): ApiRequest[String] =
    ApiRequest[String](ApiMethods.POST, "https://localhost", "/api/v1/proxy/namespaces/{namespace}/pods/{name}/{path}", "*/*")
      .withApiKey(apiKey, "authorization", HEADER)
      .withPathParam("name", name)
      .withPathParam("namespace", namespace)
      .withPathParam("path", path)
      .withSuccessResponse[String](200)
      .withErrorResponse[Unit](401)
        /**
   * proxy POST requests to Service
   * 
   * Expected answers:
   *   code 200 : String (OK)
   *   code 401 :  (Unauthorized)
   * 
   * Available security schemes:
   *   BearerToken (apiKey)
   * 
   * @param name name of the Service
   * @param namespace object name and auth scope, such as for teams and projects
   */
  def proxyCoreV1POSTNamespacedService(name: String, namespace: String)(implicit apiKey: ApiKeyValue): ApiRequest[String] =
    ApiRequest[String](ApiMethods.POST, "https://localhost", "/api/v1/proxy/namespaces/{namespace}/services/{name}", "*/*")
      .withApiKey(apiKey, "authorization", HEADER)
      .withPathParam("name", name)
      .withPathParam("namespace", namespace)
      .withSuccessResponse[String](200)
      .withErrorResponse[Unit](401)
        /**
   * proxy POST requests to Service
   * 
   * Expected answers:
   *   code 200 : String (OK)
   *   code 401 :  (Unauthorized)
   * 
   * Available security schemes:
   *   BearerToken (apiKey)
   * 
   * @param name name of the Service
   * @param namespace object name and auth scope, such as for teams and projects
   * @param path path to the resource
   */
  def proxyCoreV1POSTNamespacedServiceWithPath(name: String, namespace: String, path: String)(implicit apiKey: ApiKeyValue): ApiRequest[String] =
    ApiRequest[String](ApiMethods.POST, "https://localhost", "/api/v1/proxy/namespaces/{namespace}/services/{name}/{path}", "*/*")
      .withApiKey(apiKey, "authorization", HEADER)
      .withPathParam("name", name)
      .withPathParam("namespace", namespace)
      .withPathParam("path", path)
      .withSuccessResponse[String](200)
      .withErrorResponse[Unit](401)
        /**
   * proxy POST requests to Node
   * 
   * Expected answers:
   *   code 200 : String (OK)
   *   code 401 :  (Unauthorized)
   * 
   * Available security schemes:
   *   BearerToken (apiKey)
   * 
   * @param name name of the Node
   */
  def proxyCoreV1POSTNode(name: String)(implicit apiKey: ApiKeyValue): ApiRequest[String] =
    ApiRequest[String](ApiMethods.POST, "https://localhost", "/api/v1/proxy/nodes/{name}", "*/*")
      .withApiKey(apiKey, "authorization", HEADER)
      .withPathParam("name", name)
      .withSuccessResponse[String](200)
      .withErrorResponse[Unit](401)
        /**
   * proxy POST requests to Node
   * 
   * Expected answers:
   *   code 200 : String (OK)
   *   code 401 :  (Unauthorized)
   * 
   * Available security schemes:
   *   BearerToken (apiKey)
   * 
   * @param name name of the Node
   * @param path path to the resource
   */
  def proxyCoreV1POSTNodeWithPath(name: String, path: String)(implicit apiKey: ApiKeyValue): ApiRequest[String] =
    ApiRequest[String](ApiMethods.POST, "https://localhost", "/api/v1/proxy/nodes/{name}/{path}", "*/*")
      .withApiKey(apiKey, "authorization", HEADER)
      .withPathParam("name", name)
      .withPathParam("path", path)
      .withSuccessResponse[String](200)
      .withErrorResponse[Unit](401)
        /**
   * proxy PUT requests to Pod
   * 
   * Expected answers:
   *   code 200 : String (OK)
   *   code 401 :  (Unauthorized)
   * 
   * Available security schemes:
   *   BearerToken (apiKey)
   * 
   * @param name name of the Pod
   * @param namespace object name and auth scope, such as for teams and projects
   */
  def proxyCoreV1PUTNamespacedPod(name: String, namespace: String)(implicit apiKey: ApiKeyValue): ApiRequest[String] =
    ApiRequest[String](ApiMethods.PUT, "https://localhost", "/api/v1/proxy/namespaces/{namespace}/pods/{name}", "*/*")
      .withApiKey(apiKey, "authorization", HEADER)
      .withPathParam("name", name)
      .withPathParam("namespace", namespace)
      .withSuccessResponse[String](200)
      .withErrorResponse[Unit](401)
        /**
   * proxy PUT requests to Pod
   * 
   * Expected answers:
   *   code 200 : String (OK)
   *   code 401 :  (Unauthorized)
   * 
   * Available security schemes:
   *   BearerToken (apiKey)
   * 
   * @param name name of the Pod
   * @param namespace object name and auth scope, such as for teams and projects
   * @param path path to the resource
   */
  def proxyCoreV1PUTNamespacedPodWithPath(name: String, namespace: String, path: String)(implicit apiKey: ApiKeyValue): ApiRequest[String] =
    ApiRequest[String](ApiMethods.PUT, "https://localhost", "/api/v1/proxy/namespaces/{namespace}/pods/{name}/{path}", "*/*")
      .withApiKey(apiKey, "authorization", HEADER)
      .withPathParam("name", name)
      .withPathParam("namespace", namespace)
      .withPathParam("path", path)
      .withSuccessResponse[String](200)
      .withErrorResponse[Unit](401)
        /**
   * proxy PUT requests to Service
   * 
   * Expected answers:
   *   code 200 : String (OK)
   *   code 401 :  (Unauthorized)
   * 
   * Available security schemes:
   *   BearerToken (apiKey)
   * 
   * @param name name of the Service
   * @param namespace object name and auth scope, such as for teams and projects
   */
  def proxyCoreV1PUTNamespacedService(name: String, namespace: String)(implicit apiKey: ApiKeyValue): ApiRequest[String] =
    ApiRequest[String](ApiMethods.PUT, "https://localhost", "/api/v1/proxy/namespaces/{namespace}/services/{name}", "*/*")
      .withApiKey(apiKey, "authorization", HEADER)
      .withPathParam("name", name)
      .withPathParam("namespace", namespace)
      .withSuccessResponse[String](200)
      .withErrorResponse[Unit](401)
        /**
   * proxy PUT requests to Service
   * 
   * Expected answers:
   *   code 200 : String (OK)
   *   code 401 :  (Unauthorized)
   * 
   * Available security schemes:
   *   BearerToken (apiKey)
   * 
   * @param name name of the Service
   * @param namespace object name and auth scope, such as for teams and projects
   * @param path path to the resource
   */
  def proxyCoreV1PUTNamespacedServiceWithPath(name: String, namespace: String, path: String)(implicit apiKey: ApiKeyValue): ApiRequest[String] =
    ApiRequest[String](ApiMethods.PUT, "https://localhost", "/api/v1/proxy/namespaces/{namespace}/services/{name}/{path}", "*/*")
      .withApiKey(apiKey, "authorization", HEADER)
      .withPathParam("name", name)
      .withPathParam("namespace", namespace)
      .withPathParam("path", path)
      .withSuccessResponse[String](200)
      .withErrorResponse[Unit](401)
        /**
   * proxy PUT requests to Node
   * 
   * Expected answers:
   *   code 200 : String (OK)
   *   code 401 :  (Unauthorized)
   * 
   * Available security schemes:
   *   BearerToken (apiKey)
   * 
   * @param name name of the Node
   */
  def proxyCoreV1PUTNode(name: String)(implicit apiKey: ApiKeyValue): ApiRequest[String] =
    ApiRequest[String](ApiMethods.PUT, "https://localhost", "/api/v1/proxy/nodes/{name}", "*/*")
      .withApiKey(apiKey, "authorization", HEADER)
      .withPathParam("name", name)
      .withSuccessResponse[String](200)
      .withErrorResponse[Unit](401)
        /**
   * proxy PUT requests to Node
   * 
   * Expected answers:
   *   code 200 : String (OK)
   *   code 401 :  (Unauthorized)
   * 
   * Available security schemes:
   *   BearerToken (apiKey)
   * 
   * @param name name of the Node
   * @param path path to the resource
   */
  def proxyCoreV1PUTNodeWithPath(name: String, path: String)(implicit apiKey: ApiKeyValue): ApiRequest[String] =
    ApiRequest[String](ApiMethods.PUT, "https://localhost", "/api/v1/proxy/nodes/{name}/{path}", "*/*")
      .withApiKey(apiKey, "authorization", HEADER)
      .withPathParam("name", name)
      .withPathParam("path", path)
      .withSuccessResponse[String](200)
      .withErrorResponse[Unit](401)
        /**
   * read the specified ComponentStatus
   * 
   * Expected answers:
   *   code 200 : IoK8sApiCoreV1ComponentStatus (OK)
   *   code 401 :  (Unauthorized)
   * 
   * Available security schemes:
   *   BearerToken (apiKey)
   * 
   * @param name name of the ComponentStatus
   * @param pretty If &#39;true&#39;, then the output is pretty printed.
   */
  def readCoreV1ComponentStatus(name: String, pretty: Option[String] = None)(implicit apiKey: ApiKeyValue): ApiRequest[IoK8sApiCoreV1ComponentStatus] =
    ApiRequest[IoK8sApiCoreV1ComponentStatus](ApiMethods.GET, "https://localhost", "/api/v1/componentstatuses/{name}", "*/*")
      .withApiKey(apiKey, "authorization", HEADER)
      .withQueryParam("pretty", pretty)
      .withPathParam("name", name)
      .withSuccessResponse[IoK8sApiCoreV1ComponentStatus](200)
      .withErrorResponse[Unit](401)
        /**
   * read the specified Namespace
   * 
   * Expected answers:
   *   code 200 : IoK8sApiCoreV1Namespace (OK)
   *   code 401 :  (Unauthorized)
   * 
   * Available security schemes:
   *   BearerToken (apiKey)
   * 
   * @param name name of the Namespace
   * @param pretty If &#39;true&#39;, then the output is pretty printed.
   * @param exact Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;.
   * @param export Should this value be exported.  Export strips fields that a user can not specify.
   */
  def readCoreV1Namespace(name: String, pretty: Option[String] = None, exact: Option[Boolean] = None, export: Option[Boolean] = None)(implicit apiKey: ApiKeyValue): ApiRequest[IoK8sApiCoreV1Namespace] =
    ApiRequest[IoK8sApiCoreV1Namespace](ApiMethods.GET, "https://localhost", "/api/v1/namespaces/{name}", "*/*")
      .withApiKey(apiKey, "authorization", HEADER)
      .withQueryParam("pretty", pretty)
      .withQueryParam("exact", exact)
      .withQueryParam("export", export)
      .withPathParam("name", name)
      .withSuccessResponse[IoK8sApiCoreV1Namespace](200)
      .withErrorResponse[Unit](401)
        /**
   * read status of the specified Namespace
   * 
   * Expected answers:
   *   code 200 : IoK8sApiCoreV1Namespace (OK)
   *   code 401 :  (Unauthorized)
   * 
   * Available security schemes:
   *   BearerToken (apiKey)
   * 
   * @param name name of the Namespace
   * @param pretty If &#39;true&#39;, then the output is pretty printed.
   */
  def readCoreV1NamespaceStatus(name: String, pretty: Option[String] = None)(implicit apiKey: ApiKeyValue): ApiRequest[IoK8sApiCoreV1Namespace] =
    ApiRequest[IoK8sApiCoreV1Namespace](ApiMethods.GET, "https://localhost", "/api/v1/namespaces/{name}/status", "*/*")
      .withApiKey(apiKey, "authorization", HEADER)
      .withQueryParam("pretty", pretty)
      .withPathParam("name", name)
      .withSuccessResponse[IoK8sApiCoreV1Namespace](200)
      .withErrorResponse[Unit](401)
        /**
   * read the specified ConfigMap
   * 
   * Expected answers:
   *   code 200 : IoK8sApiCoreV1ConfigMap (OK)
   *   code 401 :  (Unauthorized)
   * 
   * Available security schemes:
   *   BearerToken (apiKey)
   * 
   * @param name name of the ConfigMap
   * @param namespace object name and auth scope, such as for teams and projects
   * @param pretty If &#39;true&#39;, then the output is pretty printed.
   * @param exact Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;.
   * @param export Should this value be exported.  Export strips fields that a user can not specify.
   */
  def readCoreV1NamespacedConfigMap(name: String, namespace: String, pretty: Option[String] = None, exact: Option[Boolean] = None, export: Option[Boolean] = None)(implicit apiKey: ApiKeyValue): ApiRequest[IoK8sApiCoreV1ConfigMap] =
    ApiRequest[IoK8sApiCoreV1ConfigMap](ApiMethods.GET, "https://localhost", "/api/v1/namespaces/{namespace}/configmaps/{name}", "*/*")
      .withApiKey(apiKey, "authorization", HEADER)
      .withQueryParam("pretty", pretty)
      .withQueryParam("exact", exact)
      .withQueryParam("export", export)
      .withPathParam("name", name)
      .withPathParam("namespace", namespace)
      .withSuccessResponse[IoK8sApiCoreV1ConfigMap](200)
      .withErrorResponse[Unit](401)
        /**
   * read the specified Endpoints
   * 
   * Expected answers:
   *   code 200 : IoK8sApiCoreV1Endpoints (OK)
   *   code 401 :  (Unauthorized)
   * 
   * Available security schemes:
   *   BearerToken (apiKey)
   * 
   * @param name name of the Endpoints
   * @param namespace object name and auth scope, such as for teams and projects
   * @param pretty If &#39;true&#39;, then the output is pretty printed.
   * @param exact Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;.
   * @param export Should this value be exported.  Export strips fields that a user can not specify.
   */
  def readCoreV1NamespacedEndpoints(name: String, namespace: String, pretty: Option[String] = None, exact: Option[Boolean] = None, export: Option[Boolean] = None)(implicit apiKey: ApiKeyValue): ApiRequest[IoK8sApiCoreV1Endpoints] =
    ApiRequest[IoK8sApiCoreV1Endpoints](ApiMethods.GET, "https://localhost", "/api/v1/namespaces/{namespace}/endpoints/{name}", "*/*")
      .withApiKey(apiKey, "authorization", HEADER)
      .withQueryParam("pretty", pretty)
      .withQueryParam("exact", exact)
      .withQueryParam("export", export)
      .withPathParam("name", name)
      .withPathParam("namespace", namespace)
      .withSuccessResponse[IoK8sApiCoreV1Endpoints](200)
      .withErrorResponse[Unit](401)
        /**
   * read the specified Event
   * 
   * Expected answers:
   *   code 200 : IoK8sApiCoreV1Event (OK)
   *   code 401 :  (Unauthorized)
   * 
   * Available security schemes:
   *   BearerToken (apiKey)
   * 
   * @param name name of the Event
   * @param namespace object name and auth scope, such as for teams and projects
   * @param pretty If &#39;true&#39;, then the output is pretty printed.
   * @param exact Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;.
   * @param export Should this value be exported.  Export strips fields that a user can not specify.
   */
  def readCoreV1NamespacedEvent(name: String, namespace: String, pretty: Option[String] = None, exact: Option[Boolean] = None, export: Option[Boolean] = None)(implicit apiKey: ApiKeyValue): ApiRequest[IoK8sApiCoreV1Event] =
    ApiRequest[IoK8sApiCoreV1Event](ApiMethods.GET, "https://localhost", "/api/v1/namespaces/{namespace}/events/{name}", "*/*")
      .withApiKey(apiKey, "authorization", HEADER)
      .withQueryParam("pretty", pretty)
      .withQueryParam("exact", exact)
      .withQueryParam("export", export)
      .withPathParam("name", name)
      .withPathParam("namespace", namespace)
      .withSuccessResponse[IoK8sApiCoreV1Event](200)
      .withErrorResponse[Unit](401)
        /**
   * read the specified LimitRange
   * 
   * Expected answers:
   *   code 200 : IoK8sApiCoreV1LimitRange (OK)
   *   code 401 :  (Unauthorized)
   * 
   * Available security schemes:
   *   BearerToken (apiKey)
   * 
   * @param name name of the LimitRange
   * @param namespace object name and auth scope, such as for teams and projects
   * @param pretty If &#39;true&#39;, then the output is pretty printed.
   * @param exact Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;.
   * @param export Should this value be exported.  Export strips fields that a user can not specify.
   */
  def readCoreV1NamespacedLimitRange(name: String, namespace: String, pretty: Option[String] = None, exact: Option[Boolean] = None, export: Option[Boolean] = None)(implicit apiKey: ApiKeyValue): ApiRequest[IoK8sApiCoreV1LimitRange] =
    ApiRequest[IoK8sApiCoreV1LimitRange](ApiMethods.GET, "https://localhost", "/api/v1/namespaces/{namespace}/limitranges/{name}", "*/*")
      .withApiKey(apiKey, "authorization", HEADER)
      .withQueryParam("pretty", pretty)
      .withQueryParam("exact", exact)
      .withQueryParam("export", export)
      .withPathParam("name", name)
      .withPathParam("namespace", namespace)
      .withSuccessResponse[IoK8sApiCoreV1LimitRange](200)
      .withErrorResponse[Unit](401)
        /**
   * read the specified PersistentVolumeClaim
   * 
   * Expected answers:
   *   code 200 : IoK8sApiCoreV1PersistentVolumeClaim (OK)
   *   code 401 :  (Unauthorized)
   * 
   * Available security schemes:
   *   BearerToken (apiKey)
   * 
   * @param name name of the PersistentVolumeClaim
   * @param namespace object name and auth scope, such as for teams and projects
   * @param pretty If &#39;true&#39;, then the output is pretty printed.
   * @param exact Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;.
   * @param export Should this value be exported.  Export strips fields that a user can not specify.
   */
  def readCoreV1NamespacedPersistentVolumeClaim(name: String, namespace: String, pretty: Option[String] = None, exact: Option[Boolean] = None, export: Option[Boolean] = None)(implicit apiKey: ApiKeyValue): ApiRequest[IoK8sApiCoreV1PersistentVolumeClaim] =
    ApiRequest[IoK8sApiCoreV1PersistentVolumeClaim](ApiMethods.GET, "https://localhost", "/api/v1/namespaces/{namespace}/persistentvolumeclaims/{name}", "*/*")
      .withApiKey(apiKey, "authorization", HEADER)
      .withQueryParam("pretty", pretty)
      .withQueryParam("exact", exact)
      .withQueryParam("export", export)
      .withPathParam("name", name)
      .withPathParam("namespace", namespace)
      .withSuccessResponse[IoK8sApiCoreV1PersistentVolumeClaim](200)
      .withErrorResponse[Unit](401)
        /**
   * read status of the specified PersistentVolumeClaim
   * 
   * Expected answers:
   *   code 200 : IoK8sApiCoreV1PersistentVolumeClaim (OK)
   *   code 401 :  (Unauthorized)
   * 
   * Available security schemes:
   *   BearerToken (apiKey)
   * 
   * @param name name of the PersistentVolumeClaim
   * @param namespace object name and auth scope, such as for teams and projects
   * @param pretty If &#39;true&#39;, then the output is pretty printed.
   */
  def readCoreV1NamespacedPersistentVolumeClaimStatus(name: String, namespace: String, pretty: Option[String] = None)(implicit apiKey: ApiKeyValue): ApiRequest[IoK8sApiCoreV1PersistentVolumeClaim] =
    ApiRequest[IoK8sApiCoreV1PersistentVolumeClaim](ApiMethods.GET, "https://localhost", "/api/v1/namespaces/{namespace}/persistentvolumeclaims/{name}/status", "*/*")
      .withApiKey(apiKey, "authorization", HEADER)
      .withQueryParam("pretty", pretty)
      .withPathParam("name", name)
      .withPathParam("namespace", namespace)
      .withSuccessResponse[IoK8sApiCoreV1PersistentVolumeClaim](200)
      .withErrorResponse[Unit](401)
        /**
   * read the specified Pod
   * 
   * Expected answers:
   *   code 200 : IoK8sApiCoreV1Pod (OK)
   *   code 401 :  (Unauthorized)
   * 
   * Available security schemes:
   *   BearerToken (apiKey)
   * 
   * @param name name of the Pod
   * @param namespace object name and auth scope, such as for teams and projects
   * @param pretty If &#39;true&#39;, then the output is pretty printed.
   * @param exact Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;.
   * @param export Should this value be exported.  Export strips fields that a user can not specify.
   */
  def readCoreV1NamespacedPod(name: String, namespace: String, pretty: Option[String] = None, exact: Option[Boolean] = None, export: Option[Boolean] = None)(implicit apiKey: ApiKeyValue): ApiRequest[IoK8sApiCoreV1Pod] =
    ApiRequest[IoK8sApiCoreV1Pod](ApiMethods.GET, "https://localhost", "/api/v1/namespaces/{namespace}/pods/{name}", "*/*")
      .withApiKey(apiKey, "authorization", HEADER)
      .withQueryParam("pretty", pretty)
      .withQueryParam("exact", exact)
      .withQueryParam("export", export)
      .withPathParam("name", name)
      .withPathParam("namespace", namespace)
      .withSuccessResponse[IoK8sApiCoreV1Pod](200)
      .withErrorResponse[Unit](401)
        /**
   * read log of the specified Pod
   * 
   * Expected answers:
   *   code 200 : String (OK)
   *   code 401 :  (Unauthorized)
   * 
   * Available security schemes:
   *   BearerToken (apiKey)
   * 
   * @param name name of the Pod
   * @param namespace object name and auth scope, such as for teams and projects
   * @param container The container for which to stream logs. Defaults to only container if there is one container in the pod.
   * @param follow Follow the log stream of the pod. Defaults to false.
   * @param limitBytes If set, the number of bytes to read from the server before terminating the log output. This may not display a complete final line of logging, and may return slightly more or slightly less than the specified limit.
   * @param pretty If &#39;true&#39;, then the output is pretty printed.
   * @param previous Return previous terminated container logs. Defaults to false.
   * @param sinceSeconds A relative time in seconds before the current time from which to show logs. If this value precedes the time a pod was started, only logs since the pod start will be returned. If this value is in the future, no logs will be returned. Only one of sinceSeconds or sinceTime may be specified.
   * @param tailLines If set, the number of lines from the end of the logs to show. If not specified, logs are shown from the creation of the container or sinceSeconds or sinceTime
   * @param timestamps If true, add an RFC3339 or RFC3339Nano timestamp at the beginning of every line of log output. Defaults to false.
   */
  def readCoreV1NamespacedPodLog(name: String, namespace: String, container: Option[String] = None, follow: Option[Boolean] = None, limitBytes: Option[Int] = None, pretty: Option[String] = None, previous: Option[Boolean] = None, sinceSeconds: Option[Int] = None, tailLines: Option[Int] = None, timestamps: Option[Boolean] = None)(implicit apiKey: ApiKeyValue): ApiRequest[String] =
    ApiRequest[String](ApiMethods.GET, "https://localhost", "/api/v1/namespaces/{namespace}/pods/{name}/log", "*/*")
      .withApiKey(apiKey, "authorization", HEADER)
      .withQueryParam("container", container)
      .withQueryParam("follow", follow)
      .withQueryParam("limitBytes", limitBytes)
      .withQueryParam("pretty", pretty)
      .withQueryParam("previous", previous)
      .withQueryParam("sinceSeconds", sinceSeconds)
      .withQueryParam("tailLines", tailLines)
      .withQueryParam("timestamps", timestamps)
      .withPathParam("name", name)
      .withPathParam("namespace", namespace)
      .withSuccessResponse[String](200)
      .withErrorResponse[Unit](401)
        /**
   * read status of the specified Pod
   * 
   * Expected answers:
   *   code 200 : IoK8sApiCoreV1Pod (OK)
   *   code 401 :  (Unauthorized)
   * 
   * Available security schemes:
   *   BearerToken (apiKey)
   * 
   * @param name name of the Pod
   * @param namespace object name and auth scope, such as for teams and projects
   * @param pretty If &#39;true&#39;, then the output is pretty printed.
   */
  def readCoreV1NamespacedPodStatus(name: String, namespace: String, pretty: Option[String] = None)(implicit apiKey: ApiKeyValue): ApiRequest[IoK8sApiCoreV1Pod] =
    ApiRequest[IoK8sApiCoreV1Pod](ApiMethods.GET, "https://localhost", "/api/v1/namespaces/{namespace}/pods/{name}/status", "*/*")
      .withApiKey(apiKey, "authorization", HEADER)
      .withQueryParam("pretty", pretty)
      .withPathParam("name", name)
      .withPathParam("namespace", namespace)
      .withSuccessResponse[IoK8sApiCoreV1Pod](200)
      .withErrorResponse[Unit](401)
        /**
   * read the specified PodTemplate
   * 
   * Expected answers:
   *   code 200 : IoK8sApiCoreV1PodTemplate (OK)
   *   code 401 :  (Unauthorized)
   * 
   * Available security schemes:
   *   BearerToken (apiKey)
   * 
   * @param name name of the PodTemplate
   * @param namespace object name and auth scope, such as for teams and projects
   * @param pretty If &#39;true&#39;, then the output is pretty printed.
   * @param exact Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;.
   * @param export Should this value be exported.  Export strips fields that a user can not specify.
   */
  def readCoreV1NamespacedPodTemplate(name: String, namespace: String, pretty: Option[String] = None, exact: Option[Boolean] = None, export: Option[Boolean] = None)(implicit apiKey: ApiKeyValue): ApiRequest[IoK8sApiCoreV1PodTemplate] =
    ApiRequest[IoK8sApiCoreV1PodTemplate](ApiMethods.GET, "https://localhost", "/api/v1/namespaces/{namespace}/podtemplates/{name}", "*/*")
      .withApiKey(apiKey, "authorization", HEADER)
      .withQueryParam("pretty", pretty)
      .withQueryParam("exact", exact)
      .withQueryParam("export", export)
      .withPathParam("name", name)
      .withPathParam("namespace", namespace)
      .withSuccessResponse[IoK8sApiCoreV1PodTemplate](200)
      .withErrorResponse[Unit](401)
        /**
   * read the specified ReplicationController
   * 
   * Expected answers:
   *   code 200 : IoK8sApiCoreV1ReplicationController (OK)
   *   code 401 :  (Unauthorized)
   * 
   * Available security schemes:
   *   BearerToken (apiKey)
   * 
   * @param name name of the ReplicationController
   * @param namespace object name and auth scope, such as for teams and projects
   * @param pretty If &#39;true&#39;, then the output is pretty printed.
   * @param exact Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;.
   * @param export Should this value be exported.  Export strips fields that a user can not specify.
   */
  def readCoreV1NamespacedReplicationController(name: String, namespace: String, pretty: Option[String] = None, exact: Option[Boolean] = None, export: Option[Boolean] = None)(implicit apiKey: ApiKeyValue): ApiRequest[IoK8sApiCoreV1ReplicationController] =
    ApiRequest[IoK8sApiCoreV1ReplicationController](ApiMethods.GET, "https://localhost", "/api/v1/namespaces/{namespace}/replicationcontrollers/{name}", "*/*")
      .withApiKey(apiKey, "authorization", HEADER)
      .withQueryParam("pretty", pretty)
      .withQueryParam("exact", exact)
      .withQueryParam("export", export)
      .withPathParam("name", name)
      .withPathParam("namespace", namespace)
      .withSuccessResponse[IoK8sApiCoreV1ReplicationController](200)
      .withErrorResponse[Unit](401)
        /**
   * read scale of the specified ReplicationController
   * 
   * Expected answers:
   *   code 200 : IoK8sApiAutoscalingV1Scale (OK)
   *   code 401 :  (Unauthorized)
   * 
   * Available security schemes:
   *   BearerToken (apiKey)
   * 
   * @param name name of the Scale
   * @param namespace object name and auth scope, such as for teams and projects
   * @param pretty If &#39;true&#39;, then the output is pretty printed.
   */
  def readCoreV1NamespacedReplicationControllerScale(name: String, namespace: String, pretty: Option[String] = None)(implicit apiKey: ApiKeyValue): ApiRequest[IoK8sApiAutoscalingV1Scale] =
    ApiRequest[IoK8sApiAutoscalingV1Scale](ApiMethods.GET, "https://localhost", "/api/v1/namespaces/{namespace}/replicationcontrollers/{name}/scale", "*/*")
      .withApiKey(apiKey, "authorization", HEADER)
      .withQueryParam("pretty", pretty)
      .withPathParam("name", name)
      .withPathParam("namespace", namespace)
      .withSuccessResponse[IoK8sApiAutoscalingV1Scale](200)
      .withErrorResponse[Unit](401)
        /**
   * read status of the specified ReplicationController
   * 
   * Expected answers:
   *   code 200 : IoK8sApiCoreV1ReplicationController (OK)
   *   code 401 :  (Unauthorized)
   * 
   * Available security schemes:
   *   BearerToken (apiKey)
   * 
   * @param name name of the ReplicationController
   * @param namespace object name and auth scope, such as for teams and projects
   * @param pretty If &#39;true&#39;, then the output is pretty printed.
   */
  def readCoreV1NamespacedReplicationControllerStatus(name: String, namespace: String, pretty: Option[String] = None)(implicit apiKey: ApiKeyValue): ApiRequest[IoK8sApiCoreV1ReplicationController] =
    ApiRequest[IoK8sApiCoreV1ReplicationController](ApiMethods.GET, "https://localhost", "/api/v1/namespaces/{namespace}/replicationcontrollers/{name}/status", "*/*")
      .withApiKey(apiKey, "authorization", HEADER)
      .withQueryParam("pretty", pretty)
      .withPathParam("name", name)
      .withPathParam("namespace", namespace)
      .withSuccessResponse[IoK8sApiCoreV1ReplicationController](200)
      .withErrorResponse[Unit](401)
        /**
   * read the specified ResourceQuota
   * 
   * Expected answers:
   *   code 200 : IoK8sApiCoreV1ResourceQuota (OK)
   *   code 401 :  (Unauthorized)
   * 
   * Available security schemes:
   *   BearerToken (apiKey)
   * 
   * @param name name of the ResourceQuota
   * @param namespace object name and auth scope, such as for teams and projects
   * @param pretty If &#39;true&#39;, then the output is pretty printed.
   * @param exact Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;.
   * @param export Should this value be exported.  Export strips fields that a user can not specify.
   */
  def readCoreV1NamespacedResourceQuota(name: String, namespace: String, pretty: Option[String] = None, exact: Option[Boolean] = None, export: Option[Boolean] = None)(implicit apiKey: ApiKeyValue): ApiRequest[IoK8sApiCoreV1ResourceQuota] =
    ApiRequest[IoK8sApiCoreV1ResourceQuota](ApiMethods.GET, "https://localhost", "/api/v1/namespaces/{namespace}/resourcequotas/{name}", "*/*")
      .withApiKey(apiKey, "authorization", HEADER)
      .withQueryParam("pretty", pretty)
      .withQueryParam("exact", exact)
      .withQueryParam("export", export)
      .withPathParam("name", name)
      .withPathParam("namespace", namespace)
      .withSuccessResponse[IoK8sApiCoreV1ResourceQuota](200)
      .withErrorResponse[Unit](401)
        /**
   * read status of the specified ResourceQuota
   * 
   * Expected answers:
   *   code 200 : IoK8sApiCoreV1ResourceQuota (OK)
   *   code 401 :  (Unauthorized)
   * 
   * Available security schemes:
   *   BearerToken (apiKey)
   * 
   * @param name name of the ResourceQuota
   * @param namespace object name and auth scope, such as for teams and projects
   * @param pretty If &#39;true&#39;, then the output is pretty printed.
   */
  def readCoreV1NamespacedResourceQuotaStatus(name: String, namespace: String, pretty: Option[String] = None)(implicit apiKey: ApiKeyValue): ApiRequest[IoK8sApiCoreV1ResourceQuota] =
    ApiRequest[IoK8sApiCoreV1ResourceQuota](ApiMethods.GET, "https://localhost", "/api/v1/namespaces/{namespace}/resourcequotas/{name}/status", "*/*")
      .withApiKey(apiKey, "authorization", HEADER)
      .withQueryParam("pretty", pretty)
      .withPathParam("name", name)
      .withPathParam("namespace", namespace)
      .withSuccessResponse[IoK8sApiCoreV1ResourceQuota](200)
      .withErrorResponse[Unit](401)
        /**
   * read the specified Secret
   * 
   * Expected answers:
   *   code 200 : IoK8sApiCoreV1Secret (OK)
   *   code 401 :  (Unauthorized)
   * 
   * Available security schemes:
   *   BearerToken (apiKey)
   * 
   * @param name name of the Secret
   * @param namespace object name and auth scope, such as for teams and projects
   * @param pretty If &#39;true&#39;, then the output is pretty printed.
   * @param exact Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;.
   * @param export Should this value be exported.  Export strips fields that a user can not specify.
   */
  def readCoreV1NamespacedSecret(name: String, namespace: String, pretty: Option[String] = None, exact: Option[Boolean] = None, export: Option[Boolean] = None)(implicit apiKey: ApiKeyValue): ApiRequest[IoK8sApiCoreV1Secret] =
    ApiRequest[IoK8sApiCoreV1Secret](ApiMethods.GET, "https://localhost", "/api/v1/namespaces/{namespace}/secrets/{name}", "*/*")
      .withApiKey(apiKey, "authorization", HEADER)
      .withQueryParam("pretty", pretty)
      .withQueryParam("exact", exact)
      .withQueryParam("export", export)
      .withPathParam("name", name)
      .withPathParam("namespace", namespace)
      .withSuccessResponse[IoK8sApiCoreV1Secret](200)
      .withErrorResponse[Unit](401)
        /**
   * read the specified Service
   * 
   * Expected answers:
   *   code 200 : IoK8sApiCoreV1Service (OK)
   *   code 401 :  (Unauthorized)
   * 
   * Available security schemes:
   *   BearerToken (apiKey)
   * 
   * @param name name of the Service
   * @param namespace object name and auth scope, such as for teams and projects
   * @param pretty If &#39;true&#39;, then the output is pretty printed.
   * @param exact Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;.
   * @param export Should this value be exported.  Export strips fields that a user can not specify.
   */
  def readCoreV1NamespacedService(name: String, namespace: String, pretty: Option[String] = None, exact: Option[Boolean] = None, export: Option[Boolean] = None)(implicit apiKey: ApiKeyValue): ApiRequest[IoK8sApiCoreV1Service] =
    ApiRequest[IoK8sApiCoreV1Service](ApiMethods.GET, "https://localhost", "/api/v1/namespaces/{namespace}/services/{name}", "*/*")
      .withApiKey(apiKey, "authorization", HEADER)
      .withQueryParam("pretty", pretty)
      .withQueryParam("exact", exact)
      .withQueryParam("export", export)
      .withPathParam("name", name)
      .withPathParam("namespace", namespace)
      .withSuccessResponse[IoK8sApiCoreV1Service](200)
      .withErrorResponse[Unit](401)
        /**
   * read the specified ServiceAccount
   * 
   * Expected answers:
   *   code 200 : IoK8sApiCoreV1ServiceAccount (OK)
   *   code 401 :  (Unauthorized)
   * 
   * Available security schemes:
   *   BearerToken (apiKey)
   * 
   * @param name name of the ServiceAccount
   * @param namespace object name and auth scope, such as for teams and projects
   * @param pretty If &#39;true&#39;, then the output is pretty printed.
   * @param exact Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;.
   * @param export Should this value be exported.  Export strips fields that a user can not specify.
   */
  def readCoreV1NamespacedServiceAccount(name: String, namespace: String, pretty: Option[String] = None, exact: Option[Boolean] = None, export: Option[Boolean] = None)(implicit apiKey: ApiKeyValue): ApiRequest[IoK8sApiCoreV1ServiceAccount] =
    ApiRequest[IoK8sApiCoreV1ServiceAccount](ApiMethods.GET, "https://localhost", "/api/v1/namespaces/{namespace}/serviceaccounts/{name}", "*/*")
      .withApiKey(apiKey, "authorization", HEADER)
      .withQueryParam("pretty", pretty)
      .withQueryParam("exact", exact)
      .withQueryParam("export", export)
      .withPathParam("name", name)
      .withPathParam("namespace", namespace)
      .withSuccessResponse[IoK8sApiCoreV1ServiceAccount](200)
      .withErrorResponse[Unit](401)
        /**
   * read status of the specified Service
   * 
   * Expected answers:
   *   code 200 : IoK8sApiCoreV1Service (OK)
   *   code 401 :  (Unauthorized)
   * 
   * Available security schemes:
   *   BearerToken (apiKey)
   * 
   * @param name name of the Service
   * @param namespace object name and auth scope, such as for teams and projects
   * @param pretty If &#39;true&#39;, then the output is pretty printed.
   */
  def readCoreV1NamespacedServiceStatus(name: String, namespace: String, pretty: Option[String] = None)(implicit apiKey: ApiKeyValue): ApiRequest[IoK8sApiCoreV1Service] =
    ApiRequest[IoK8sApiCoreV1Service](ApiMethods.GET, "https://localhost", "/api/v1/namespaces/{namespace}/services/{name}/status", "*/*")
      .withApiKey(apiKey, "authorization", HEADER)
      .withQueryParam("pretty", pretty)
      .withPathParam("name", name)
      .withPathParam("namespace", namespace)
      .withSuccessResponse[IoK8sApiCoreV1Service](200)
      .withErrorResponse[Unit](401)
        /**
   * read the specified Node
   * 
   * Expected answers:
   *   code 200 : IoK8sApiCoreV1Node (OK)
   *   code 401 :  (Unauthorized)
   * 
   * Available security schemes:
   *   BearerToken (apiKey)
   * 
   * @param name name of the Node
   * @param pretty If &#39;true&#39;, then the output is pretty printed.
   * @param exact Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;.
   * @param export Should this value be exported.  Export strips fields that a user can not specify.
   */
  def readCoreV1Node(name: String, pretty: Option[String] = None, exact: Option[Boolean] = None, export: Option[Boolean] = None)(implicit apiKey: ApiKeyValue): ApiRequest[IoK8sApiCoreV1Node] =
    ApiRequest[IoK8sApiCoreV1Node](ApiMethods.GET, "https://localhost", "/api/v1/nodes/{name}", "*/*")
      .withApiKey(apiKey, "authorization", HEADER)
      .withQueryParam("pretty", pretty)
      .withQueryParam("exact", exact)
      .withQueryParam("export", export)
      .withPathParam("name", name)
      .withSuccessResponse[IoK8sApiCoreV1Node](200)
      .withErrorResponse[Unit](401)
        /**
   * read status of the specified Node
   * 
   * Expected answers:
   *   code 200 : IoK8sApiCoreV1Node (OK)
   *   code 401 :  (Unauthorized)
   * 
   * Available security schemes:
   *   BearerToken (apiKey)
   * 
   * @param name name of the Node
   * @param pretty If &#39;true&#39;, then the output is pretty printed.
   */
  def readCoreV1NodeStatus(name: String, pretty: Option[String] = None)(implicit apiKey: ApiKeyValue): ApiRequest[IoK8sApiCoreV1Node] =
    ApiRequest[IoK8sApiCoreV1Node](ApiMethods.GET, "https://localhost", "/api/v1/nodes/{name}/status", "*/*")
      .withApiKey(apiKey, "authorization", HEADER)
      .withQueryParam("pretty", pretty)
      .withPathParam("name", name)
      .withSuccessResponse[IoK8sApiCoreV1Node](200)
      .withErrorResponse[Unit](401)
        /**
   * read the specified PersistentVolume
   * 
   * Expected answers:
   *   code 200 : IoK8sApiCoreV1PersistentVolume (OK)
   *   code 401 :  (Unauthorized)
   * 
   * Available security schemes:
   *   BearerToken (apiKey)
   * 
   * @param name name of the PersistentVolume
   * @param pretty If &#39;true&#39;, then the output is pretty printed.
   * @param exact Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;.
   * @param export Should this value be exported.  Export strips fields that a user can not specify.
   */
  def readCoreV1PersistentVolume(name: String, pretty: Option[String] = None, exact: Option[Boolean] = None, export: Option[Boolean] = None)(implicit apiKey: ApiKeyValue): ApiRequest[IoK8sApiCoreV1PersistentVolume] =
    ApiRequest[IoK8sApiCoreV1PersistentVolume](ApiMethods.GET, "https://localhost", "/api/v1/persistentvolumes/{name}", "*/*")
      .withApiKey(apiKey, "authorization", HEADER)
      .withQueryParam("pretty", pretty)
      .withQueryParam("exact", exact)
      .withQueryParam("export", export)
      .withPathParam("name", name)
      .withSuccessResponse[IoK8sApiCoreV1PersistentVolume](200)
      .withErrorResponse[Unit](401)
        /**
   * read status of the specified PersistentVolume
   * 
   * Expected answers:
   *   code 200 : IoK8sApiCoreV1PersistentVolume (OK)
   *   code 401 :  (Unauthorized)
   * 
   * Available security schemes:
   *   BearerToken (apiKey)
   * 
   * @param name name of the PersistentVolume
   * @param pretty If &#39;true&#39;, then the output is pretty printed.
   */
  def readCoreV1PersistentVolumeStatus(name: String, pretty: Option[String] = None)(implicit apiKey: ApiKeyValue): ApiRequest[IoK8sApiCoreV1PersistentVolume] =
    ApiRequest[IoK8sApiCoreV1PersistentVolume](ApiMethods.GET, "https://localhost", "/api/v1/persistentvolumes/{name}/status", "*/*")
      .withApiKey(apiKey, "authorization", HEADER)
      .withQueryParam("pretty", pretty)
      .withPathParam("name", name)
      .withSuccessResponse[IoK8sApiCoreV1PersistentVolume](200)
      .withErrorResponse[Unit](401)
        /**
   * replace the specified Namespace
   * 
   * Expected answers:
   *   code 200 : IoK8sApiCoreV1Namespace (OK)
   *   code 201 : IoK8sApiCoreV1Namespace (Created)
   *   code 401 :  (Unauthorized)
   * 
   * Available security schemes:
   *   BearerToken (apiKey)
   * 
   * @param name name of the Namespace
   * @param body 
   * @param pretty If &#39;true&#39;, then the output is pretty printed.
   */
  def replaceCoreV1Namespace(name: String, body: IoK8sApiCoreV1Namespace, pretty: Option[String] = None)(implicit apiKey: ApiKeyValue): ApiRequest[IoK8sApiCoreV1Namespace] =
    ApiRequest[IoK8sApiCoreV1Namespace](ApiMethods.PUT, "https://localhost", "/api/v1/namespaces/{name}", "*/*")
      .withApiKey(apiKey, "authorization", HEADER)
      .withBody(body)
      .withQueryParam("pretty", pretty)
      .withPathParam("name", name)
      .withSuccessResponse[IoK8sApiCoreV1Namespace](200)
      .withErrorResponse[IoK8sApiCoreV1Namespace](201)
      .withErrorResponse[Unit](401)
        /**
   * replace finalize of the specified Namespace
   * 
   * Expected answers:
   *   code 200 : IoK8sApiCoreV1Namespace (OK)
   *   code 201 : IoK8sApiCoreV1Namespace (Created)
   *   code 401 :  (Unauthorized)
   * 
   * Available security schemes:
   *   BearerToken (apiKey)
   * 
   * @param name name of the Namespace
   * @param body 
   * @param pretty If &#39;true&#39;, then the output is pretty printed.
   */
  def replaceCoreV1NamespaceFinalize(name: String, body: IoK8sApiCoreV1Namespace, pretty: Option[String] = None)(implicit apiKey: ApiKeyValue): ApiRequest[IoK8sApiCoreV1Namespace] =
    ApiRequest[IoK8sApiCoreV1Namespace](ApiMethods.PUT, "https://localhost", "/api/v1/namespaces/{name}/finalize", "*/*")
      .withApiKey(apiKey, "authorization", HEADER)
      .withBody(body)
      .withQueryParam("pretty", pretty)
      .withPathParam("name", name)
      .withSuccessResponse[IoK8sApiCoreV1Namespace](200)
      .withErrorResponse[IoK8sApiCoreV1Namespace](201)
      .withErrorResponse[Unit](401)
        /**
   * replace status of the specified Namespace
   * 
   * Expected answers:
   *   code 200 : IoK8sApiCoreV1Namespace (OK)
   *   code 201 : IoK8sApiCoreV1Namespace (Created)
   *   code 401 :  (Unauthorized)
   * 
   * Available security schemes:
   *   BearerToken (apiKey)
   * 
   * @param name name of the Namespace
   * @param body 
   * @param pretty If &#39;true&#39;, then the output is pretty printed.
   */
  def replaceCoreV1NamespaceStatus(name: String, body: IoK8sApiCoreV1Namespace, pretty: Option[String] = None)(implicit apiKey: ApiKeyValue): ApiRequest[IoK8sApiCoreV1Namespace] =
    ApiRequest[IoK8sApiCoreV1Namespace](ApiMethods.PUT, "https://localhost", "/api/v1/namespaces/{name}/status", "*/*")
      .withApiKey(apiKey, "authorization", HEADER)
      .withBody(body)
      .withQueryParam("pretty", pretty)
      .withPathParam("name", name)
      .withSuccessResponse[IoK8sApiCoreV1Namespace](200)
      .withErrorResponse[IoK8sApiCoreV1Namespace](201)
      .withErrorResponse[Unit](401)
        /**
   * replace the specified ConfigMap
   * 
   * Expected answers:
   *   code 200 : IoK8sApiCoreV1ConfigMap (OK)
   *   code 201 : IoK8sApiCoreV1ConfigMap (Created)
   *   code 401 :  (Unauthorized)
   * 
   * Available security schemes:
   *   BearerToken (apiKey)
   * 
   * @param name name of the ConfigMap
   * @param namespace object name and auth scope, such as for teams and projects
   * @param body 
   * @param pretty If &#39;true&#39;, then the output is pretty printed.
   */
  def replaceCoreV1NamespacedConfigMap(name: String, namespace: String, body: IoK8sApiCoreV1ConfigMap, pretty: Option[String] = None)(implicit apiKey: ApiKeyValue): ApiRequest[IoK8sApiCoreV1ConfigMap] =
    ApiRequest[IoK8sApiCoreV1ConfigMap](ApiMethods.PUT, "https://localhost", "/api/v1/namespaces/{namespace}/configmaps/{name}", "*/*")
      .withApiKey(apiKey, "authorization", HEADER)
      .withBody(body)
      .withQueryParam("pretty", pretty)
      .withPathParam("name", name)
      .withPathParam("namespace", namespace)
      .withSuccessResponse[IoK8sApiCoreV1ConfigMap](200)
      .withErrorResponse[IoK8sApiCoreV1ConfigMap](201)
      .withErrorResponse[Unit](401)
        /**
   * replace the specified Endpoints
   * 
   * Expected answers:
   *   code 200 : IoK8sApiCoreV1Endpoints (OK)
   *   code 201 : IoK8sApiCoreV1Endpoints (Created)
   *   code 401 :  (Unauthorized)
   * 
   * Available security schemes:
   *   BearerToken (apiKey)
   * 
   * @param name name of the Endpoints
   * @param namespace object name and auth scope, such as for teams and projects
   * @param body 
   * @param pretty If &#39;true&#39;, then the output is pretty printed.
   */
  def replaceCoreV1NamespacedEndpoints(name: String, namespace: String, body: IoK8sApiCoreV1Endpoints, pretty: Option[String] = None)(implicit apiKey: ApiKeyValue): ApiRequest[IoK8sApiCoreV1Endpoints] =
    ApiRequest[IoK8sApiCoreV1Endpoints](ApiMethods.PUT, "https://localhost", "/api/v1/namespaces/{namespace}/endpoints/{name}", "*/*")
      .withApiKey(apiKey, "authorization", HEADER)
      .withBody(body)
      .withQueryParam("pretty", pretty)
      .withPathParam("name", name)
      .withPathParam("namespace", namespace)
      .withSuccessResponse[IoK8sApiCoreV1Endpoints](200)
      .withErrorResponse[IoK8sApiCoreV1Endpoints](201)
      .withErrorResponse[Unit](401)
        /**
   * replace the specified Event
   * 
   * Expected answers:
   *   code 200 : IoK8sApiCoreV1Event (OK)
   *   code 201 : IoK8sApiCoreV1Event (Created)
   *   code 401 :  (Unauthorized)
   * 
   * Available security schemes:
   *   BearerToken (apiKey)
   * 
   * @param name name of the Event
   * @param namespace object name and auth scope, such as for teams and projects
   * @param body 
   * @param pretty If &#39;true&#39;, then the output is pretty printed.
   */
  def replaceCoreV1NamespacedEvent(name: String, namespace: String, body: IoK8sApiCoreV1Event, pretty: Option[String] = None)(implicit apiKey: ApiKeyValue): ApiRequest[IoK8sApiCoreV1Event] =
    ApiRequest[IoK8sApiCoreV1Event](ApiMethods.PUT, "https://localhost", "/api/v1/namespaces/{namespace}/events/{name}", "*/*")
      .withApiKey(apiKey, "authorization", HEADER)
      .withBody(body)
      .withQueryParam("pretty", pretty)
      .withPathParam("name", name)
      .withPathParam("namespace", namespace)
      .withSuccessResponse[IoK8sApiCoreV1Event](200)
      .withErrorResponse[IoK8sApiCoreV1Event](201)
      .withErrorResponse[Unit](401)
        /**
   * replace the specified LimitRange
   * 
   * Expected answers:
   *   code 200 : IoK8sApiCoreV1LimitRange (OK)
   *   code 201 : IoK8sApiCoreV1LimitRange (Created)
   *   code 401 :  (Unauthorized)
   * 
   * Available security schemes:
   *   BearerToken (apiKey)
   * 
   * @param name name of the LimitRange
   * @param namespace object name and auth scope, such as for teams and projects
   * @param body 
   * @param pretty If &#39;true&#39;, then the output is pretty printed.
   */
  def replaceCoreV1NamespacedLimitRange(name: String, namespace: String, body: IoK8sApiCoreV1LimitRange, pretty: Option[String] = None)(implicit apiKey: ApiKeyValue): ApiRequest[IoK8sApiCoreV1LimitRange] =
    ApiRequest[IoK8sApiCoreV1LimitRange](ApiMethods.PUT, "https://localhost", "/api/v1/namespaces/{namespace}/limitranges/{name}", "*/*")
      .withApiKey(apiKey, "authorization", HEADER)
      .withBody(body)
      .withQueryParam("pretty", pretty)
      .withPathParam("name", name)
      .withPathParam("namespace", namespace)
      .withSuccessResponse[IoK8sApiCoreV1LimitRange](200)
      .withErrorResponse[IoK8sApiCoreV1LimitRange](201)
      .withErrorResponse[Unit](401)
        /**
   * replace the specified PersistentVolumeClaim
   * 
   * Expected answers:
   *   code 200 : IoK8sApiCoreV1PersistentVolumeClaim (OK)
   *   code 201 : IoK8sApiCoreV1PersistentVolumeClaim (Created)
   *   code 401 :  (Unauthorized)
   * 
   * Available security schemes:
   *   BearerToken (apiKey)
   * 
   * @param name name of the PersistentVolumeClaim
   * @param namespace object name and auth scope, such as for teams and projects
   * @param body 
   * @param pretty If &#39;true&#39;, then the output is pretty printed.
   */
  def replaceCoreV1NamespacedPersistentVolumeClaim(name: String, namespace: String, body: IoK8sApiCoreV1PersistentVolumeClaim, pretty: Option[String] = None)(implicit apiKey: ApiKeyValue): ApiRequest[IoK8sApiCoreV1PersistentVolumeClaim] =
    ApiRequest[IoK8sApiCoreV1PersistentVolumeClaim](ApiMethods.PUT, "https://localhost", "/api/v1/namespaces/{namespace}/persistentvolumeclaims/{name}", "*/*")
      .withApiKey(apiKey, "authorization", HEADER)
      .withBody(body)
      .withQueryParam("pretty", pretty)
      .withPathParam("name", name)
      .withPathParam("namespace", namespace)
      .withSuccessResponse[IoK8sApiCoreV1PersistentVolumeClaim](200)
      .withErrorResponse[IoK8sApiCoreV1PersistentVolumeClaim](201)
      .withErrorResponse[Unit](401)
        /**
   * replace status of the specified PersistentVolumeClaim
   * 
   * Expected answers:
   *   code 200 : IoK8sApiCoreV1PersistentVolumeClaim (OK)
   *   code 201 : IoK8sApiCoreV1PersistentVolumeClaim (Created)
   *   code 401 :  (Unauthorized)
   * 
   * Available security schemes:
   *   BearerToken (apiKey)
   * 
   * @param name name of the PersistentVolumeClaim
   * @param namespace object name and auth scope, such as for teams and projects
   * @param body 
   * @param pretty If &#39;true&#39;, then the output is pretty printed.
   */
  def replaceCoreV1NamespacedPersistentVolumeClaimStatus(name: String, namespace: String, body: IoK8sApiCoreV1PersistentVolumeClaim, pretty: Option[String] = None)(implicit apiKey: ApiKeyValue): ApiRequest[IoK8sApiCoreV1PersistentVolumeClaim] =
    ApiRequest[IoK8sApiCoreV1PersistentVolumeClaim](ApiMethods.PUT, "https://localhost", "/api/v1/namespaces/{namespace}/persistentvolumeclaims/{name}/status", "*/*")
      .withApiKey(apiKey, "authorization", HEADER)
      .withBody(body)
      .withQueryParam("pretty", pretty)
      .withPathParam("name", name)
      .withPathParam("namespace", namespace)
      .withSuccessResponse[IoK8sApiCoreV1PersistentVolumeClaim](200)
      .withErrorResponse[IoK8sApiCoreV1PersistentVolumeClaim](201)
      .withErrorResponse[Unit](401)
        /**
   * replace the specified Pod
   * 
   * Expected answers:
   *   code 200 : IoK8sApiCoreV1Pod (OK)
   *   code 201 : IoK8sApiCoreV1Pod (Created)
   *   code 401 :  (Unauthorized)
   * 
   * Available security schemes:
   *   BearerToken (apiKey)
   * 
   * @param name name of the Pod
   * @param namespace object name and auth scope, such as for teams and projects
   * @param body 
   * @param pretty If &#39;true&#39;, then the output is pretty printed.
   */
  def replaceCoreV1NamespacedPod(name: String, namespace: String, body: IoK8sApiCoreV1Pod, pretty: Option[String] = None)(implicit apiKey: ApiKeyValue): ApiRequest[IoK8sApiCoreV1Pod] =
    ApiRequest[IoK8sApiCoreV1Pod](ApiMethods.PUT, "https://localhost", "/api/v1/namespaces/{namespace}/pods/{name}", "*/*")
      .withApiKey(apiKey, "authorization", HEADER)
      .withBody(body)
      .withQueryParam("pretty", pretty)
      .withPathParam("name", name)
      .withPathParam("namespace", namespace)
      .withSuccessResponse[IoK8sApiCoreV1Pod](200)
      .withErrorResponse[IoK8sApiCoreV1Pod](201)
      .withErrorResponse[Unit](401)
        /**
   * replace status of the specified Pod
   * 
   * Expected answers:
   *   code 200 : IoK8sApiCoreV1Pod (OK)
   *   code 201 : IoK8sApiCoreV1Pod (Created)
   *   code 401 :  (Unauthorized)
   * 
   * Available security schemes:
   *   BearerToken (apiKey)
   * 
   * @param name name of the Pod
   * @param namespace object name and auth scope, such as for teams and projects
   * @param body 
   * @param pretty If &#39;true&#39;, then the output is pretty printed.
   */
  def replaceCoreV1NamespacedPodStatus(name: String, namespace: String, body: IoK8sApiCoreV1Pod, pretty: Option[String] = None)(implicit apiKey: ApiKeyValue): ApiRequest[IoK8sApiCoreV1Pod] =
    ApiRequest[IoK8sApiCoreV1Pod](ApiMethods.PUT, "https://localhost", "/api/v1/namespaces/{namespace}/pods/{name}/status", "*/*")
      .withApiKey(apiKey, "authorization", HEADER)
      .withBody(body)
      .withQueryParam("pretty", pretty)
      .withPathParam("name", name)
      .withPathParam("namespace", namespace)
      .withSuccessResponse[IoK8sApiCoreV1Pod](200)
      .withErrorResponse[IoK8sApiCoreV1Pod](201)
      .withErrorResponse[Unit](401)
        /**
   * replace the specified PodTemplate
   * 
   * Expected answers:
   *   code 200 : IoK8sApiCoreV1PodTemplate (OK)
   *   code 201 : IoK8sApiCoreV1PodTemplate (Created)
   *   code 401 :  (Unauthorized)
   * 
   * Available security schemes:
   *   BearerToken (apiKey)
   * 
   * @param name name of the PodTemplate
   * @param namespace object name and auth scope, such as for teams and projects
   * @param body 
   * @param pretty If &#39;true&#39;, then the output is pretty printed.
   */
  def replaceCoreV1NamespacedPodTemplate(name: String, namespace: String, body: IoK8sApiCoreV1PodTemplate, pretty: Option[String] = None)(implicit apiKey: ApiKeyValue): ApiRequest[IoK8sApiCoreV1PodTemplate] =
    ApiRequest[IoK8sApiCoreV1PodTemplate](ApiMethods.PUT, "https://localhost", "/api/v1/namespaces/{namespace}/podtemplates/{name}", "*/*")
      .withApiKey(apiKey, "authorization", HEADER)
      .withBody(body)
      .withQueryParam("pretty", pretty)
      .withPathParam("name", name)
      .withPathParam("namespace", namespace)
      .withSuccessResponse[IoK8sApiCoreV1PodTemplate](200)
      .withErrorResponse[IoK8sApiCoreV1PodTemplate](201)
      .withErrorResponse[Unit](401)
        /**
   * replace the specified ReplicationController
   * 
   * Expected answers:
   *   code 200 : IoK8sApiCoreV1ReplicationController (OK)
   *   code 201 : IoK8sApiCoreV1ReplicationController (Created)
   *   code 401 :  (Unauthorized)
   * 
   * Available security schemes:
   *   BearerToken (apiKey)
   * 
   * @param name name of the ReplicationController
   * @param namespace object name and auth scope, such as for teams and projects
   * @param body 
   * @param pretty If &#39;true&#39;, then the output is pretty printed.
   */
  def replaceCoreV1NamespacedReplicationController(name: String, namespace: String, body: IoK8sApiCoreV1ReplicationController, pretty: Option[String] = None)(implicit apiKey: ApiKeyValue): ApiRequest[IoK8sApiCoreV1ReplicationController] =
    ApiRequest[IoK8sApiCoreV1ReplicationController](ApiMethods.PUT, "https://localhost", "/api/v1/namespaces/{namespace}/replicationcontrollers/{name}", "*/*")
      .withApiKey(apiKey, "authorization", HEADER)
      .withBody(body)
      .withQueryParam("pretty", pretty)
      .withPathParam("name", name)
      .withPathParam("namespace", namespace)
      .withSuccessResponse[IoK8sApiCoreV1ReplicationController](200)
      .withErrorResponse[IoK8sApiCoreV1ReplicationController](201)
      .withErrorResponse[Unit](401)
        /**
   * replace scale of the specified ReplicationController
   * 
   * Expected answers:
   *   code 200 : IoK8sApiAutoscalingV1Scale (OK)
   *   code 201 : IoK8sApiAutoscalingV1Scale (Created)
   *   code 401 :  (Unauthorized)
   * 
   * Available security schemes:
   *   BearerToken (apiKey)
   * 
   * @param name name of the Scale
   * @param namespace object name and auth scope, such as for teams and projects
   * @param body 
   * @param pretty If &#39;true&#39;, then the output is pretty printed.
   */
  def replaceCoreV1NamespacedReplicationControllerScale(name: String, namespace: String, body: IoK8sApiAutoscalingV1Scale, pretty: Option[String] = None)(implicit apiKey: ApiKeyValue): ApiRequest[IoK8sApiAutoscalingV1Scale] =
    ApiRequest[IoK8sApiAutoscalingV1Scale](ApiMethods.PUT, "https://localhost", "/api/v1/namespaces/{namespace}/replicationcontrollers/{name}/scale", "*/*")
      .withApiKey(apiKey, "authorization", HEADER)
      .withBody(body)
      .withQueryParam("pretty", pretty)
      .withPathParam("name", name)
      .withPathParam("namespace", namespace)
      .withSuccessResponse[IoK8sApiAutoscalingV1Scale](200)
      .withErrorResponse[IoK8sApiAutoscalingV1Scale](201)
      .withErrorResponse[Unit](401)
        /**
   * replace status of the specified ReplicationController
   * 
   * Expected answers:
   *   code 200 : IoK8sApiCoreV1ReplicationController (OK)
   *   code 201 : IoK8sApiCoreV1ReplicationController (Created)
   *   code 401 :  (Unauthorized)
   * 
   * Available security schemes:
   *   BearerToken (apiKey)
   * 
   * @param name name of the ReplicationController
   * @param namespace object name and auth scope, such as for teams and projects
   * @param body 
   * @param pretty If &#39;true&#39;, then the output is pretty printed.
   */
  def replaceCoreV1NamespacedReplicationControllerStatus(name: String, namespace: String, body: IoK8sApiCoreV1ReplicationController, pretty: Option[String] = None)(implicit apiKey: ApiKeyValue): ApiRequest[IoK8sApiCoreV1ReplicationController] =
    ApiRequest[IoK8sApiCoreV1ReplicationController](ApiMethods.PUT, "https://localhost", "/api/v1/namespaces/{namespace}/replicationcontrollers/{name}/status", "*/*")
      .withApiKey(apiKey, "authorization", HEADER)
      .withBody(body)
      .withQueryParam("pretty", pretty)
      .withPathParam("name", name)
      .withPathParam("namespace", namespace)
      .withSuccessResponse[IoK8sApiCoreV1ReplicationController](200)
      .withErrorResponse[IoK8sApiCoreV1ReplicationController](201)
      .withErrorResponse[Unit](401)
        /**
   * replace the specified ResourceQuota
   * 
   * Expected answers:
   *   code 200 : IoK8sApiCoreV1ResourceQuota (OK)
   *   code 201 : IoK8sApiCoreV1ResourceQuota (Created)
   *   code 401 :  (Unauthorized)
   * 
   * Available security schemes:
   *   BearerToken (apiKey)
   * 
   * @param name name of the ResourceQuota
   * @param namespace object name and auth scope, such as for teams and projects
   * @param body 
   * @param pretty If &#39;true&#39;, then the output is pretty printed.
   */
  def replaceCoreV1NamespacedResourceQuota(name: String, namespace: String, body: IoK8sApiCoreV1ResourceQuota, pretty: Option[String] = None)(implicit apiKey: ApiKeyValue): ApiRequest[IoK8sApiCoreV1ResourceQuota] =
    ApiRequest[IoK8sApiCoreV1ResourceQuota](ApiMethods.PUT, "https://localhost", "/api/v1/namespaces/{namespace}/resourcequotas/{name}", "*/*")
      .withApiKey(apiKey, "authorization", HEADER)
      .withBody(body)
      .withQueryParam("pretty", pretty)
      .withPathParam("name", name)
      .withPathParam("namespace", namespace)
      .withSuccessResponse[IoK8sApiCoreV1ResourceQuota](200)
      .withErrorResponse[IoK8sApiCoreV1ResourceQuota](201)
      .withErrorResponse[Unit](401)
        /**
   * replace status of the specified ResourceQuota
   * 
   * Expected answers:
   *   code 200 : IoK8sApiCoreV1ResourceQuota (OK)
   *   code 201 : IoK8sApiCoreV1ResourceQuota (Created)
   *   code 401 :  (Unauthorized)
   * 
   * Available security schemes:
   *   BearerToken (apiKey)
   * 
   * @param name name of the ResourceQuota
   * @param namespace object name and auth scope, such as for teams and projects
   * @param body 
   * @param pretty If &#39;true&#39;, then the output is pretty printed.
   */
  def replaceCoreV1NamespacedResourceQuotaStatus(name: String, namespace: String, body: IoK8sApiCoreV1ResourceQuota, pretty: Option[String] = None)(implicit apiKey: ApiKeyValue): ApiRequest[IoK8sApiCoreV1ResourceQuota] =
    ApiRequest[IoK8sApiCoreV1ResourceQuota](ApiMethods.PUT, "https://localhost", "/api/v1/namespaces/{namespace}/resourcequotas/{name}/status", "*/*")
      .withApiKey(apiKey, "authorization", HEADER)
      .withBody(body)
      .withQueryParam("pretty", pretty)
      .withPathParam("name", name)
      .withPathParam("namespace", namespace)
      .withSuccessResponse[IoK8sApiCoreV1ResourceQuota](200)
      .withErrorResponse[IoK8sApiCoreV1ResourceQuota](201)
      .withErrorResponse[Unit](401)
        /**
   * replace the specified Secret
   * 
   * Expected answers:
   *   code 200 : IoK8sApiCoreV1Secret (OK)
   *   code 201 : IoK8sApiCoreV1Secret (Created)
   *   code 401 :  (Unauthorized)
   * 
   * Available security schemes:
   *   BearerToken (apiKey)
   * 
   * @param name name of the Secret
   * @param namespace object name and auth scope, such as for teams and projects
   * @param body 
   * @param pretty If &#39;true&#39;, then the output is pretty printed.
   */
  def replaceCoreV1NamespacedSecret(name: String, namespace: String, body: IoK8sApiCoreV1Secret, pretty: Option[String] = None)(implicit apiKey: ApiKeyValue): ApiRequest[IoK8sApiCoreV1Secret] =
    ApiRequest[IoK8sApiCoreV1Secret](ApiMethods.PUT, "https://localhost", "/api/v1/namespaces/{namespace}/secrets/{name}", "*/*")
      .withApiKey(apiKey, "authorization", HEADER)
      .withBody(body)
      .withQueryParam("pretty", pretty)
      .withPathParam("name", name)
      .withPathParam("namespace", namespace)
      .withSuccessResponse[IoK8sApiCoreV1Secret](200)
      .withErrorResponse[IoK8sApiCoreV1Secret](201)
      .withErrorResponse[Unit](401)
        /**
   * replace the specified Service
   * 
   * Expected answers:
   *   code 200 : IoK8sApiCoreV1Service (OK)
   *   code 201 : IoK8sApiCoreV1Service (Created)
   *   code 401 :  (Unauthorized)
   * 
   * Available security schemes:
   *   BearerToken (apiKey)
   * 
   * @param name name of the Service
   * @param namespace object name and auth scope, such as for teams and projects
   * @param body 
   * @param pretty If &#39;true&#39;, then the output is pretty printed.
   */
  def replaceCoreV1NamespacedService(name: String, namespace: String, body: IoK8sApiCoreV1Service, pretty: Option[String] = None)(implicit apiKey: ApiKeyValue): ApiRequest[IoK8sApiCoreV1Service] =
    ApiRequest[IoK8sApiCoreV1Service](ApiMethods.PUT, "https://localhost", "/api/v1/namespaces/{namespace}/services/{name}", "*/*")
      .withApiKey(apiKey, "authorization", HEADER)
      .withBody(body)
      .withQueryParam("pretty", pretty)
      .withPathParam("name", name)
      .withPathParam("namespace", namespace)
      .withSuccessResponse[IoK8sApiCoreV1Service](200)
      .withErrorResponse[IoK8sApiCoreV1Service](201)
      .withErrorResponse[Unit](401)
        /**
   * replace the specified ServiceAccount
   * 
   * Expected answers:
   *   code 200 : IoK8sApiCoreV1ServiceAccount (OK)
   *   code 201 : IoK8sApiCoreV1ServiceAccount (Created)
   *   code 401 :  (Unauthorized)
   * 
   * Available security schemes:
   *   BearerToken (apiKey)
   * 
   * @param name name of the ServiceAccount
   * @param namespace object name and auth scope, such as for teams and projects
   * @param body 
   * @param pretty If &#39;true&#39;, then the output is pretty printed.
   */
  def replaceCoreV1NamespacedServiceAccount(name: String, namespace: String, body: IoK8sApiCoreV1ServiceAccount, pretty: Option[String] = None)(implicit apiKey: ApiKeyValue): ApiRequest[IoK8sApiCoreV1ServiceAccount] =
    ApiRequest[IoK8sApiCoreV1ServiceAccount](ApiMethods.PUT, "https://localhost", "/api/v1/namespaces/{namespace}/serviceaccounts/{name}", "*/*")
      .withApiKey(apiKey, "authorization", HEADER)
      .withBody(body)
      .withQueryParam("pretty", pretty)
      .withPathParam("name", name)
      .withPathParam("namespace", namespace)
      .withSuccessResponse[IoK8sApiCoreV1ServiceAccount](200)
      .withErrorResponse[IoK8sApiCoreV1ServiceAccount](201)
      .withErrorResponse[Unit](401)
        /**
   * replace status of the specified Service
   * 
   * Expected answers:
   *   code 200 : IoK8sApiCoreV1Service (OK)
   *   code 201 : IoK8sApiCoreV1Service (Created)
   *   code 401 :  (Unauthorized)
   * 
   * Available security schemes:
   *   BearerToken (apiKey)
   * 
   * @param name name of the Service
   * @param namespace object name and auth scope, such as for teams and projects
   * @param body 
   * @param pretty If &#39;true&#39;, then the output is pretty printed.
   */
  def replaceCoreV1NamespacedServiceStatus(name: String, namespace: String, body: IoK8sApiCoreV1Service, pretty: Option[String] = None)(implicit apiKey: ApiKeyValue): ApiRequest[IoK8sApiCoreV1Service] =
    ApiRequest[IoK8sApiCoreV1Service](ApiMethods.PUT, "https://localhost", "/api/v1/namespaces/{namespace}/services/{name}/status", "*/*")
      .withApiKey(apiKey, "authorization", HEADER)
      .withBody(body)
      .withQueryParam("pretty", pretty)
      .withPathParam("name", name)
      .withPathParam("namespace", namespace)
      .withSuccessResponse[IoK8sApiCoreV1Service](200)
      .withErrorResponse[IoK8sApiCoreV1Service](201)
      .withErrorResponse[Unit](401)
        /**
   * replace the specified Node
   * 
   * Expected answers:
   *   code 200 : IoK8sApiCoreV1Node (OK)
   *   code 201 : IoK8sApiCoreV1Node (Created)
   *   code 401 :  (Unauthorized)
   * 
   * Available security schemes:
   *   BearerToken (apiKey)
   * 
   * @param name name of the Node
   * @param body 
   * @param pretty If &#39;true&#39;, then the output is pretty printed.
   */
  def replaceCoreV1Node(name: String, body: IoK8sApiCoreV1Node, pretty: Option[String] = None)(implicit apiKey: ApiKeyValue): ApiRequest[IoK8sApiCoreV1Node] =
    ApiRequest[IoK8sApiCoreV1Node](ApiMethods.PUT, "https://localhost", "/api/v1/nodes/{name}", "*/*")
      .withApiKey(apiKey, "authorization", HEADER)
      .withBody(body)
      .withQueryParam("pretty", pretty)
      .withPathParam("name", name)
      .withSuccessResponse[IoK8sApiCoreV1Node](200)
      .withErrorResponse[IoK8sApiCoreV1Node](201)
      .withErrorResponse[Unit](401)
        /**
   * replace status of the specified Node
   * 
   * Expected answers:
   *   code 200 : IoK8sApiCoreV1Node (OK)
   *   code 201 : IoK8sApiCoreV1Node (Created)
   *   code 401 :  (Unauthorized)
   * 
   * Available security schemes:
   *   BearerToken (apiKey)
   * 
   * @param name name of the Node
   * @param body 
   * @param pretty If &#39;true&#39;, then the output is pretty printed.
   */
  def replaceCoreV1NodeStatus(name: String, body: IoK8sApiCoreV1Node, pretty: Option[String] = None)(implicit apiKey: ApiKeyValue): ApiRequest[IoK8sApiCoreV1Node] =
    ApiRequest[IoK8sApiCoreV1Node](ApiMethods.PUT, "https://localhost", "/api/v1/nodes/{name}/status", "*/*")
      .withApiKey(apiKey, "authorization", HEADER)
      .withBody(body)
      .withQueryParam("pretty", pretty)
      .withPathParam("name", name)
      .withSuccessResponse[IoK8sApiCoreV1Node](200)
      .withErrorResponse[IoK8sApiCoreV1Node](201)
      .withErrorResponse[Unit](401)
        /**
   * replace the specified PersistentVolume
   * 
   * Expected answers:
   *   code 200 : IoK8sApiCoreV1PersistentVolume (OK)
   *   code 201 : IoK8sApiCoreV1PersistentVolume (Created)
   *   code 401 :  (Unauthorized)
   * 
   * Available security schemes:
   *   BearerToken (apiKey)
   * 
   * @param name name of the PersistentVolume
   * @param body 
   * @param pretty If &#39;true&#39;, then the output is pretty printed.
   */
  def replaceCoreV1PersistentVolume(name: String, body: IoK8sApiCoreV1PersistentVolume, pretty: Option[String] = None)(implicit apiKey: ApiKeyValue): ApiRequest[IoK8sApiCoreV1PersistentVolume] =
    ApiRequest[IoK8sApiCoreV1PersistentVolume](ApiMethods.PUT, "https://localhost", "/api/v1/persistentvolumes/{name}", "*/*")
      .withApiKey(apiKey, "authorization", HEADER)
      .withBody(body)
      .withQueryParam("pretty", pretty)
      .withPathParam("name", name)
      .withSuccessResponse[IoK8sApiCoreV1PersistentVolume](200)
      .withErrorResponse[IoK8sApiCoreV1PersistentVolume](201)
      .withErrorResponse[Unit](401)
        /**
   * replace status of the specified PersistentVolume
   * 
   * Expected answers:
   *   code 200 : IoK8sApiCoreV1PersistentVolume (OK)
   *   code 201 : IoK8sApiCoreV1PersistentVolume (Created)
   *   code 401 :  (Unauthorized)
   * 
   * Available security schemes:
   *   BearerToken (apiKey)
   * 
   * @param name name of the PersistentVolume
   * @param body 
   * @param pretty If &#39;true&#39;, then the output is pretty printed.
   */
  def replaceCoreV1PersistentVolumeStatus(name: String, body: IoK8sApiCoreV1PersistentVolume, pretty: Option[String] = None)(implicit apiKey: ApiKeyValue): ApiRequest[IoK8sApiCoreV1PersistentVolume] =
    ApiRequest[IoK8sApiCoreV1PersistentVolume](ApiMethods.PUT, "https://localhost", "/api/v1/persistentvolumes/{name}/status", "*/*")
      .withApiKey(apiKey, "authorization", HEADER)
      .withBody(body)
      .withQueryParam("pretty", pretty)
      .withPathParam("name", name)
      .withSuccessResponse[IoK8sApiCoreV1PersistentVolume](200)
      .withErrorResponse[IoK8sApiCoreV1PersistentVolume](201)
      .withErrorResponse[Unit](401)
        /**
   * watch individual changes to a list of ConfigMap
   * 
   * Expected answers:
   *   code 200 : IoK8sApimachineryPkgApisMetaV1WatchEvent (OK)
   *   code 401 :  (Unauthorized)
   * 
   * Available security schemes:
   *   BearerToken (apiKey)
   * 
   * @param continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
   * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
   * @param includeUninitialized If true, partially initialized resources are included in the response.
   * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
   * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
   * @param pretty If &#39;true&#39;, then the output is pretty printed.
   * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
   * @param timeoutSeconds Timeout for the list/watch call.
   * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
   */
  def watchCoreV1ConfigMapListForAllNamespaces(continue: Option[String] = None, fieldSelector: Option[String] = None, includeUninitialized: Option[Boolean] = None, labelSelector: Option[String] = None, limit: Option[Int] = None, pretty: Option[String] = None, resourceVersion: Option[String] = None, timeoutSeconds: Option[Int] = None, watch: Option[Boolean] = None)(implicit apiKey: ApiKeyValue): ApiRequest[IoK8sApimachineryPkgApisMetaV1WatchEvent] =
    ApiRequest[IoK8sApimachineryPkgApisMetaV1WatchEvent](ApiMethods.GET, "https://localhost", "/api/v1/watch/configmaps", "*/*")
      .withApiKey(apiKey, "authorization", HEADER)
      .withQueryParam("continue", continue)
      .withQueryParam("fieldSelector", fieldSelector)
      .withQueryParam("includeUninitialized", includeUninitialized)
      .withQueryParam("labelSelector", labelSelector)
      .withQueryParam("limit", limit)
      .withQueryParam("pretty", pretty)
      .withQueryParam("resourceVersion", resourceVersion)
      .withQueryParam("timeoutSeconds", timeoutSeconds)
      .withQueryParam("watch", watch)
      .withSuccessResponse[IoK8sApimachineryPkgApisMetaV1WatchEvent](200)
      .withErrorResponse[Unit](401)
        /**
   * watch individual changes to a list of Endpoints
   * 
   * Expected answers:
   *   code 200 : IoK8sApimachineryPkgApisMetaV1WatchEvent (OK)
   *   code 401 :  (Unauthorized)
   * 
   * Available security schemes:
   *   BearerToken (apiKey)
   * 
   * @param continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
   * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
   * @param includeUninitialized If true, partially initialized resources are included in the response.
   * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
   * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
   * @param pretty If &#39;true&#39;, then the output is pretty printed.
   * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
   * @param timeoutSeconds Timeout for the list/watch call.
   * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
   */
  def watchCoreV1EndpointsListForAllNamespaces(continue: Option[String] = None, fieldSelector: Option[String] = None, includeUninitialized: Option[Boolean] = None, labelSelector: Option[String] = None, limit: Option[Int] = None, pretty: Option[String] = None, resourceVersion: Option[String] = None, timeoutSeconds: Option[Int] = None, watch: Option[Boolean] = None)(implicit apiKey: ApiKeyValue): ApiRequest[IoK8sApimachineryPkgApisMetaV1WatchEvent] =
    ApiRequest[IoK8sApimachineryPkgApisMetaV1WatchEvent](ApiMethods.GET, "https://localhost", "/api/v1/watch/endpoints", "*/*")
      .withApiKey(apiKey, "authorization", HEADER)
      .withQueryParam("continue", continue)
      .withQueryParam("fieldSelector", fieldSelector)
      .withQueryParam("includeUninitialized", includeUninitialized)
      .withQueryParam("labelSelector", labelSelector)
      .withQueryParam("limit", limit)
      .withQueryParam("pretty", pretty)
      .withQueryParam("resourceVersion", resourceVersion)
      .withQueryParam("timeoutSeconds", timeoutSeconds)
      .withQueryParam("watch", watch)
      .withSuccessResponse[IoK8sApimachineryPkgApisMetaV1WatchEvent](200)
      .withErrorResponse[Unit](401)
        /**
   * watch individual changes to a list of Event
   * 
   * Expected answers:
   *   code 200 : IoK8sApimachineryPkgApisMetaV1WatchEvent (OK)
   *   code 401 :  (Unauthorized)
   * 
   * Available security schemes:
   *   BearerToken (apiKey)
   * 
   * @param continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
   * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
   * @param includeUninitialized If true, partially initialized resources are included in the response.
   * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
   * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
   * @param pretty If &#39;true&#39;, then the output is pretty printed.
   * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
   * @param timeoutSeconds Timeout for the list/watch call.
   * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
   */
  def watchCoreV1EventListForAllNamespaces(continue: Option[String] = None, fieldSelector: Option[String] = None, includeUninitialized: Option[Boolean] = None, labelSelector: Option[String] = None, limit: Option[Int] = None, pretty: Option[String] = None, resourceVersion: Option[String] = None, timeoutSeconds: Option[Int] = None, watch: Option[Boolean] = None)(implicit apiKey: ApiKeyValue): ApiRequest[IoK8sApimachineryPkgApisMetaV1WatchEvent] =
    ApiRequest[IoK8sApimachineryPkgApisMetaV1WatchEvent](ApiMethods.GET, "https://localhost", "/api/v1/watch/events", "*/*")
      .withApiKey(apiKey, "authorization", HEADER)
      .withQueryParam("continue", continue)
      .withQueryParam("fieldSelector", fieldSelector)
      .withQueryParam("includeUninitialized", includeUninitialized)
      .withQueryParam("labelSelector", labelSelector)
      .withQueryParam("limit", limit)
      .withQueryParam("pretty", pretty)
      .withQueryParam("resourceVersion", resourceVersion)
      .withQueryParam("timeoutSeconds", timeoutSeconds)
      .withQueryParam("watch", watch)
      .withSuccessResponse[IoK8sApimachineryPkgApisMetaV1WatchEvent](200)
      .withErrorResponse[Unit](401)
        /**
   * watch individual changes to a list of LimitRange
   * 
   * Expected answers:
   *   code 200 : IoK8sApimachineryPkgApisMetaV1WatchEvent (OK)
   *   code 401 :  (Unauthorized)
   * 
   * Available security schemes:
   *   BearerToken (apiKey)
   * 
   * @param continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
   * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
   * @param includeUninitialized If true, partially initialized resources are included in the response.
   * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
   * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
   * @param pretty If &#39;true&#39;, then the output is pretty printed.
   * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
   * @param timeoutSeconds Timeout for the list/watch call.
   * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
   */
  def watchCoreV1LimitRangeListForAllNamespaces(continue: Option[String] = None, fieldSelector: Option[String] = None, includeUninitialized: Option[Boolean] = None, labelSelector: Option[String] = None, limit: Option[Int] = None, pretty: Option[String] = None, resourceVersion: Option[String] = None, timeoutSeconds: Option[Int] = None, watch: Option[Boolean] = None)(implicit apiKey: ApiKeyValue): ApiRequest[IoK8sApimachineryPkgApisMetaV1WatchEvent] =
    ApiRequest[IoK8sApimachineryPkgApisMetaV1WatchEvent](ApiMethods.GET, "https://localhost", "/api/v1/watch/limitranges", "*/*")
      .withApiKey(apiKey, "authorization", HEADER)
      .withQueryParam("continue", continue)
      .withQueryParam("fieldSelector", fieldSelector)
      .withQueryParam("includeUninitialized", includeUninitialized)
      .withQueryParam("labelSelector", labelSelector)
      .withQueryParam("limit", limit)
      .withQueryParam("pretty", pretty)
      .withQueryParam("resourceVersion", resourceVersion)
      .withQueryParam("timeoutSeconds", timeoutSeconds)
      .withQueryParam("watch", watch)
      .withSuccessResponse[IoK8sApimachineryPkgApisMetaV1WatchEvent](200)
      .withErrorResponse[Unit](401)
        /**
   * watch changes to an object of kind Namespace
   * 
   * Expected answers:
   *   code 200 : IoK8sApimachineryPkgApisMetaV1WatchEvent (OK)
   *   code 401 :  (Unauthorized)
   * 
   * Available security schemes:
   *   BearerToken (apiKey)
   * 
   * @param name name of the Namespace
   * @param continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
   * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
   * @param includeUninitialized If true, partially initialized resources are included in the response.
   * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
   * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
   * @param pretty If &#39;true&#39;, then the output is pretty printed.
   * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
   * @param timeoutSeconds Timeout for the list/watch call.
   * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
   */
  def watchCoreV1Namespace(name: String, continue: Option[String] = None, fieldSelector: Option[String] = None, includeUninitialized: Option[Boolean] = None, labelSelector: Option[String] = None, limit: Option[Int] = None, pretty: Option[String] = None, resourceVersion: Option[String] = None, timeoutSeconds: Option[Int] = None, watch: Option[Boolean] = None)(implicit apiKey: ApiKeyValue): ApiRequest[IoK8sApimachineryPkgApisMetaV1WatchEvent] =
    ApiRequest[IoK8sApimachineryPkgApisMetaV1WatchEvent](ApiMethods.GET, "https://localhost", "/api/v1/watch/namespaces/{name}", "*/*")
      .withApiKey(apiKey, "authorization", HEADER)
      .withQueryParam("continue", continue)
      .withQueryParam("fieldSelector", fieldSelector)
      .withQueryParam("includeUninitialized", includeUninitialized)
      .withQueryParam("labelSelector", labelSelector)
      .withQueryParam("limit", limit)
      .withQueryParam("pretty", pretty)
      .withQueryParam("resourceVersion", resourceVersion)
      .withQueryParam("timeoutSeconds", timeoutSeconds)
      .withQueryParam("watch", watch)
      .withPathParam("name", name)
      .withSuccessResponse[IoK8sApimachineryPkgApisMetaV1WatchEvent](200)
      .withErrorResponse[Unit](401)
        /**
   * watch individual changes to a list of Namespace
   * 
   * Expected answers:
   *   code 200 : IoK8sApimachineryPkgApisMetaV1WatchEvent (OK)
   *   code 401 :  (Unauthorized)
   * 
   * Available security schemes:
   *   BearerToken (apiKey)
   * 
   * @param continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
   * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
   * @param includeUninitialized If true, partially initialized resources are included in the response.
   * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
   * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
   * @param pretty If &#39;true&#39;, then the output is pretty printed.
   * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
   * @param timeoutSeconds Timeout for the list/watch call.
   * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
   */
  def watchCoreV1NamespaceList(continue: Option[String] = None, fieldSelector: Option[String] = None, includeUninitialized: Option[Boolean] = None, labelSelector: Option[String] = None, limit: Option[Int] = None, pretty: Option[String] = None, resourceVersion: Option[String] = None, timeoutSeconds: Option[Int] = None, watch: Option[Boolean] = None)(implicit apiKey: ApiKeyValue): ApiRequest[IoK8sApimachineryPkgApisMetaV1WatchEvent] =
    ApiRequest[IoK8sApimachineryPkgApisMetaV1WatchEvent](ApiMethods.GET, "https://localhost", "/api/v1/watch/namespaces", "*/*")
      .withApiKey(apiKey, "authorization", HEADER)
      .withQueryParam("continue", continue)
      .withQueryParam("fieldSelector", fieldSelector)
      .withQueryParam("includeUninitialized", includeUninitialized)
      .withQueryParam("labelSelector", labelSelector)
      .withQueryParam("limit", limit)
      .withQueryParam("pretty", pretty)
      .withQueryParam("resourceVersion", resourceVersion)
      .withQueryParam("timeoutSeconds", timeoutSeconds)
      .withQueryParam("watch", watch)
      .withSuccessResponse[IoK8sApimachineryPkgApisMetaV1WatchEvent](200)
      .withErrorResponse[Unit](401)
        /**
   * watch changes to an object of kind ConfigMap
   * 
   * Expected answers:
   *   code 200 : IoK8sApimachineryPkgApisMetaV1WatchEvent (OK)
   *   code 401 :  (Unauthorized)
   * 
   * Available security schemes:
   *   BearerToken (apiKey)
   * 
   * @param name name of the ConfigMap
   * @param namespace object name and auth scope, such as for teams and projects
   * @param continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
   * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
   * @param includeUninitialized If true, partially initialized resources are included in the response.
   * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
   * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
   * @param pretty If &#39;true&#39;, then the output is pretty printed.
   * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
   * @param timeoutSeconds Timeout for the list/watch call.
   * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
   */
  def watchCoreV1NamespacedConfigMap(name: String, namespace: String, continue: Option[String] = None, fieldSelector: Option[String] = None, includeUninitialized: Option[Boolean] = None, labelSelector: Option[String] = None, limit: Option[Int] = None, pretty: Option[String] = None, resourceVersion: Option[String] = None, timeoutSeconds: Option[Int] = None, watch: Option[Boolean] = None)(implicit apiKey: ApiKeyValue): ApiRequest[IoK8sApimachineryPkgApisMetaV1WatchEvent] =
    ApiRequest[IoK8sApimachineryPkgApisMetaV1WatchEvent](ApiMethods.GET, "https://localhost", "/api/v1/watch/namespaces/{namespace}/configmaps/{name}", "*/*")
      .withApiKey(apiKey, "authorization", HEADER)
      .withQueryParam("continue", continue)
      .withQueryParam("fieldSelector", fieldSelector)
      .withQueryParam("includeUninitialized", includeUninitialized)
      .withQueryParam("labelSelector", labelSelector)
      .withQueryParam("limit", limit)
      .withQueryParam("pretty", pretty)
      .withQueryParam("resourceVersion", resourceVersion)
      .withQueryParam("timeoutSeconds", timeoutSeconds)
      .withQueryParam("watch", watch)
      .withPathParam("name", name)
      .withPathParam("namespace", namespace)
      .withSuccessResponse[IoK8sApimachineryPkgApisMetaV1WatchEvent](200)
      .withErrorResponse[Unit](401)
        /**
   * watch individual changes to a list of ConfigMap
   * 
   * Expected answers:
   *   code 200 : IoK8sApimachineryPkgApisMetaV1WatchEvent (OK)
   *   code 401 :  (Unauthorized)
   * 
   * Available security schemes:
   *   BearerToken (apiKey)
   * 
   * @param namespace object name and auth scope, such as for teams and projects
   * @param continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
   * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
   * @param includeUninitialized If true, partially initialized resources are included in the response.
   * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
   * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
   * @param pretty If &#39;true&#39;, then the output is pretty printed.
   * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
   * @param timeoutSeconds Timeout for the list/watch call.
   * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
   */
  def watchCoreV1NamespacedConfigMapList(namespace: String, continue: Option[String] = None, fieldSelector: Option[String] = None, includeUninitialized: Option[Boolean] = None, labelSelector: Option[String] = None, limit: Option[Int] = None, pretty: Option[String] = None, resourceVersion: Option[String] = None, timeoutSeconds: Option[Int] = None, watch: Option[Boolean] = None)(implicit apiKey: ApiKeyValue): ApiRequest[IoK8sApimachineryPkgApisMetaV1WatchEvent] =
    ApiRequest[IoK8sApimachineryPkgApisMetaV1WatchEvent](ApiMethods.GET, "https://localhost", "/api/v1/watch/namespaces/{namespace}/configmaps", "*/*")
      .withApiKey(apiKey, "authorization", HEADER)
      .withQueryParam("continue", continue)
      .withQueryParam("fieldSelector", fieldSelector)
      .withQueryParam("includeUninitialized", includeUninitialized)
      .withQueryParam("labelSelector", labelSelector)
      .withQueryParam("limit", limit)
      .withQueryParam("pretty", pretty)
      .withQueryParam("resourceVersion", resourceVersion)
      .withQueryParam("timeoutSeconds", timeoutSeconds)
      .withQueryParam("watch", watch)
      .withPathParam("namespace", namespace)
      .withSuccessResponse[IoK8sApimachineryPkgApisMetaV1WatchEvent](200)
      .withErrorResponse[Unit](401)
        /**
   * watch changes to an object of kind Endpoints
   * 
   * Expected answers:
   *   code 200 : IoK8sApimachineryPkgApisMetaV1WatchEvent (OK)
   *   code 401 :  (Unauthorized)
   * 
   * Available security schemes:
   *   BearerToken (apiKey)
   * 
   * @param name name of the Endpoints
   * @param namespace object name and auth scope, such as for teams and projects
   * @param continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
   * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
   * @param includeUninitialized If true, partially initialized resources are included in the response.
   * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
   * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
   * @param pretty If &#39;true&#39;, then the output is pretty printed.
   * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
   * @param timeoutSeconds Timeout for the list/watch call.
   * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
   */
  def watchCoreV1NamespacedEndpoints(name: String, namespace: String, continue: Option[String] = None, fieldSelector: Option[String] = None, includeUninitialized: Option[Boolean] = None, labelSelector: Option[String] = None, limit: Option[Int] = None, pretty: Option[String] = None, resourceVersion: Option[String] = None, timeoutSeconds: Option[Int] = None, watch: Option[Boolean] = None)(implicit apiKey: ApiKeyValue): ApiRequest[IoK8sApimachineryPkgApisMetaV1WatchEvent] =
    ApiRequest[IoK8sApimachineryPkgApisMetaV1WatchEvent](ApiMethods.GET, "https://localhost", "/api/v1/watch/namespaces/{namespace}/endpoints/{name}", "*/*")
      .withApiKey(apiKey, "authorization", HEADER)
      .withQueryParam("continue", continue)
      .withQueryParam("fieldSelector", fieldSelector)
      .withQueryParam("includeUninitialized", includeUninitialized)
      .withQueryParam("labelSelector", labelSelector)
      .withQueryParam("limit", limit)
      .withQueryParam("pretty", pretty)
      .withQueryParam("resourceVersion", resourceVersion)
      .withQueryParam("timeoutSeconds", timeoutSeconds)
      .withQueryParam("watch", watch)
      .withPathParam("name", name)
      .withPathParam("namespace", namespace)
      .withSuccessResponse[IoK8sApimachineryPkgApisMetaV1WatchEvent](200)
      .withErrorResponse[Unit](401)
        /**
   * watch individual changes to a list of Endpoints
   * 
   * Expected answers:
   *   code 200 : IoK8sApimachineryPkgApisMetaV1WatchEvent (OK)
   *   code 401 :  (Unauthorized)
   * 
   * Available security schemes:
   *   BearerToken (apiKey)
   * 
   * @param namespace object name and auth scope, such as for teams and projects
   * @param continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
   * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
   * @param includeUninitialized If true, partially initialized resources are included in the response.
   * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
   * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
   * @param pretty If &#39;true&#39;, then the output is pretty printed.
   * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
   * @param timeoutSeconds Timeout for the list/watch call.
   * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
   */
  def watchCoreV1NamespacedEndpointsList(namespace: String, continue: Option[String] = None, fieldSelector: Option[String] = None, includeUninitialized: Option[Boolean] = None, labelSelector: Option[String] = None, limit: Option[Int] = None, pretty: Option[String] = None, resourceVersion: Option[String] = None, timeoutSeconds: Option[Int] = None, watch: Option[Boolean] = None)(implicit apiKey: ApiKeyValue): ApiRequest[IoK8sApimachineryPkgApisMetaV1WatchEvent] =
    ApiRequest[IoK8sApimachineryPkgApisMetaV1WatchEvent](ApiMethods.GET, "https://localhost", "/api/v1/watch/namespaces/{namespace}/endpoints", "*/*")
      .withApiKey(apiKey, "authorization", HEADER)
      .withQueryParam("continue", continue)
      .withQueryParam("fieldSelector", fieldSelector)
      .withQueryParam("includeUninitialized", includeUninitialized)
      .withQueryParam("labelSelector", labelSelector)
      .withQueryParam("limit", limit)
      .withQueryParam("pretty", pretty)
      .withQueryParam("resourceVersion", resourceVersion)
      .withQueryParam("timeoutSeconds", timeoutSeconds)
      .withQueryParam("watch", watch)
      .withPathParam("namespace", namespace)
      .withSuccessResponse[IoK8sApimachineryPkgApisMetaV1WatchEvent](200)
      .withErrorResponse[Unit](401)
        /**
   * watch changes to an object of kind Event
   * 
   * Expected answers:
   *   code 200 : IoK8sApimachineryPkgApisMetaV1WatchEvent (OK)
   *   code 401 :  (Unauthorized)
   * 
   * Available security schemes:
   *   BearerToken (apiKey)
   * 
   * @param name name of the Event
   * @param namespace object name and auth scope, such as for teams and projects
   * @param continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
   * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
   * @param includeUninitialized If true, partially initialized resources are included in the response.
   * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
   * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
   * @param pretty If &#39;true&#39;, then the output is pretty printed.
   * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
   * @param timeoutSeconds Timeout for the list/watch call.
   * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
   */
  def watchCoreV1NamespacedEvent(name: String, namespace: String, continue: Option[String] = None, fieldSelector: Option[String] = None, includeUninitialized: Option[Boolean] = None, labelSelector: Option[String] = None, limit: Option[Int] = None, pretty: Option[String] = None, resourceVersion: Option[String] = None, timeoutSeconds: Option[Int] = None, watch: Option[Boolean] = None)(implicit apiKey: ApiKeyValue): ApiRequest[IoK8sApimachineryPkgApisMetaV1WatchEvent] =
    ApiRequest[IoK8sApimachineryPkgApisMetaV1WatchEvent](ApiMethods.GET, "https://localhost", "/api/v1/watch/namespaces/{namespace}/events/{name}", "*/*")
      .withApiKey(apiKey, "authorization", HEADER)
      .withQueryParam("continue", continue)
      .withQueryParam("fieldSelector", fieldSelector)
      .withQueryParam("includeUninitialized", includeUninitialized)
      .withQueryParam("labelSelector", labelSelector)
      .withQueryParam("limit", limit)
      .withQueryParam("pretty", pretty)
      .withQueryParam("resourceVersion", resourceVersion)
      .withQueryParam("timeoutSeconds", timeoutSeconds)
      .withQueryParam("watch", watch)
      .withPathParam("name", name)
      .withPathParam("namespace", namespace)
      .withSuccessResponse[IoK8sApimachineryPkgApisMetaV1WatchEvent](200)
      .withErrorResponse[Unit](401)
        /**
   * watch individual changes to a list of Event
   * 
   * Expected answers:
   *   code 200 : IoK8sApimachineryPkgApisMetaV1WatchEvent (OK)
   *   code 401 :  (Unauthorized)
   * 
   * Available security schemes:
   *   BearerToken (apiKey)
   * 
   * @param namespace object name and auth scope, such as for teams and projects
   * @param continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
   * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
   * @param includeUninitialized If true, partially initialized resources are included in the response.
   * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
   * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
   * @param pretty If &#39;true&#39;, then the output is pretty printed.
   * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
   * @param timeoutSeconds Timeout for the list/watch call.
   * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
   */
  def watchCoreV1NamespacedEventList(namespace: String, continue: Option[String] = None, fieldSelector: Option[String] = None, includeUninitialized: Option[Boolean] = None, labelSelector: Option[String] = None, limit: Option[Int] = None, pretty: Option[String] = None, resourceVersion: Option[String] = None, timeoutSeconds: Option[Int] = None, watch: Option[Boolean] = None)(implicit apiKey: ApiKeyValue): ApiRequest[IoK8sApimachineryPkgApisMetaV1WatchEvent] =
    ApiRequest[IoK8sApimachineryPkgApisMetaV1WatchEvent](ApiMethods.GET, "https://localhost", "/api/v1/watch/namespaces/{namespace}/events", "*/*")
      .withApiKey(apiKey, "authorization", HEADER)
      .withQueryParam("continue", continue)
      .withQueryParam("fieldSelector", fieldSelector)
      .withQueryParam("includeUninitialized", includeUninitialized)
      .withQueryParam("labelSelector", labelSelector)
      .withQueryParam("limit", limit)
      .withQueryParam("pretty", pretty)
      .withQueryParam("resourceVersion", resourceVersion)
      .withQueryParam("timeoutSeconds", timeoutSeconds)
      .withQueryParam("watch", watch)
      .withPathParam("namespace", namespace)
      .withSuccessResponse[IoK8sApimachineryPkgApisMetaV1WatchEvent](200)
      .withErrorResponse[Unit](401)
        /**
   * watch changes to an object of kind LimitRange
   * 
   * Expected answers:
   *   code 200 : IoK8sApimachineryPkgApisMetaV1WatchEvent (OK)
   *   code 401 :  (Unauthorized)
   * 
   * Available security schemes:
   *   BearerToken (apiKey)
   * 
   * @param name name of the LimitRange
   * @param namespace object name and auth scope, such as for teams and projects
   * @param continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
   * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
   * @param includeUninitialized If true, partially initialized resources are included in the response.
   * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
   * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
   * @param pretty If &#39;true&#39;, then the output is pretty printed.
   * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
   * @param timeoutSeconds Timeout for the list/watch call.
   * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
   */
  def watchCoreV1NamespacedLimitRange(name: String, namespace: String, continue: Option[String] = None, fieldSelector: Option[String] = None, includeUninitialized: Option[Boolean] = None, labelSelector: Option[String] = None, limit: Option[Int] = None, pretty: Option[String] = None, resourceVersion: Option[String] = None, timeoutSeconds: Option[Int] = None, watch: Option[Boolean] = None)(implicit apiKey: ApiKeyValue): ApiRequest[IoK8sApimachineryPkgApisMetaV1WatchEvent] =
    ApiRequest[IoK8sApimachineryPkgApisMetaV1WatchEvent](ApiMethods.GET, "https://localhost", "/api/v1/watch/namespaces/{namespace}/limitranges/{name}", "*/*")
      .withApiKey(apiKey, "authorization", HEADER)
      .withQueryParam("continue", continue)
      .withQueryParam("fieldSelector", fieldSelector)
      .withQueryParam("includeUninitialized", includeUninitialized)
      .withQueryParam("labelSelector", labelSelector)
      .withQueryParam("limit", limit)
      .withQueryParam("pretty", pretty)
      .withQueryParam("resourceVersion", resourceVersion)
      .withQueryParam("timeoutSeconds", timeoutSeconds)
      .withQueryParam("watch", watch)
      .withPathParam("name", name)
      .withPathParam("namespace", namespace)
      .withSuccessResponse[IoK8sApimachineryPkgApisMetaV1WatchEvent](200)
      .withErrorResponse[Unit](401)
        /**
   * watch individual changes to a list of LimitRange
   * 
   * Expected answers:
   *   code 200 : IoK8sApimachineryPkgApisMetaV1WatchEvent (OK)
   *   code 401 :  (Unauthorized)
   * 
   * Available security schemes:
   *   BearerToken (apiKey)
   * 
   * @param namespace object name and auth scope, such as for teams and projects
   * @param continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
   * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
   * @param includeUninitialized If true, partially initialized resources are included in the response.
   * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
   * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
   * @param pretty If &#39;true&#39;, then the output is pretty printed.
   * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
   * @param timeoutSeconds Timeout for the list/watch call.
   * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
   */
  def watchCoreV1NamespacedLimitRangeList(namespace: String, continue: Option[String] = None, fieldSelector: Option[String] = None, includeUninitialized: Option[Boolean] = None, labelSelector: Option[String] = None, limit: Option[Int] = None, pretty: Option[String] = None, resourceVersion: Option[String] = None, timeoutSeconds: Option[Int] = None, watch: Option[Boolean] = None)(implicit apiKey: ApiKeyValue): ApiRequest[IoK8sApimachineryPkgApisMetaV1WatchEvent] =
    ApiRequest[IoK8sApimachineryPkgApisMetaV1WatchEvent](ApiMethods.GET, "https://localhost", "/api/v1/watch/namespaces/{namespace}/limitranges", "*/*")
      .withApiKey(apiKey, "authorization", HEADER)
      .withQueryParam("continue", continue)
      .withQueryParam("fieldSelector", fieldSelector)
      .withQueryParam("includeUninitialized", includeUninitialized)
      .withQueryParam("labelSelector", labelSelector)
      .withQueryParam("limit", limit)
      .withQueryParam("pretty", pretty)
      .withQueryParam("resourceVersion", resourceVersion)
      .withQueryParam("timeoutSeconds", timeoutSeconds)
      .withQueryParam("watch", watch)
      .withPathParam("namespace", namespace)
      .withSuccessResponse[IoK8sApimachineryPkgApisMetaV1WatchEvent](200)
      .withErrorResponse[Unit](401)
        /**
   * watch changes to an object of kind PersistentVolumeClaim
   * 
   * Expected answers:
   *   code 200 : IoK8sApimachineryPkgApisMetaV1WatchEvent (OK)
   *   code 401 :  (Unauthorized)
   * 
   * Available security schemes:
   *   BearerToken (apiKey)
   * 
   * @param name name of the PersistentVolumeClaim
   * @param namespace object name and auth scope, such as for teams and projects
   * @param continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
   * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
   * @param includeUninitialized If true, partially initialized resources are included in the response.
   * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
   * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
   * @param pretty If &#39;true&#39;, then the output is pretty printed.
   * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
   * @param timeoutSeconds Timeout for the list/watch call.
   * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
   */
  def watchCoreV1NamespacedPersistentVolumeClaim(name: String, namespace: String, continue: Option[String] = None, fieldSelector: Option[String] = None, includeUninitialized: Option[Boolean] = None, labelSelector: Option[String] = None, limit: Option[Int] = None, pretty: Option[String] = None, resourceVersion: Option[String] = None, timeoutSeconds: Option[Int] = None, watch: Option[Boolean] = None)(implicit apiKey: ApiKeyValue): ApiRequest[IoK8sApimachineryPkgApisMetaV1WatchEvent] =
    ApiRequest[IoK8sApimachineryPkgApisMetaV1WatchEvent](ApiMethods.GET, "https://localhost", "/api/v1/watch/namespaces/{namespace}/persistentvolumeclaims/{name}", "*/*")
      .withApiKey(apiKey, "authorization", HEADER)
      .withQueryParam("continue", continue)
      .withQueryParam("fieldSelector", fieldSelector)
      .withQueryParam("includeUninitialized", includeUninitialized)
      .withQueryParam("labelSelector", labelSelector)
      .withQueryParam("limit", limit)
      .withQueryParam("pretty", pretty)
      .withQueryParam("resourceVersion", resourceVersion)
      .withQueryParam("timeoutSeconds", timeoutSeconds)
      .withQueryParam("watch", watch)
      .withPathParam("name", name)
      .withPathParam("namespace", namespace)
      .withSuccessResponse[IoK8sApimachineryPkgApisMetaV1WatchEvent](200)
      .withErrorResponse[Unit](401)
        /**
   * watch individual changes to a list of PersistentVolumeClaim
   * 
   * Expected answers:
   *   code 200 : IoK8sApimachineryPkgApisMetaV1WatchEvent (OK)
   *   code 401 :  (Unauthorized)
   * 
   * Available security schemes:
   *   BearerToken (apiKey)
   * 
   * @param namespace object name and auth scope, such as for teams and projects
   * @param continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
   * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
   * @param includeUninitialized If true, partially initialized resources are included in the response.
   * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
   * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
   * @param pretty If &#39;true&#39;, then the output is pretty printed.
   * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
   * @param timeoutSeconds Timeout for the list/watch call.
   * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
   */
  def watchCoreV1NamespacedPersistentVolumeClaimList(namespace: String, continue: Option[String] = None, fieldSelector: Option[String] = None, includeUninitialized: Option[Boolean] = None, labelSelector: Option[String] = None, limit: Option[Int] = None, pretty: Option[String] = None, resourceVersion: Option[String] = None, timeoutSeconds: Option[Int] = None, watch: Option[Boolean] = None)(implicit apiKey: ApiKeyValue): ApiRequest[IoK8sApimachineryPkgApisMetaV1WatchEvent] =
    ApiRequest[IoK8sApimachineryPkgApisMetaV1WatchEvent](ApiMethods.GET, "https://localhost", "/api/v1/watch/namespaces/{namespace}/persistentvolumeclaims", "*/*")
      .withApiKey(apiKey, "authorization", HEADER)
      .withQueryParam("continue", continue)
      .withQueryParam("fieldSelector", fieldSelector)
      .withQueryParam("includeUninitialized", includeUninitialized)
      .withQueryParam("labelSelector", labelSelector)
      .withQueryParam("limit", limit)
      .withQueryParam("pretty", pretty)
      .withQueryParam("resourceVersion", resourceVersion)
      .withQueryParam("timeoutSeconds", timeoutSeconds)
      .withQueryParam("watch", watch)
      .withPathParam("namespace", namespace)
      .withSuccessResponse[IoK8sApimachineryPkgApisMetaV1WatchEvent](200)
      .withErrorResponse[Unit](401)
        /**
   * watch changes to an object of kind Pod
   * 
   * Expected answers:
   *   code 200 : IoK8sApimachineryPkgApisMetaV1WatchEvent (OK)
   *   code 401 :  (Unauthorized)
   * 
   * Available security schemes:
   *   BearerToken (apiKey)
   * 
   * @param name name of the Pod
   * @param namespace object name and auth scope, such as for teams and projects
   * @param continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
   * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
   * @param includeUninitialized If true, partially initialized resources are included in the response.
   * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
   * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
   * @param pretty If &#39;true&#39;, then the output is pretty printed.
   * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
   * @param timeoutSeconds Timeout for the list/watch call.
   * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
   */
  def watchCoreV1NamespacedPod(name: String, namespace: String, continue: Option[String] = None, fieldSelector: Option[String] = None, includeUninitialized: Option[Boolean] = None, labelSelector: Option[String] = None, limit: Option[Int] = None, pretty: Option[String] = None, resourceVersion: Option[String] = None, timeoutSeconds: Option[Int] = None, watch: Option[Boolean] = None)(implicit apiKey: ApiKeyValue): ApiRequest[IoK8sApimachineryPkgApisMetaV1WatchEvent] =
    ApiRequest[IoK8sApimachineryPkgApisMetaV1WatchEvent](ApiMethods.GET, "https://localhost", "/api/v1/watch/namespaces/{namespace}/pods/{name}", "*/*")
      .withApiKey(apiKey, "authorization", HEADER)
      .withQueryParam("continue", continue)
      .withQueryParam("fieldSelector", fieldSelector)
      .withQueryParam("includeUninitialized", includeUninitialized)
      .withQueryParam("labelSelector", labelSelector)
      .withQueryParam("limit", limit)
      .withQueryParam("pretty", pretty)
      .withQueryParam("resourceVersion", resourceVersion)
      .withQueryParam("timeoutSeconds", timeoutSeconds)
      .withQueryParam("watch", watch)
      .withPathParam("name", name)
      .withPathParam("namespace", namespace)
      .withSuccessResponse[IoK8sApimachineryPkgApisMetaV1WatchEvent](200)
      .withErrorResponse[Unit](401)
        /**
   * watch individual changes to a list of Pod
   * 
   * Expected answers:
   *   code 200 : IoK8sApimachineryPkgApisMetaV1WatchEvent (OK)
   *   code 401 :  (Unauthorized)
   * 
   * Available security schemes:
   *   BearerToken (apiKey)
   * 
   * @param namespace object name and auth scope, such as for teams and projects
   * @param continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
   * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
   * @param includeUninitialized If true, partially initialized resources are included in the response.
   * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
   * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
   * @param pretty If &#39;true&#39;, then the output is pretty printed.
   * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
   * @param timeoutSeconds Timeout for the list/watch call.
   * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
   */
  def watchCoreV1NamespacedPodList(namespace: String, continue: Option[String] = None, fieldSelector: Option[String] = None, includeUninitialized: Option[Boolean] = None, labelSelector: Option[String] = None, limit: Option[Int] = None, pretty: Option[String] = None, resourceVersion: Option[String] = None, timeoutSeconds: Option[Int] = None, watch: Option[Boolean] = None)(implicit apiKey: ApiKeyValue): ApiRequest[IoK8sApimachineryPkgApisMetaV1WatchEvent] =
    ApiRequest[IoK8sApimachineryPkgApisMetaV1WatchEvent](ApiMethods.GET, "https://localhost", "/api/v1/watch/namespaces/{namespace}/pods", "*/*")
      .withApiKey(apiKey, "authorization", HEADER)
      .withQueryParam("continue", continue)
      .withQueryParam("fieldSelector", fieldSelector)
      .withQueryParam("includeUninitialized", includeUninitialized)
      .withQueryParam("labelSelector", labelSelector)
      .withQueryParam("limit", limit)
      .withQueryParam("pretty", pretty)
      .withQueryParam("resourceVersion", resourceVersion)
      .withQueryParam("timeoutSeconds", timeoutSeconds)
      .withQueryParam("watch", watch)
      .withPathParam("namespace", namespace)
      .withSuccessResponse[IoK8sApimachineryPkgApisMetaV1WatchEvent](200)
      .withErrorResponse[Unit](401)
        /**
   * watch changes to an object of kind PodTemplate
   * 
   * Expected answers:
   *   code 200 : IoK8sApimachineryPkgApisMetaV1WatchEvent (OK)
   *   code 401 :  (Unauthorized)
   * 
   * Available security schemes:
   *   BearerToken (apiKey)
   * 
   * @param name name of the PodTemplate
   * @param namespace object name and auth scope, such as for teams and projects
   * @param continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
   * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
   * @param includeUninitialized If true, partially initialized resources are included in the response.
   * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
   * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
   * @param pretty If &#39;true&#39;, then the output is pretty printed.
   * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
   * @param timeoutSeconds Timeout for the list/watch call.
   * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
   */
  def watchCoreV1NamespacedPodTemplate(name: String, namespace: String, continue: Option[String] = None, fieldSelector: Option[String] = None, includeUninitialized: Option[Boolean] = None, labelSelector: Option[String] = None, limit: Option[Int] = None, pretty: Option[String] = None, resourceVersion: Option[String] = None, timeoutSeconds: Option[Int] = None, watch: Option[Boolean] = None)(implicit apiKey: ApiKeyValue): ApiRequest[IoK8sApimachineryPkgApisMetaV1WatchEvent] =
    ApiRequest[IoK8sApimachineryPkgApisMetaV1WatchEvent](ApiMethods.GET, "https://localhost", "/api/v1/watch/namespaces/{namespace}/podtemplates/{name}", "*/*")
      .withApiKey(apiKey, "authorization", HEADER)
      .withQueryParam("continue", continue)
      .withQueryParam("fieldSelector", fieldSelector)
      .withQueryParam("includeUninitialized", includeUninitialized)
      .withQueryParam("labelSelector", labelSelector)
      .withQueryParam("limit", limit)
      .withQueryParam("pretty", pretty)
      .withQueryParam("resourceVersion", resourceVersion)
      .withQueryParam("timeoutSeconds", timeoutSeconds)
      .withQueryParam("watch", watch)
      .withPathParam("name", name)
      .withPathParam("namespace", namespace)
      .withSuccessResponse[IoK8sApimachineryPkgApisMetaV1WatchEvent](200)
      .withErrorResponse[Unit](401)
        /**
   * watch individual changes to a list of PodTemplate
   * 
   * Expected answers:
   *   code 200 : IoK8sApimachineryPkgApisMetaV1WatchEvent (OK)
   *   code 401 :  (Unauthorized)
   * 
   * Available security schemes:
   *   BearerToken (apiKey)
   * 
   * @param namespace object name and auth scope, such as for teams and projects
   * @param continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
   * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
   * @param includeUninitialized If true, partially initialized resources are included in the response.
   * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
   * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
   * @param pretty If &#39;true&#39;, then the output is pretty printed.
   * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
   * @param timeoutSeconds Timeout for the list/watch call.
   * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
   */
  def watchCoreV1NamespacedPodTemplateList(namespace: String, continue: Option[String] = None, fieldSelector: Option[String] = None, includeUninitialized: Option[Boolean] = None, labelSelector: Option[String] = None, limit: Option[Int] = None, pretty: Option[String] = None, resourceVersion: Option[String] = None, timeoutSeconds: Option[Int] = None, watch: Option[Boolean] = None)(implicit apiKey: ApiKeyValue): ApiRequest[IoK8sApimachineryPkgApisMetaV1WatchEvent] =
    ApiRequest[IoK8sApimachineryPkgApisMetaV1WatchEvent](ApiMethods.GET, "https://localhost", "/api/v1/watch/namespaces/{namespace}/podtemplates", "*/*")
      .withApiKey(apiKey, "authorization", HEADER)
      .withQueryParam("continue", continue)
      .withQueryParam("fieldSelector", fieldSelector)
      .withQueryParam("includeUninitialized", includeUninitialized)
      .withQueryParam("labelSelector", labelSelector)
      .withQueryParam("limit", limit)
      .withQueryParam("pretty", pretty)
      .withQueryParam("resourceVersion", resourceVersion)
      .withQueryParam("timeoutSeconds", timeoutSeconds)
      .withQueryParam("watch", watch)
      .withPathParam("namespace", namespace)
      .withSuccessResponse[IoK8sApimachineryPkgApisMetaV1WatchEvent](200)
      .withErrorResponse[Unit](401)
        /**
   * watch changes to an object of kind ReplicationController
   * 
   * Expected answers:
   *   code 200 : IoK8sApimachineryPkgApisMetaV1WatchEvent (OK)
   *   code 401 :  (Unauthorized)
   * 
   * Available security schemes:
   *   BearerToken (apiKey)
   * 
   * @param name name of the ReplicationController
   * @param namespace object name and auth scope, such as for teams and projects
   * @param continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
   * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
   * @param includeUninitialized If true, partially initialized resources are included in the response.
   * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
   * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
   * @param pretty If &#39;true&#39;, then the output is pretty printed.
   * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
   * @param timeoutSeconds Timeout for the list/watch call.
   * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
   */
  def watchCoreV1NamespacedReplicationController(name: String, namespace: String, continue: Option[String] = None, fieldSelector: Option[String] = None, includeUninitialized: Option[Boolean] = None, labelSelector: Option[String] = None, limit: Option[Int] = None, pretty: Option[String] = None, resourceVersion: Option[String] = None, timeoutSeconds: Option[Int] = None, watch: Option[Boolean] = None)(implicit apiKey: ApiKeyValue): ApiRequest[IoK8sApimachineryPkgApisMetaV1WatchEvent] =
    ApiRequest[IoK8sApimachineryPkgApisMetaV1WatchEvent](ApiMethods.GET, "https://localhost", "/api/v1/watch/namespaces/{namespace}/replicationcontrollers/{name}", "*/*")
      .withApiKey(apiKey, "authorization", HEADER)
      .withQueryParam("continue", continue)
      .withQueryParam("fieldSelector", fieldSelector)
      .withQueryParam("includeUninitialized", includeUninitialized)
      .withQueryParam("labelSelector", labelSelector)
      .withQueryParam("limit", limit)
      .withQueryParam("pretty", pretty)
      .withQueryParam("resourceVersion", resourceVersion)
      .withQueryParam("timeoutSeconds", timeoutSeconds)
      .withQueryParam("watch", watch)
      .withPathParam("name", name)
      .withPathParam("namespace", namespace)
      .withSuccessResponse[IoK8sApimachineryPkgApisMetaV1WatchEvent](200)
      .withErrorResponse[Unit](401)
        /**
   * watch individual changes to a list of ReplicationController
   * 
   * Expected answers:
   *   code 200 : IoK8sApimachineryPkgApisMetaV1WatchEvent (OK)
   *   code 401 :  (Unauthorized)
   * 
   * Available security schemes:
   *   BearerToken (apiKey)
   * 
   * @param namespace object name and auth scope, such as for teams and projects
   * @param continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
   * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
   * @param includeUninitialized If true, partially initialized resources are included in the response.
   * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
   * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
   * @param pretty If &#39;true&#39;, then the output is pretty printed.
   * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
   * @param timeoutSeconds Timeout for the list/watch call.
   * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
   */
  def watchCoreV1NamespacedReplicationControllerList(namespace: String, continue: Option[String] = None, fieldSelector: Option[String] = None, includeUninitialized: Option[Boolean] = None, labelSelector: Option[String] = None, limit: Option[Int] = None, pretty: Option[String] = None, resourceVersion: Option[String] = None, timeoutSeconds: Option[Int] = None, watch: Option[Boolean] = None)(implicit apiKey: ApiKeyValue): ApiRequest[IoK8sApimachineryPkgApisMetaV1WatchEvent] =
    ApiRequest[IoK8sApimachineryPkgApisMetaV1WatchEvent](ApiMethods.GET, "https://localhost", "/api/v1/watch/namespaces/{namespace}/replicationcontrollers", "*/*")
      .withApiKey(apiKey, "authorization", HEADER)
      .withQueryParam("continue", continue)
      .withQueryParam("fieldSelector", fieldSelector)
      .withQueryParam("includeUninitialized", includeUninitialized)
      .withQueryParam("labelSelector", labelSelector)
      .withQueryParam("limit", limit)
      .withQueryParam("pretty", pretty)
      .withQueryParam("resourceVersion", resourceVersion)
      .withQueryParam("timeoutSeconds", timeoutSeconds)
      .withQueryParam("watch", watch)
      .withPathParam("namespace", namespace)
      .withSuccessResponse[IoK8sApimachineryPkgApisMetaV1WatchEvent](200)
      .withErrorResponse[Unit](401)
        /**
   * watch changes to an object of kind ResourceQuota
   * 
   * Expected answers:
   *   code 200 : IoK8sApimachineryPkgApisMetaV1WatchEvent (OK)
   *   code 401 :  (Unauthorized)
   * 
   * Available security schemes:
   *   BearerToken (apiKey)
   * 
   * @param name name of the ResourceQuota
   * @param namespace object name and auth scope, such as for teams and projects
   * @param continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
   * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
   * @param includeUninitialized If true, partially initialized resources are included in the response.
   * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
   * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
   * @param pretty If &#39;true&#39;, then the output is pretty printed.
   * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
   * @param timeoutSeconds Timeout for the list/watch call.
   * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
   */
  def watchCoreV1NamespacedResourceQuota(name: String, namespace: String, continue: Option[String] = None, fieldSelector: Option[String] = None, includeUninitialized: Option[Boolean] = None, labelSelector: Option[String] = None, limit: Option[Int] = None, pretty: Option[String] = None, resourceVersion: Option[String] = None, timeoutSeconds: Option[Int] = None, watch: Option[Boolean] = None)(implicit apiKey: ApiKeyValue): ApiRequest[IoK8sApimachineryPkgApisMetaV1WatchEvent] =
    ApiRequest[IoK8sApimachineryPkgApisMetaV1WatchEvent](ApiMethods.GET, "https://localhost", "/api/v1/watch/namespaces/{namespace}/resourcequotas/{name}", "*/*")
      .withApiKey(apiKey, "authorization", HEADER)
      .withQueryParam("continue", continue)
      .withQueryParam("fieldSelector", fieldSelector)
      .withQueryParam("includeUninitialized", includeUninitialized)
      .withQueryParam("labelSelector", labelSelector)
      .withQueryParam("limit", limit)
      .withQueryParam("pretty", pretty)
      .withQueryParam("resourceVersion", resourceVersion)
      .withQueryParam("timeoutSeconds", timeoutSeconds)
      .withQueryParam("watch", watch)
      .withPathParam("name", name)
      .withPathParam("namespace", namespace)
      .withSuccessResponse[IoK8sApimachineryPkgApisMetaV1WatchEvent](200)
      .withErrorResponse[Unit](401)
        /**
   * watch individual changes to a list of ResourceQuota
   * 
   * Expected answers:
   *   code 200 : IoK8sApimachineryPkgApisMetaV1WatchEvent (OK)
   *   code 401 :  (Unauthorized)
   * 
   * Available security schemes:
   *   BearerToken (apiKey)
   * 
   * @param namespace object name and auth scope, such as for teams and projects
   * @param continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
   * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
   * @param includeUninitialized If true, partially initialized resources are included in the response.
   * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
   * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
   * @param pretty If &#39;true&#39;, then the output is pretty printed.
   * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
   * @param timeoutSeconds Timeout for the list/watch call.
   * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
   */
  def watchCoreV1NamespacedResourceQuotaList(namespace: String, continue: Option[String] = None, fieldSelector: Option[String] = None, includeUninitialized: Option[Boolean] = None, labelSelector: Option[String] = None, limit: Option[Int] = None, pretty: Option[String] = None, resourceVersion: Option[String] = None, timeoutSeconds: Option[Int] = None, watch: Option[Boolean] = None)(implicit apiKey: ApiKeyValue): ApiRequest[IoK8sApimachineryPkgApisMetaV1WatchEvent] =
    ApiRequest[IoK8sApimachineryPkgApisMetaV1WatchEvent](ApiMethods.GET, "https://localhost", "/api/v1/watch/namespaces/{namespace}/resourcequotas", "*/*")
      .withApiKey(apiKey, "authorization", HEADER)
      .withQueryParam("continue", continue)
      .withQueryParam("fieldSelector", fieldSelector)
      .withQueryParam("includeUninitialized", includeUninitialized)
      .withQueryParam("labelSelector", labelSelector)
      .withQueryParam("limit", limit)
      .withQueryParam("pretty", pretty)
      .withQueryParam("resourceVersion", resourceVersion)
      .withQueryParam("timeoutSeconds", timeoutSeconds)
      .withQueryParam("watch", watch)
      .withPathParam("namespace", namespace)
      .withSuccessResponse[IoK8sApimachineryPkgApisMetaV1WatchEvent](200)
      .withErrorResponse[Unit](401)
        /**
   * watch changes to an object of kind Secret
   * 
   * Expected answers:
   *   code 200 : IoK8sApimachineryPkgApisMetaV1WatchEvent (OK)
   *   code 401 :  (Unauthorized)
   * 
   * Available security schemes:
   *   BearerToken (apiKey)
   * 
   * @param name name of the Secret
   * @param namespace object name and auth scope, such as for teams and projects
   * @param continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
   * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
   * @param includeUninitialized If true, partially initialized resources are included in the response.
   * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
   * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
   * @param pretty If &#39;true&#39;, then the output is pretty printed.
   * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
   * @param timeoutSeconds Timeout for the list/watch call.
   * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
   */
  def watchCoreV1NamespacedSecret(name: String, namespace: String, continue: Option[String] = None, fieldSelector: Option[String] = None, includeUninitialized: Option[Boolean] = None, labelSelector: Option[String] = None, limit: Option[Int] = None, pretty: Option[String] = None, resourceVersion: Option[String] = None, timeoutSeconds: Option[Int] = None, watch: Option[Boolean] = None)(implicit apiKey: ApiKeyValue): ApiRequest[IoK8sApimachineryPkgApisMetaV1WatchEvent] =
    ApiRequest[IoK8sApimachineryPkgApisMetaV1WatchEvent](ApiMethods.GET, "https://localhost", "/api/v1/watch/namespaces/{namespace}/secrets/{name}", "*/*")
      .withApiKey(apiKey, "authorization", HEADER)
      .withQueryParam("continue", continue)
      .withQueryParam("fieldSelector", fieldSelector)
      .withQueryParam("includeUninitialized", includeUninitialized)
      .withQueryParam("labelSelector", labelSelector)
      .withQueryParam("limit", limit)
      .withQueryParam("pretty", pretty)
      .withQueryParam("resourceVersion", resourceVersion)
      .withQueryParam("timeoutSeconds", timeoutSeconds)
      .withQueryParam("watch", watch)
      .withPathParam("name", name)
      .withPathParam("namespace", namespace)
      .withSuccessResponse[IoK8sApimachineryPkgApisMetaV1WatchEvent](200)
      .withErrorResponse[Unit](401)
        /**
   * watch individual changes to a list of Secret
   * 
   * Expected answers:
   *   code 200 : IoK8sApimachineryPkgApisMetaV1WatchEvent (OK)
   *   code 401 :  (Unauthorized)
   * 
   * Available security schemes:
   *   BearerToken (apiKey)
   * 
   * @param namespace object name and auth scope, such as for teams and projects
   * @param continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
   * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
   * @param includeUninitialized If true, partially initialized resources are included in the response.
   * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
   * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
   * @param pretty If &#39;true&#39;, then the output is pretty printed.
   * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
   * @param timeoutSeconds Timeout for the list/watch call.
   * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
   */
  def watchCoreV1NamespacedSecretList(namespace: String, continue: Option[String] = None, fieldSelector: Option[String] = None, includeUninitialized: Option[Boolean] = None, labelSelector: Option[String] = None, limit: Option[Int] = None, pretty: Option[String] = None, resourceVersion: Option[String] = None, timeoutSeconds: Option[Int] = None, watch: Option[Boolean] = None)(implicit apiKey: ApiKeyValue): ApiRequest[IoK8sApimachineryPkgApisMetaV1WatchEvent] =
    ApiRequest[IoK8sApimachineryPkgApisMetaV1WatchEvent](ApiMethods.GET, "https://localhost", "/api/v1/watch/namespaces/{namespace}/secrets", "*/*")
      .withApiKey(apiKey, "authorization", HEADER)
      .withQueryParam("continue", continue)
      .withQueryParam("fieldSelector", fieldSelector)
      .withQueryParam("includeUninitialized", includeUninitialized)
      .withQueryParam("labelSelector", labelSelector)
      .withQueryParam("limit", limit)
      .withQueryParam("pretty", pretty)
      .withQueryParam("resourceVersion", resourceVersion)
      .withQueryParam("timeoutSeconds", timeoutSeconds)
      .withQueryParam("watch", watch)
      .withPathParam("namespace", namespace)
      .withSuccessResponse[IoK8sApimachineryPkgApisMetaV1WatchEvent](200)
      .withErrorResponse[Unit](401)
        /**
   * watch changes to an object of kind Service
   * 
   * Expected answers:
   *   code 200 : IoK8sApimachineryPkgApisMetaV1WatchEvent (OK)
   *   code 401 :  (Unauthorized)
   * 
   * Available security schemes:
   *   BearerToken (apiKey)
   * 
   * @param name name of the Service
   * @param namespace object name and auth scope, such as for teams and projects
   * @param continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
   * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
   * @param includeUninitialized If true, partially initialized resources are included in the response.
   * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
   * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
   * @param pretty If &#39;true&#39;, then the output is pretty printed.
   * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
   * @param timeoutSeconds Timeout for the list/watch call.
   * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
   */
  def watchCoreV1NamespacedService(name: String, namespace: String, continue: Option[String] = None, fieldSelector: Option[String] = None, includeUninitialized: Option[Boolean] = None, labelSelector: Option[String] = None, limit: Option[Int] = None, pretty: Option[String] = None, resourceVersion: Option[String] = None, timeoutSeconds: Option[Int] = None, watch: Option[Boolean] = None)(implicit apiKey: ApiKeyValue): ApiRequest[IoK8sApimachineryPkgApisMetaV1WatchEvent] =
    ApiRequest[IoK8sApimachineryPkgApisMetaV1WatchEvent](ApiMethods.GET, "https://localhost", "/api/v1/watch/namespaces/{namespace}/services/{name}", "*/*")
      .withApiKey(apiKey, "authorization", HEADER)
      .withQueryParam("continue", continue)
      .withQueryParam("fieldSelector", fieldSelector)
      .withQueryParam("includeUninitialized", includeUninitialized)
      .withQueryParam("labelSelector", labelSelector)
      .withQueryParam("limit", limit)
      .withQueryParam("pretty", pretty)
      .withQueryParam("resourceVersion", resourceVersion)
      .withQueryParam("timeoutSeconds", timeoutSeconds)
      .withQueryParam("watch", watch)
      .withPathParam("name", name)
      .withPathParam("namespace", namespace)
      .withSuccessResponse[IoK8sApimachineryPkgApisMetaV1WatchEvent](200)
      .withErrorResponse[Unit](401)
        /**
   * watch changes to an object of kind ServiceAccount
   * 
   * Expected answers:
   *   code 200 : IoK8sApimachineryPkgApisMetaV1WatchEvent (OK)
   *   code 401 :  (Unauthorized)
   * 
   * Available security schemes:
   *   BearerToken (apiKey)
   * 
   * @param name name of the ServiceAccount
   * @param namespace object name and auth scope, such as for teams and projects
   * @param continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
   * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
   * @param includeUninitialized If true, partially initialized resources are included in the response.
   * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
   * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
   * @param pretty If &#39;true&#39;, then the output is pretty printed.
   * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
   * @param timeoutSeconds Timeout for the list/watch call.
   * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
   */
  def watchCoreV1NamespacedServiceAccount(name: String, namespace: String, continue: Option[String] = None, fieldSelector: Option[String] = None, includeUninitialized: Option[Boolean] = None, labelSelector: Option[String] = None, limit: Option[Int] = None, pretty: Option[String] = None, resourceVersion: Option[String] = None, timeoutSeconds: Option[Int] = None, watch: Option[Boolean] = None)(implicit apiKey: ApiKeyValue): ApiRequest[IoK8sApimachineryPkgApisMetaV1WatchEvent] =
    ApiRequest[IoK8sApimachineryPkgApisMetaV1WatchEvent](ApiMethods.GET, "https://localhost", "/api/v1/watch/namespaces/{namespace}/serviceaccounts/{name}", "*/*")
      .withApiKey(apiKey, "authorization", HEADER)
      .withQueryParam("continue", continue)
      .withQueryParam("fieldSelector", fieldSelector)
      .withQueryParam("includeUninitialized", includeUninitialized)
      .withQueryParam("labelSelector", labelSelector)
      .withQueryParam("limit", limit)
      .withQueryParam("pretty", pretty)
      .withQueryParam("resourceVersion", resourceVersion)
      .withQueryParam("timeoutSeconds", timeoutSeconds)
      .withQueryParam("watch", watch)
      .withPathParam("name", name)
      .withPathParam("namespace", namespace)
      .withSuccessResponse[IoK8sApimachineryPkgApisMetaV1WatchEvent](200)
      .withErrorResponse[Unit](401)
        /**
   * watch individual changes to a list of ServiceAccount
   * 
   * Expected answers:
   *   code 200 : IoK8sApimachineryPkgApisMetaV1WatchEvent (OK)
   *   code 401 :  (Unauthorized)
   * 
   * Available security schemes:
   *   BearerToken (apiKey)
   * 
   * @param namespace object name and auth scope, such as for teams and projects
   * @param continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
   * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
   * @param includeUninitialized If true, partially initialized resources are included in the response.
   * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
   * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
   * @param pretty If &#39;true&#39;, then the output is pretty printed.
   * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
   * @param timeoutSeconds Timeout for the list/watch call.
   * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
   */
  def watchCoreV1NamespacedServiceAccountList(namespace: String, continue: Option[String] = None, fieldSelector: Option[String] = None, includeUninitialized: Option[Boolean] = None, labelSelector: Option[String] = None, limit: Option[Int] = None, pretty: Option[String] = None, resourceVersion: Option[String] = None, timeoutSeconds: Option[Int] = None, watch: Option[Boolean] = None)(implicit apiKey: ApiKeyValue): ApiRequest[IoK8sApimachineryPkgApisMetaV1WatchEvent] =
    ApiRequest[IoK8sApimachineryPkgApisMetaV1WatchEvent](ApiMethods.GET, "https://localhost", "/api/v1/watch/namespaces/{namespace}/serviceaccounts", "*/*")
      .withApiKey(apiKey, "authorization", HEADER)
      .withQueryParam("continue", continue)
      .withQueryParam("fieldSelector", fieldSelector)
      .withQueryParam("includeUninitialized", includeUninitialized)
      .withQueryParam("labelSelector", labelSelector)
      .withQueryParam("limit", limit)
      .withQueryParam("pretty", pretty)
      .withQueryParam("resourceVersion", resourceVersion)
      .withQueryParam("timeoutSeconds", timeoutSeconds)
      .withQueryParam("watch", watch)
      .withPathParam("namespace", namespace)
      .withSuccessResponse[IoK8sApimachineryPkgApisMetaV1WatchEvent](200)
      .withErrorResponse[Unit](401)
        /**
   * watch individual changes to a list of Service
   * 
   * Expected answers:
   *   code 200 : IoK8sApimachineryPkgApisMetaV1WatchEvent (OK)
   *   code 401 :  (Unauthorized)
   * 
   * Available security schemes:
   *   BearerToken (apiKey)
   * 
   * @param namespace object name and auth scope, such as for teams and projects
   * @param continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
   * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
   * @param includeUninitialized If true, partially initialized resources are included in the response.
   * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
   * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
   * @param pretty If &#39;true&#39;, then the output is pretty printed.
   * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
   * @param timeoutSeconds Timeout for the list/watch call.
   * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
   */
  def watchCoreV1NamespacedServiceList(namespace: String, continue: Option[String] = None, fieldSelector: Option[String] = None, includeUninitialized: Option[Boolean] = None, labelSelector: Option[String] = None, limit: Option[Int] = None, pretty: Option[String] = None, resourceVersion: Option[String] = None, timeoutSeconds: Option[Int] = None, watch: Option[Boolean] = None)(implicit apiKey: ApiKeyValue): ApiRequest[IoK8sApimachineryPkgApisMetaV1WatchEvent] =
    ApiRequest[IoK8sApimachineryPkgApisMetaV1WatchEvent](ApiMethods.GET, "https://localhost", "/api/v1/watch/namespaces/{namespace}/services", "*/*")
      .withApiKey(apiKey, "authorization", HEADER)
      .withQueryParam("continue", continue)
      .withQueryParam("fieldSelector", fieldSelector)
      .withQueryParam("includeUninitialized", includeUninitialized)
      .withQueryParam("labelSelector", labelSelector)
      .withQueryParam("limit", limit)
      .withQueryParam("pretty", pretty)
      .withQueryParam("resourceVersion", resourceVersion)
      .withQueryParam("timeoutSeconds", timeoutSeconds)
      .withQueryParam("watch", watch)
      .withPathParam("namespace", namespace)
      .withSuccessResponse[IoK8sApimachineryPkgApisMetaV1WatchEvent](200)
      .withErrorResponse[Unit](401)
        /**
   * watch changes to an object of kind Node
   * 
   * Expected answers:
   *   code 200 : IoK8sApimachineryPkgApisMetaV1WatchEvent (OK)
   *   code 401 :  (Unauthorized)
   * 
   * Available security schemes:
   *   BearerToken (apiKey)
   * 
   * @param name name of the Node
   * @param continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
   * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
   * @param includeUninitialized If true, partially initialized resources are included in the response.
   * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
   * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
   * @param pretty If &#39;true&#39;, then the output is pretty printed.
   * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
   * @param timeoutSeconds Timeout for the list/watch call.
   * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
   */
  def watchCoreV1Node(name: String, continue: Option[String] = None, fieldSelector: Option[String] = None, includeUninitialized: Option[Boolean] = None, labelSelector: Option[String] = None, limit: Option[Int] = None, pretty: Option[String] = None, resourceVersion: Option[String] = None, timeoutSeconds: Option[Int] = None, watch: Option[Boolean] = None)(implicit apiKey: ApiKeyValue): ApiRequest[IoK8sApimachineryPkgApisMetaV1WatchEvent] =
    ApiRequest[IoK8sApimachineryPkgApisMetaV1WatchEvent](ApiMethods.GET, "https://localhost", "/api/v1/watch/nodes/{name}", "*/*")
      .withApiKey(apiKey, "authorization", HEADER)
      .withQueryParam("continue", continue)
      .withQueryParam("fieldSelector", fieldSelector)
      .withQueryParam("includeUninitialized", includeUninitialized)
      .withQueryParam("labelSelector", labelSelector)
      .withQueryParam("limit", limit)
      .withQueryParam("pretty", pretty)
      .withQueryParam("resourceVersion", resourceVersion)
      .withQueryParam("timeoutSeconds", timeoutSeconds)
      .withQueryParam("watch", watch)
      .withPathParam("name", name)
      .withSuccessResponse[IoK8sApimachineryPkgApisMetaV1WatchEvent](200)
      .withErrorResponse[Unit](401)
        /**
   * watch individual changes to a list of Node
   * 
   * Expected answers:
   *   code 200 : IoK8sApimachineryPkgApisMetaV1WatchEvent (OK)
   *   code 401 :  (Unauthorized)
   * 
   * Available security schemes:
   *   BearerToken (apiKey)
   * 
   * @param continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
   * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
   * @param includeUninitialized If true, partially initialized resources are included in the response.
   * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
   * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
   * @param pretty If &#39;true&#39;, then the output is pretty printed.
   * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
   * @param timeoutSeconds Timeout for the list/watch call.
   * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
   */
  def watchCoreV1NodeList(continue: Option[String] = None, fieldSelector: Option[String] = None, includeUninitialized: Option[Boolean] = None, labelSelector: Option[String] = None, limit: Option[Int] = None, pretty: Option[String] = None, resourceVersion: Option[String] = None, timeoutSeconds: Option[Int] = None, watch: Option[Boolean] = None)(implicit apiKey: ApiKeyValue): ApiRequest[IoK8sApimachineryPkgApisMetaV1WatchEvent] =
    ApiRequest[IoK8sApimachineryPkgApisMetaV1WatchEvent](ApiMethods.GET, "https://localhost", "/api/v1/watch/nodes", "*/*")
      .withApiKey(apiKey, "authorization", HEADER)
      .withQueryParam("continue", continue)
      .withQueryParam("fieldSelector", fieldSelector)
      .withQueryParam("includeUninitialized", includeUninitialized)
      .withQueryParam("labelSelector", labelSelector)
      .withQueryParam("limit", limit)
      .withQueryParam("pretty", pretty)
      .withQueryParam("resourceVersion", resourceVersion)
      .withQueryParam("timeoutSeconds", timeoutSeconds)
      .withQueryParam("watch", watch)
      .withSuccessResponse[IoK8sApimachineryPkgApisMetaV1WatchEvent](200)
      .withErrorResponse[Unit](401)
        /**
   * watch changes to an object of kind PersistentVolume
   * 
   * Expected answers:
   *   code 200 : IoK8sApimachineryPkgApisMetaV1WatchEvent (OK)
   *   code 401 :  (Unauthorized)
   * 
   * Available security schemes:
   *   BearerToken (apiKey)
   * 
   * @param name name of the PersistentVolume
   * @param continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
   * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
   * @param includeUninitialized If true, partially initialized resources are included in the response.
   * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
   * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
   * @param pretty If &#39;true&#39;, then the output is pretty printed.
   * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
   * @param timeoutSeconds Timeout for the list/watch call.
   * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
   */
  def watchCoreV1PersistentVolume(name: String, continue: Option[String] = None, fieldSelector: Option[String] = None, includeUninitialized: Option[Boolean] = None, labelSelector: Option[String] = None, limit: Option[Int] = None, pretty: Option[String] = None, resourceVersion: Option[String] = None, timeoutSeconds: Option[Int] = None, watch: Option[Boolean] = None)(implicit apiKey: ApiKeyValue): ApiRequest[IoK8sApimachineryPkgApisMetaV1WatchEvent] =
    ApiRequest[IoK8sApimachineryPkgApisMetaV1WatchEvent](ApiMethods.GET, "https://localhost", "/api/v1/watch/persistentvolumes/{name}", "*/*")
      .withApiKey(apiKey, "authorization", HEADER)
      .withQueryParam("continue", continue)
      .withQueryParam("fieldSelector", fieldSelector)
      .withQueryParam("includeUninitialized", includeUninitialized)
      .withQueryParam("labelSelector", labelSelector)
      .withQueryParam("limit", limit)
      .withQueryParam("pretty", pretty)
      .withQueryParam("resourceVersion", resourceVersion)
      .withQueryParam("timeoutSeconds", timeoutSeconds)
      .withQueryParam("watch", watch)
      .withPathParam("name", name)
      .withSuccessResponse[IoK8sApimachineryPkgApisMetaV1WatchEvent](200)
      .withErrorResponse[Unit](401)
        /**
   * watch individual changes to a list of PersistentVolumeClaim
   * 
   * Expected answers:
   *   code 200 : IoK8sApimachineryPkgApisMetaV1WatchEvent (OK)
   *   code 401 :  (Unauthorized)
   * 
   * Available security schemes:
   *   BearerToken (apiKey)
   * 
   * @param continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
   * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
   * @param includeUninitialized If true, partially initialized resources are included in the response.
   * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
   * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
   * @param pretty If &#39;true&#39;, then the output is pretty printed.
   * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
   * @param timeoutSeconds Timeout for the list/watch call.
   * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
   */
  def watchCoreV1PersistentVolumeClaimListForAllNamespaces(continue: Option[String] = None, fieldSelector: Option[String] = None, includeUninitialized: Option[Boolean] = None, labelSelector: Option[String] = None, limit: Option[Int] = None, pretty: Option[String] = None, resourceVersion: Option[String] = None, timeoutSeconds: Option[Int] = None, watch: Option[Boolean] = None)(implicit apiKey: ApiKeyValue): ApiRequest[IoK8sApimachineryPkgApisMetaV1WatchEvent] =
    ApiRequest[IoK8sApimachineryPkgApisMetaV1WatchEvent](ApiMethods.GET, "https://localhost", "/api/v1/watch/persistentvolumeclaims", "*/*")
      .withApiKey(apiKey, "authorization", HEADER)
      .withQueryParam("continue", continue)
      .withQueryParam("fieldSelector", fieldSelector)
      .withQueryParam("includeUninitialized", includeUninitialized)
      .withQueryParam("labelSelector", labelSelector)
      .withQueryParam("limit", limit)
      .withQueryParam("pretty", pretty)
      .withQueryParam("resourceVersion", resourceVersion)
      .withQueryParam("timeoutSeconds", timeoutSeconds)
      .withQueryParam("watch", watch)
      .withSuccessResponse[IoK8sApimachineryPkgApisMetaV1WatchEvent](200)
      .withErrorResponse[Unit](401)
        /**
   * watch individual changes to a list of PersistentVolume
   * 
   * Expected answers:
   *   code 200 : IoK8sApimachineryPkgApisMetaV1WatchEvent (OK)
   *   code 401 :  (Unauthorized)
   * 
   * Available security schemes:
   *   BearerToken (apiKey)
   * 
   * @param continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
   * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
   * @param includeUninitialized If true, partially initialized resources are included in the response.
   * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
   * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
   * @param pretty If &#39;true&#39;, then the output is pretty printed.
   * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
   * @param timeoutSeconds Timeout for the list/watch call.
   * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
   */
  def watchCoreV1PersistentVolumeList(continue: Option[String] = None, fieldSelector: Option[String] = None, includeUninitialized: Option[Boolean] = None, labelSelector: Option[String] = None, limit: Option[Int] = None, pretty: Option[String] = None, resourceVersion: Option[String] = None, timeoutSeconds: Option[Int] = None, watch: Option[Boolean] = None)(implicit apiKey: ApiKeyValue): ApiRequest[IoK8sApimachineryPkgApisMetaV1WatchEvent] =
    ApiRequest[IoK8sApimachineryPkgApisMetaV1WatchEvent](ApiMethods.GET, "https://localhost", "/api/v1/watch/persistentvolumes", "*/*")
      .withApiKey(apiKey, "authorization", HEADER)
      .withQueryParam("continue", continue)
      .withQueryParam("fieldSelector", fieldSelector)
      .withQueryParam("includeUninitialized", includeUninitialized)
      .withQueryParam("labelSelector", labelSelector)
      .withQueryParam("limit", limit)
      .withQueryParam("pretty", pretty)
      .withQueryParam("resourceVersion", resourceVersion)
      .withQueryParam("timeoutSeconds", timeoutSeconds)
      .withQueryParam("watch", watch)
      .withSuccessResponse[IoK8sApimachineryPkgApisMetaV1WatchEvent](200)
      .withErrorResponse[Unit](401)
        /**
   * watch individual changes to a list of Pod
   * 
   * Expected answers:
   *   code 200 : IoK8sApimachineryPkgApisMetaV1WatchEvent (OK)
   *   code 401 :  (Unauthorized)
   * 
   * Available security schemes:
   *   BearerToken (apiKey)
   * 
   * @param continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
   * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
   * @param includeUninitialized If true, partially initialized resources are included in the response.
   * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
   * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
   * @param pretty If &#39;true&#39;, then the output is pretty printed.
   * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
   * @param timeoutSeconds Timeout for the list/watch call.
   * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
   */
  def watchCoreV1PodListForAllNamespaces(continue: Option[String] = None, fieldSelector: Option[String] = None, includeUninitialized: Option[Boolean] = None, labelSelector: Option[String] = None, limit: Option[Int] = None, pretty: Option[String] = None, resourceVersion: Option[String] = None, timeoutSeconds: Option[Int] = None, watch: Option[Boolean] = None)(implicit apiKey: ApiKeyValue): ApiRequest[IoK8sApimachineryPkgApisMetaV1WatchEvent] =
    ApiRequest[IoK8sApimachineryPkgApisMetaV1WatchEvent](ApiMethods.GET, "https://localhost", "/api/v1/watch/pods", "*/*")
      .withApiKey(apiKey, "authorization", HEADER)
      .withQueryParam("continue", continue)
      .withQueryParam("fieldSelector", fieldSelector)
      .withQueryParam("includeUninitialized", includeUninitialized)
      .withQueryParam("labelSelector", labelSelector)
      .withQueryParam("limit", limit)
      .withQueryParam("pretty", pretty)
      .withQueryParam("resourceVersion", resourceVersion)
      .withQueryParam("timeoutSeconds", timeoutSeconds)
      .withQueryParam("watch", watch)
      .withSuccessResponse[IoK8sApimachineryPkgApisMetaV1WatchEvent](200)
      .withErrorResponse[Unit](401)
        /**
   * watch individual changes to a list of PodTemplate
   * 
   * Expected answers:
   *   code 200 : IoK8sApimachineryPkgApisMetaV1WatchEvent (OK)
   *   code 401 :  (Unauthorized)
   * 
   * Available security schemes:
   *   BearerToken (apiKey)
   * 
   * @param continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
   * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
   * @param includeUninitialized If true, partially initialized resources are included in the response.
   * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
   * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
   * @param pretty If &#39;true&#39;, then the output is pretty printed.
   * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
   * @param timeoutSeconds Timeout for the list/watch call.
   * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
   */
  def watchCoreV1PodTemplateListForAllNamespaces(continue: Option[String] = None, fieldSelector: Option[String] = None, includeUninitialized: Option[Boolean] = None, labelSelector: Option[String] = None, limit: Option[Int] = None, pretty: Option[String] = None, resourceVersion: Option[String] = None, timeoutSeconds: Option[Int] = None, watch: Option[Boolean] = None)(implicit apiKey: ApiKeyValue): ApiRequest[IoK8sApimachineryPkgApisMetaV1WatchEvent] =
    ApiRequest[IoK8sApimachineryPkgApisMetaV1WatchEvent](ApiMethods.GET, "https://localhost", "/api/v1/watch/podtemplates", "*/*")
      .withApiKey(apiKey, "authorization", HEADER)
      .withQueryParam("continue", continue)
      .withQueryParam("fieldSelector", fieldSelector)
      .withQueryParam("includeUninitialized", includeUninitialized)
      .withQueryParam("labelSelector", labelSelector)
      .withQueryParam("limit", limit)
      .withQueryParam("pretty", pretty)
      .withQueryParam("resourceVersion", resourceVersion)
      .withQueryParam("timeoutSeconds", timeoutSeconds)
      .withQueryParam("watch", watch)
      .withSuccessResponse[IoK8sApimachineryPkgApisMetaV1WatchEvent](200)
      .withErrorResponse[Unit](401)
        /**
   * watch individual changes to a list of ReplicationController
   * 
   * Expected answers:
   *   code 200 : IoK8sApimachineryPkgApisMetaV1WatchEvent (OK)
   *   code 401 :  (Unauthorized)
   * 
   * Available security schemes:
   *   BearerToken (apiKey)
   * 
   * @param continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
   * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
   * @param includeUninitialized If true, partially initialized resources are included in the response.
   * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
   * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
   * @param pretty If &#39;true&#39;, then the output is pretty printed.
   * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
   * @param timeoutSeconds Timeout for the list/watch call.
   * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
   */
  def watchCoreV1ReplicationControllerListForAllNamespaces(continue: Option[String] = None, fieldSelector: Option[String] = None, includeUninitialized: Option[Boolean] = None, labelSelector: Option[String] = None, limit: Option[Int] = None, pretty: Option[String] = None, resourceVersion: Option[String] = None, timeoutSeconds: Option[Int] = None, watch: Option[Boolean] = None)(implicit apiKey: ApiKeyValue): ApiRequest[IoK8sApimachineryPkgApisMetaV1WatchEvent] =
    ApiRequest[IoK8sApimachineryPkgApisMetaV1WatchEvent](ApiMethods.GET, "https://localhost", "/api/v1/watch/replicationcontrollers", "*/*")
      .withApiKey(apiKey, "authorization", HEADER)
      .withQueryParam("continue", continue)
      .withQueryParam("fieldSelector", fieldSelector)
      .withQueryParam("includeUninitialized", includeUninitialized)
      .withQueryParam("labelSelector", labelSelector)
      .withQueryParam("limit", limit)
      .withQueryParam("pretty", pretty)
      .withQueryParam("resourceVersion", resourceVersion)
      .withQueryParam("timeoutSeconds", timeoutSeconds)
      .withQueryParam("watch", watch)
      .withSuccessResponse[IoK8sApimachineryPkgApisMetaV1WatchEvent](200)
      .withErrorResponse[Unit](401)
        /**
   * watch individual changes to a list of ResourceQuota
   * 
   * Expected answers:
   *   code 200 : IoK8sApimachineryPkgApisMetaV1WatchEvent (OK)
   *   code 401 :  (Unauthorized)
   * 
   * Available security schemes:
   *   BearerToken (apiKey)
   * 
   * @param continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
   * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
   * @param includeUninitialized If true, partially initialized resources are included in the response.
   * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
   * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
   * @param pretty If &#39;true&#39;, then the output is pretty printed.
   * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
   * @param timeoutSeconds Timeout for the list/watch call.
   * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
   */
  def watchCoreV1ResourceQuotaListForAllNamespaces(continue: Option[String] = None, fieldSelector: Option[String] = None, includeUninitialized: Option[Boolean] = None, labelSelector: Option[String] = None, limit: Option[Int] = None, pretty: Option[String] = None, resourceVersion: Option[String] = None, timeoutSeconds: Option[Int] = None, watch: Option[Boolean] = None)(implicit apiKey: ApiKeyValue): ApiRequest[IoK8sApimachineryPkgApisMetaV1WatchEvent] =
    ApiRequest[IoK8sApimachineryPkgApisMetaV1WatchEvent](ApiMethods.GET, "https://localhost", "/api/v1/watch/resourcequotas", "*/*")
      .withApiKey(apiKey, "authorization", HEADER)
      .withQueryParam("continue", continue)
      .withQueryParam("fieldSelector", fieldSelector)
      .withQueryParam("includeUninitialized", includeUninitialized)
      .withQueryParam("labelSelector", labelSelector)
      .withQueryParam("limit", limit)
      .withQueryParam("pretty", pretty)
      .withQueryParam("resourceVersion", resourceVersion)
      .withQueryParam("timeoutSeconds", timeoutSeconds)
      .withQueryParam("watch", watch)
      .withSuccessResponse[IoK8sApimachineryPkgApisMetaV1WatchEvent](200)
      .withErrorResponse[Unit](401)
        /**
   * watch individual changes to a list of Secret
   * 
   * Expected answers:
   *   code 200 : IoK8sApimachineryPkgApisMetaV1WatchEvent (OK)
   *   code 401 :  (Unauthorized)
   * 
   * Available security schemes:
   *   BearerToken (apiKey)
   * 
   * @param continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
   * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
   * @param includeUninitialized If true, partially initialized resources are included in the response.
   * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
   * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
   * @param pretty If &#39;true&#39;, then the output is pretty printed.
   * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
   * @param timeoutSeconds Timeout for the list/watch call.
   * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
   */
  def watchCoreV1SecretListForAllNamespaces(continue: Option[String] = None, fieldSelector: Option[String] = None, includeUninitialized: Option[Boolean] = None, labelSelector: Option[String] = None, limit: Option[Int] = None, pretty: Option[String] = None, resourceVersion: Option[String] = None, timeoutSeconds: Option[Int] = None, watch: Option[Boolean] = None)(implicit apiKey: ApiKeyValue): ApiRequest[IoK8sApimachineryPkgApisMetaV1WatchEvent] =
    ApiRequest[IoK8sApimachineryPkgApisMetaV1WatchEvent](ApiMethods.GET, "https://localhost", "/api/v1/watch/secrets", "*/*")
      .withApiKey(apiKey, "authorization", HEADER)
      .withQueryParam("continue", continue)
      .withQueryParam("fieldSelector", fieldSelector)
      .withQueryParam("includeUninitialized", includeUninitialized)
      .withQueryParam("labelSelector", labelSelector)
      .withQueryParam("limit", limit)
      .withQueryParam("pretty", pretty)
      .withQueryParam("resourceVersion", resourceVersion)
      .withQueryParam("timeoutSeconds", timeoutSeconds)
      .withQueryParam("watch", watch)
      .withSuccessResponse[IoK8sApimachineryPkgApisMetaV1WatchEvent](200)
      .withErrorResponse[Unit](401)
        /**
   * watch individual changes to a list of ServiceAccount
   * 
   * Expected answers:
   *   code 200 : IoK8sApimachineryPkgApisMetaV1WatchEvent (OK)
   *   code 401 :  (Unauthorized)
   * 
   * Available security schemes:
   *   BearerToken (apiKey)
   * 
   * @param continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
   * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
   * @param includeUninitialized If true, partially initialized resources are included in the response.
   * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
   * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
   * @param pretty If &#39;true&#39;, then the output is pretty printed.
   * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
   * @param timeoutSeconds Timeout for the list/watch call.
   * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
   */
  def watchCoreV1ServiceAccountListForAllNamespaces(continue: Option[String] = None, fieldSelector: Option[String] = None, includeUninitialized: Option[Boolean] = None, labelSelector: Option[String] = None, limit: Option[Int] = None, pretty: Option[String] = None, resourceVersion: Option[String] = None, timeoutSeconds: Option[Int] = None, watch: Option[Boolean] = None)(implicit apiKey: ApiKeyValue): ApiRequest[IoK8sApimachineryPkgApisMetaV1WatchEvent] =
    ApiRequest[IoK8sApimachineryPkgApisMetaV1WatchEvent](ApiMethods.GET, "https://localhost", "/api/v1/watch/serviceaccounts", "*/*")
      .withApiKey(apiKey, "authorization", HEADER)
      .withQueryParam("continue", continue)
      .withQueryParam("fieldSelector", fieldSelector)
      .withQueryParam("includeUninitialized", includeUninitialized)
      .withQueryParam("labelSelector", labelSelector)
      .withQueryParam("limit", limit)
      .withQueryParam("pretty", pretty)
      .withQueryParam("resourceVersion", resourceVersion)
      .withQueryParam("timeoutSeconds", timeoutSeconds)
      .withQueryParam("watch", watch)
      .withSuccessResponse[IoK8sApimachineryPkgApisMetaV1WatchEvent](200)
      .withErrorResponse[Unit](401)
        /**
   * watch individual changes to a list of Service
   * 
   * Expected answers:
   *   code 200 : IoK8sApimachineryPkgApisMetaV1WatchEvent (OK)
   *   code 401 :  (Unauthorized)
   * 
   * Available security schemes:
   *   BearerToken (apiKey)
   * 
   * @param continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
   * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
   * @param includeUninitialized If true, partially initialized resources are included in the response.
   * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
   * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
   * @param pretty If &#39;true&#39;, then the output is pretty printed.
   * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
   * @param timeoutSeconds Timeout for the list/watch call.
   * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
   */
  def watchCoreV1ServiceListForAllNamespaces(continue: Option[String] = None, fieldSelector: Option[String] = None, includeUninitialized: Option[Boolean] = None, labelSelector: Option[String] = None, limit: Option[Int] = None, pretty: Option[String] = None, resourceVersion: Option[String] = None, timeoutSeconds: Option[Int] = None, watch: Option[Boolean] = None)(implicit apiKey: ApiKeyValue): ApiRequest[IoK8sApimachineryPkgApisMetaV1WatchEvent] =
    ApiRequest[IoK8sApimachineryPkgApisMetaV1WatchEvent](ApiMethods.GET, "https://localhost", "/api/v1/watch/services", "*/*")
      .withApiKey(apiKey, "authorization", HEADER)
      .withQueryParam("continue", continue)
      .withQueryParam("fieldSelector", fieldSelector)
      .withQueryParam("includeUninitialized", includeUninitialized)
      .withQueryParam("labelSelector", labelSelector)
      .withQueryParam("limit", limit)
      .withQueryParam("pretty", pretty)
      .withQueryParam("resourceVersion", resourceVersion)
      .withQueryParam("timeoutSeconds", timeoutSeconds)
      .withQueryParam("watch", watch)
      .withSuccessResponse[IoK8sApimachineryPkgApisMetaV1WatchEvent](200)
      .withErrorResponse[Unit](401)
      

}


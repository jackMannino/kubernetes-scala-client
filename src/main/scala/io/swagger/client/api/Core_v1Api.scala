/**
 * Kubernetes
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: v1.9.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

package io.swagger.client.api

import io.swagger.client.model.IoK8sApiAutoscalingV1Scale
import io.swagger.client.model.IoK8sApiCoreV1Binding
import io.swagger.client.model.IoK8sApiCoreV1ComponentStatus
import io.swagger.client.model.IoK8sApiCoreV1ComponentStatusList
import io.swagger.client.model.IoK8sApiCoreV1ConfigMap
import io.swagger.client.model.IoK8sApiCoreV1ConfigMapList
import io.swagger.client.model.IoK8sApiCoreV1Endpoints
import io.swagger.client.model.IoK8sApiCoreV1EndpointsList
import io.swagger.client.model.IoK8sApiCoreV1Event
import io.swagger.client.model.IoK8sApiCoreV1EventList
import io.swagger.client.model.IoK8sApiCoreV1LimitRange
import io.swagger.client.model.IoK8sApiCoreV1LimitRangeList
import io.swagger.client.model.IoK8sApiCoreV1Namespace
import io.swagger.client.model.IoK8sApiCoreV1NamespaceList
import io.swagger.client.model.IoK8sApiCoreV1Node
import io.swagger.client.model.IoK8sApiCoreV1NodeList
import io.swagger.client.model.IoK8sApiCoreV1PersistentVolume
import io.swagger.client.model.IoK8sApiCoreV1PersistentVolumeClaim
import io.swagger.client.model.IoK8sApiCoreV1PersistentVolumeClaimList
import io.swagger.client.model.IoK8sApiCoreV1PersistentVolumeList
import io.swagger.client.model.IoK8sApiCoreV1Pod
import io.swagger.client.model.IoK8sApiCoreV1PodList
import io.swagger.client.model.IoK8sApiCoreV1PodTemplate
import io.swagger.client.model.IoK8sApiCoreV1PodTemplateList
import io.swagger.client.model.IoK8sApiCoreV1ReplicationController
import io.swagger.client.model.IoK8sApiCoreV1ReplicationControllerList
import io.swagger.client.model.IoK8sApiCoreV1ResourceQuota
import io.swagger.client.model.IoK8sApiCoreV1ResourceQuotaList
import io.swagger.client.model.IoK8sApiCoreV1Secret
import io.swagger.client.model.IoK8sApiCoreV1SecretList
import io.swagger.client.model.IoK8sApiCoreV1Service
import io.swagger.client.model.IoK8sApiCoreV1ServiceAccount
import io.swagger.client.model.IoK8sApiCoreV1ServiceAccountList
import io.swagger.client.model.IoK8sApiCoreV1ServiceList
import io.swagger.client.model.IoK8sApiPolicyV1beta1Eviction
import io.swagger.client.model.IoK8sApimachineryPkgApisMetaV1APIResourceList
import io.swagger.client.model.IoK8sApimachineryPkgApisMetaV1DeleteOptions
import io.swagger.client.model.IoK8sApimachineryPkgApisMetaV1Status
import io.swagger.client.model.IoK8sApimachineryPkgApisMetaV1WatchEvent
import io.swagger.client.ApiInvoker
import io.swagger.client.ApiException

import com.sun.jersey.multipart.FormDataMultiPart
import com.sun.jersey.multipart.file.FileDataBodyPart

import javax.ws.rs.core.MediaType

import java.io.File
import java.util.Date

import scala.collection.mutable.HashMap

class Core_v1Api(val defBasePath: String = "https://localhost",
                        defApiInvoker: ApiInvoker = ApiInvoker) {
  var basePath = defBasePath
  var apiInvoker = defApiInvoker

  def addHeader(key: String, value: String) = apiInvoker.defaultHeaders += key -> value 

  /**
   * 
   * connect DELETE requests to proxy of Pod
   * @param name name of the Pod 
   * @param namespace object name and auth scope, such as for teams and projects 
   * @param _path Path is the URL path to use for the current proxy request to pod. (optional)
   * @return String
   */
  def connectCoreV1DeleteNamespacedPodProxy(name: String, namespace: String, _path: Option[String] = None): Option[String] = {
    // create path and map variables
    val path = "/api/v1/namespaces/{namespace}/pods/{name}/proxy".replaceAll("\\{format\\}", "json").replaceAll("\\{" + "name" + "\\}",apiInvoker.escape(name)).replaceAll("\\{" + "namespace" + "\\}",apiInvoker.escape(namespace))

    val contentTypes = List("*/*")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (name == null) throw new Exception("Missing required parameter 'name' when calling Core_v1Api->connectCoreV1DeleteNamespacedPodProxy")

    if (namespace == null) throw new Exception("Missing required parameter 'namespace' when calling Core_v1Api->connectCoreV1DeleteNamespacedPodProxy")

    _path.map(paramVal => queryParams += "path" -> paramVal.toString)
    

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "DELETE", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "", classOf[String]).asInstanceOf[String])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * 
   * connect DELETE requests to proxy of Pod
   * @param name name of the Pod 
   * @param namespace object name and auth scope, such as for teams and projects 
   * @param _path path to the resource 
   * @param _path2 Path is the URL path to use for the current proxy request to pod. (optional)
   * @return String
   */
  def connectCoreV1DeleteNamespacedPodProxyWithPath(name: String, namespace: String, _path: String, _path2: Option[String] = None): Option[String] = {
    // create path and map variables
    val path = "/api/v1/namespaces/{namespace}/pods/{name}/proxy/{path}".replaceAll("\\{format\\}", "json").replaceAll("\\{" + "name" + "\\}",apiInvoker.escape(name)).replaceAll("\\{" + "namespace" + "\\}",apiInvoker.escape(namespace)).replaceAll("\\{" + "path" + "\\}",apiInvoker.escape(_path))

    val contentTypes = List("*/*")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (name == null) throw new Exception("Missing required parameter 'name' when calling Core_v1Api->connectCoreV1DeleteNamespacedPodProxyWithPath")

    if (namespace == null) throw new Exception("Missing required parameter 'namespace' when calling Core_v1Api->connectCoreV1DeleteNamespacedPodProxyWithPath")

    if (_path == null) throw new Exception("Missing required parameter '_path' when calling Core_v1Api->connectCoreV1DeleteNamespacedPodProxyWithPath")

    _path2.map(paramVal => queryParams += "path" -> paramVal.toString)
    

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "DELETE", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "", classOf[String]).asInstanceOf[String])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * 
   * connect DELETE requests to proxy of Service
   * @param name name of the Service 
   * @param namespace object name and auth scope, such as for teams and projects 
   * @param _path Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q&#x3D;user:kimchy. Path is _search?q&#x3D;user:kimchy. (optional)
   * @return String
   */
  def connectCoreV1DeleteNamespacedServiceProxy(name: String, namespace: String, _path: Option[String] = None): Option[String] = {
    // create path and map variables
    val path = "/api/v1/namespaces/{namespace}/services/{name}/proxy".replaceAll("\\{format\\}", "json").replaceAll("\\{" + "name" + "\\}",apiInvoker.escape(name)).replaceAll("\\{" + "namespace" + "\\}",apiInvoker.escape(namespace))

    val contentTypes = List("*/*")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (name == null) throw new Exception("Missing required parameter 'name' when calling Core_v1Api->connectCoreV1DeleteNamespacedServiceProxy")

    if (namespace == null) throw new Exception("Missing required parameter 'namespace' when calling Core_v1Api->connectCoreV1DeleteNamespacedServiceProxy")

    _path.map(paramVal => queryParams += "path" -> paramVal.toString)
    

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "DELETE", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "", classOf[String]).asInstanceOf[String])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * 
   * connect DELETE requests to proxy of Service
   * @param name name of the Service 
   * @param namespace object name and auth scope, such as for teams and projects 
   * @param _path path to the resource 
   * @param _path2 Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q&#x3D;user:kimchy. Path is _search?q&#x3D;user:kimchy. (optional)
   * @return String
   */
  def connectCoreV1DeleteNamespacedServiceProxyWithPath(name: String, namespace: String, _path: String, _path2: Option[String] = None): Option[String] = {
    // create path and map variables
    val path = "/api/v1/namespaces/{namespace}/services/{name}/proxy/{path}".replaceAll("\\{format\\}", "json").replaceAll("\\{" + "name" + "\\}",apiInvoker.escape(name)).replaceAll("\\{" + "namespace" + "\\}",apiInvoker.escape(namespace)).replaceAll("\\{" + "path" + "\\}",apiInvoker.escape(_path))

    val contentTypes = List("*/*")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (name == null) throw new Exception("Missing required parameter 'name' when calling Core_v1Api->connectCoreV1DeleteNamespacedServiceProxyWithPath")

    if (namespace == null) throw new Exception("Missing required parameter 'namespace' when calling Core_v1Api->connectCoreV1DeleteNamespacedServiceProxyWithPath")

    if (_path == null) throw new Exception("Missing required parameter '_path' when calling Core_v1Api->connectCoreV1DeleteNamespacedServiceProxyWithPath")

    _path2.map(paramVal => queryParams += "path" -> paramVal.toString)
    

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "DELETE", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "", classOf[String]).asInstanceOf[String])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * 
   * connect DELETE requests to proxy of Node
   * @param name name of the Node 
   * @param _path Path is the URL path to use for the current proxy request to node. (optional)
   * @return String
   */
  def connectCoreV1DeleteNodeProxy(name: String, _path: Option[String] = None): Option[String] = {
    // create path and map variables
    val path = "/api/v1/nodes/{name}/proxy".replaceAll("\\{format\\}", "json").replaceAll("\\{" + "name" + "\\}",apiInvoker.escape(name))

    val contentTypes = List("*/*")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (name == null) throw new Exception("Missing required parameter 'name' when calling Core_v1Api->connectCoreV1DeleteNodeProxy")

    _path.map(paramVal => queryParams += "path" -> paramVal.toString)
    

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "DELETE", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "", classOf[String]).asInstanceOf[String])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * 
   * connect DELETE requests to proxy of Node
   * @param name name of the Node 
   * @param _path path to the resource 
   * @param _path2 Path is the URL path to use for the current proxy request to node. (optional)
   * @return String
   */
  def connectCoreV1DeleteNodeProxyWithPath(name: String, _path: String, _path2: Option[String] = None): Option[String] = {
    // create path and map variables
    val path = "/api/v1/nodes/{name}/proxy/{path}".replaceAll("\\{format\\}", "json").replaceAll("\\{" + "name" + "\\}",apiInvoker.escape(name)).replaceAll("\\{" + "path" + "\\}",apiInvoker.escape(_path))

    val contentTypes = List("*/*")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (name == null) throw new Exception("Missing required parameter 'name' when calling Core_v1Api->connectCoreV1DeleteNodeProxyWithPath")

    if (_path == null) throw new Exception("Missing required parameter '_path' when calling Core_v1Api->connectCoreV1DeleteNodeProxyWithPath")

    _path2.map(paramVal => queryParams += "path" -> paramVal.toString)
    

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "DELETE", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "", classOf[String]).asInstanceOf[String])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * 
   * connect GET requests to attach of Pod
   * @param name name of the Pod 
   * @param namespace object name and auth scope, such as for teams and projects 
   * @param container The container in which to execute the command. Defaults to only container if there is only one container in the pod. (optional)
   * @param stderr Stderr if true indicates that stderr is to be redirected for the attach call. Defaults to true. (optional)
   * @param stdin Stdin if true, redirects the standard input stream of the pod for this call. Defaults to false. (optional)
   * @param stdout Stdout if true indicates that stdout is to be redirected for the attach call. Defaults to true. (optional)
   * @param tty TTY if true indicates that a tty will be allocated for the attach call. This is passed through the container runtime so the tty is allocated on the worker node by the container runtime. Defaults to false. (optional)
   * @return String
   */
  def connectCoreV1GetNamespacedPodAttach(name: String, namespace: String, container: Option[String] = None, stderr: Option[Boolean] = None, stdin: Option[Boolean] = None, stdout: Option[Boolean] = None, tty: Option[Boolean] = None): Option[String] = {
    // create path and map variables
    val path = "/api/v1/namespaces/{namespace}/pods/{name}/attach".replaceAll("\\{format\\}", "json").replaceAll("\\{" + "name" + "\\}",apiInvoker.escape(name)).replaceAll("\\{" + "namespace" + "\\}",apiInvoker.escape(namespace))

    val contentTypes = List("*/*")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (name == null) throw new Exception("Missing required parameter 'name' when calling Core_v1Api->connectCoreV1GetNamespacedPodAttach")

    if (namespace == null) throw new Exception("Missing required parameter 'namespace' when calling Core_v1Api->connectCoreV1GetNamespacedPodAttach")

    container.map(paramVal => queryParams += "container" -> paramVal.toString)
    stderr.map(paramVal => queryParams += "stderr" -> paramVal.toString)
    stdin.map(paramVal => queryParams += "stdin" -> paramVal.toString)
    stdout.map(paramVal => queryParams += "stdout" -> paramVal.toString)
    tty.map(paramVal => queryParams += "tty" -> paramVal.toString)
    

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "GET", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "", classOf[String]).asInstanceOf[String])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * 
   * connect GET requests to exec of Pod
   * @param name name of the Pod 
   * @param namespace object name and auth scope, such as for teams and projects 
   * @param command Command is the remote command to execute. argv array. Not executed within a shell. (optional)
   * @param container Container in which to execute the command. Defaults to only container if there is only one container in the pod. (optional)
   * @param stderr Redirect the standard error stream of the pod for this call. Defaults to true. (optional)
   * @param stdin Redirect the standard input stream of the pod for this call. Defaults to false. (optional)
   * @param stdout Redirect the standard output stream of the pod for this call. Defaults to true. (optional)
   * @param tty TTY if true indicates that a tty will be allocated for the exec call. Defaults to false. (optional)
   * @return String
   */
  def connectCoreV1GetNamespacedPodExec(name: String, namespace: String, command: Option[String] = None, container: Option[String] = None, stderr: Option[Boolean] = None, stdin: Option[Boolean] = None, stdout: Option[Boolean] = None, tty: Option[Boolean] = None): Option[String] = {
    // create path and map variables
    val path = "/api/v1/namespaces/{namespace}/pods/{name}/exec".replaceAll("\\{format\\}", "json").replaceAll("\\{" + "name" + "\\}",apiInvoker.escape(name)).replaceAll("\\{" + "namespace" + "\\}",apiInvoker.escape(namespace))

    val contentTypes = List("*/*")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (name == null) throw new Exception("Missing required parameter 'name' when calling Core_v1Api->connectCoreV1GetNamespacedPodExec")

    if (namespace == null) throw new Exception("Missing required parameter 'namespace' when calling Core_v1Api->connectCoreV1GetNamespacedPodExec")

    command.map(paramVal => queryParams += "command" -> paramVal.toString)
    container.map(paramVal => queryParams += "container" -> paramVal.toString)
    stderr.map(paramVal => queryParams += "stderr" -> paramVal.toString)
    stdin.map(paramVal => queryParams += "stdin" -> paramVal.toString)
    stdout.map(paramVal => queryParams += "stdout" -> paramVal.toString)
    tty.map(paramVal => queryParams += "tty" -> paramVal.toString)
    

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "GET", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "", classOf[String]).asInstanceOf[String])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * 
   * connect GET requests to portforward of Pod
   * @param name name of the Pod 
   * @param namespace object name and auth scope, such as for teams and projects 
   * @param ports List of ports to forward Required when using WebSockets (optional)
   * @return String
   */
  def connectCoreV1GetNamespacedPodPortforward(name: String, namespace: String, ports: Option[Integer] = None): Option[String] = {
    // create path and map variables
    val path = "/api/v1/namespaces/{namespace}/pods/{name}/portforward".replaceAll("\\{format\\}", "json").replaceAll("\\{" + "name" + "\\}",apiInvoker.escape(name)).replaceAll("\\{" + "namespace" + "\\}",apiInvoker.escape(namespace))

    val contentTypes = List("*/*")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (name == null) throw new Exception("Missing required parameter 'name' when calling Core_v1Api->connectCoreV1GetNamespacedPodPortforward")

    if (namespace == null) throw new Exception("Missing required parameter 'namespace' when calling Core_v1Api->connectCoreV1GetNamespacedPodPortforward")

    ports.map(paramVal => queryParams += "ports" -> paramVal.toString)
    

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "GET", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "", classOf[String]).asInstanceOf[String])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * 
   * connect GET requests to proxy of Pod
   * @param name name of the Pod 
   * @param namespace object name and auth scope, such as for teams and projects 
   * @param _path Path is the URL path to use for the current proxy request to pod. (optional)
   * @return String
   */
  def connectCoreV1GetNamespacedPodProxy(name: String, namespace: String, _path: Option[String] = None): Option[String] = {
    // create path and map variables
    val path = "/api/v1/namespaces/{namespace}/pods/{name}/proxy".replaceAll("\\{format\\}", "json").replaceAll("\\{" + "name" + "\\}",apiInvoker.escape(name)).replaceAll("\\{" + "namespace" + "\\}",apiInvoker.escape(namespace))

    val contentTypes = List("*/*")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (name == null) throw new Exception("Missing required parameter 'name' when calling Core_v1Api->connectCoreV1GetNamespacedPodProxy")

    if (namespace == null) throw new Exception("Missing required parameter 'namespace' when calling Core_v1Api->connectCoreV1GetNamespacedPodProxy")

    _path.map(paramVal => queryParams += "path" -> paramVal.toString)
    

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "GET", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "", classOf[String]).asInstanceOf[String])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * 
   * connect GET requests to proxy of Pod
   * @param name name of the Pod 
   * @param namespace object name and auth scope, such as for teams and projects 
   * @param _path path to the resource 
   * @param _path2 Path is the URL path to use for the current proxy request to pod. (optional)
   * @return String
   */
  def connectCoreV1GetNamespacedPodProxyWithPath(name: String, namespace: String, _path: String, _path2: Option[String] = None): Option[String] = {
    // create path and map variables
    val path = "/api/v1/namespaces/{namespace}/pods/{name}/proxy/{path}".replaceAll("\\{format\\}", "json").replaceAll("\\{" + "name" + "\\}",apiInvoker.escape(name)).replaceAll("\\{" + "namespace" + "\\}",apiInvoker.escape(namespace)).replaceAll("\\{" + "path" + "\\}",apiInvoker.escape(_path))

    val contentTypes = List("*/*")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (name == null) throw new Exception("Missing required parameter 'name' when calling Core_v1Api->connectCoreV1GetNamespacedPodProxyWithPath")

    if (namespace == null) throw new Exception("Missing required parameter 'namespace' when calling Core_v1Api->connectCoreV1GetNamespacedPodProxyWithPath")

    if (_path == null) throw new Exception("Missing required parameter '_path' when calling Core_v1Api->connectCoreV1GetNamespacedPodProxyWithPath")

    _path2.map(paramVal => queryParams += "path" -> paramVal.toString)
    

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "GET", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "", classOf[String]).asInstanceOf[String])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * 
   * connect GET requests to proxy of Service
   * @param name name of the Service 
   * @param namespace object name and auth scope, such as for teams and projects 
   * @param _path Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q&#x3D;user:kimchy. Path is _search?q&#x3D;user:kimchy. (optional)
   * @return String
   */
  def connectCoreV1GetNamespacedServiceProxy(name: String, namespace: String, _path: Option[String] = None): Option[String] = {
    // create path and map variables
    val path = "/api/v1/namespaces/{namespace}/services/{name}/proxy".replaceAll("\\{format\\}", "json").replaceAll("\\{" + "name" + "\\}",apiInvoker.escape(name)).replaceAll("\\{" + "namespace" + "\\}",apiInvoker.escape(namespace))

    val contentTypes = List("*/*")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (name == null) throw new Exception("Missing required parameter 'name' when calling Core_v1Api->connectCoreV1GetNamespacedServiceProxy")

    if (namespace == null) throw new Exception("Missing required parameter 'namespace' when calling Core_v1Api->connectCoreV1GetNamespacedServiceProxy")

    _path.map(paramVal => queryParams += "path" -> paramVal.toString)
    

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "GET", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "", classOf[String]).asInstanceOf[String])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * 
   * connect GET requests to proxy of Service
   * @param name name of the Service 
   * @param namespace object name and auth scope, such as for teams and projects 
   * @param _path path to the resource 
   * @param _path2 Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q&#x3D;user:kimchy. Path is _search?q&#x3D;user:kimchy. (optional)
   * @return String
   */
  def connectCoreV1GetNamespacedServiceProxyWithPath(name: String, namespace: String, _path: String, _path2: Option[String] = None): Option[String] = {
    // create path and map variables
    val path = "/api/v1/namespaces/{namespace}/services/{name}/proxy/{path}".replaceAll("\\{format\\}", "json").replaceAll("\\{" + "name" + "\\}",apiInvoker.escape(name)).replaceAll("\\{" + "namespace" + "\\}",apiInvoker.escape(namespace)).replaceAll("\\{" + "path" + "\\}",apiInvoker.escape(_path))

    val contentTypes = List("*/*")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (name == null) throw new Exception("Missing required parameter 'name' when calling Core_v1Api->connectCoreV1GetNamespacedServiceProxyWithPath")

    if (namespace == null) throw new Exception("Missing required parameter 'namespace' when calling Core_v1Api->connectCoreV1GetNamespacedServiceProxyWithPath")

    if (_path == null) throw new Exception("Missing required parameter '_path' when calling Core_v1Api->connectCoreV1GetNamespacedServiceProxyWithPath")

    _path2.map(paramVal => queryParams += "path" -> paramVal.toString)
    

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "GET", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "", classOf[String]).asInstanceOf[String])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * 
   * connect GET requests to proxy of Node
   * @param name name of the Node 
   * @param _path Path is the URL path to use for the current proxy request to node. (optional)
   * @return String
   */
  def connectCoreV1GetNodeProxy(name: String, _path: Option[String] = None): Option[String] = {
    // create path and map variables
    val path = "/api/v1/nodes/{name}/proxy".replaceAll("\\{format\\}", "json").replaceAll("\\{" + "name" + "\\}",apiInvoker.escape(name))

    val contentTypes = List("*/*")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (name == null) throw new Exception("Missing required parameter 'name' when calling Core_v1Api->connectCoreV1GetNodeProxy")

    _path.map(paramVal => queryParams += "path" -> paramVal.toString)
    

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "GET", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "", classOf[String]).asInstanceOf[String])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * 
   * connect GET requests to proxy of Node
   * @param name name of the Node 
   * @param _path path to the resource 
   * @param _path2 Path is the URL path to use for the current proxy request to node. (optional)
   * @return String
   */
  def connectCoreV1GetNodeProxyWithPath(name: String, _path: String, _path2: Option[String] = None): Option[String] = {
    // create path and map variables
    val path = "/api/v1/nodes/{name}/proxy/{path}".replaceAll("\\{format\\}", "json").replaceAll("\\{" + "name" + "\\}",apiInvoker.escape(name)).replaceAll("\\{" + "path" + "\\}",apiInvoker.escape(_path))

    val contentTypes = List("*/*")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (name == null) throw new Exception("Missing required parameter 'name' when calling Core_v1Api->connectCoreV1GetNodeProxyWithPath")

    if (_path == null) throw new Exception("Missing required parameter '_path' when calling Core_v1Api->connectCoreV1GetNodeProxyWithPath")

    _path2.map(paramVal => queryParams += "path" -> paramVal.toString)
    

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "GET", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "", classOf[String]).asInstanceOf[String])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * 
   * connect HEAD requests to proxy of Pod
   * @param name name of the Pod 
   * @param namespace object name and auth scope, such as for teams and projects 
   * @param _path Path is the URL path to use for the current proxy request to pod. (optional)
   * @return String
   */
  def connectCoreV1HeadNamespacedPodProxy(name: String, namespace: String, _path: Option[String] = None): Option[String] = {
    // create path and map variables
    val path = "/api/v1/namespaces/{namespace}/pods/{name}/proxy".replaceAll("\\{format\\}", "json").replaceAll("\\{" + "name" + "\\}",apiInvoker.escape(name)).replaceAll("\\{" + "namespace" + "\\}",apiInvoker.escape(namespace))

    val contentTypes = List("*/*")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (name == null) throw new Exception("Missing required parameter 'name' when calling Core_v1Api->connectCoreV1HeadNamespacedPodProxy")

    if (namespace == null) throw new Exception("Missing required parameter 'namespace' when calling Core_v1Api->connectCoreV1HeadNamespacedPodProxy")

    _path.map(paramVal => queryParams += "path" -> paramVal.toString)
    

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "HEAD", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "", classOf[String]).asInstanceOf[String])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * 
   * connect HEAD requests to proxy of Pod
   * @param name name of the Pod 
   * @param namespace object name and auth scope, such as for teams and projects 
   * @param _path path to the resource 
   * @param _path2 Path is the URL path to use for the current proxy request to pod. (optional)
   * @return String
   */
  def connectCoreV1HeadNamespacedPodProxyWithPath(name: String, namespace: String, _path: String, _path2: Option[String] = None): Option[String] = {
    // create path and map variables
    val path = "/api/v1/namespaces/{namespace}/pods/{name}/proxy/{path}".replaceAll("\\{format\\}", "json").replaceAll("\\{" + "name" + "\\}",apiInvoker.escape(name)).replaceAll("\\{" + "namespace" + "\\}",apiInvoker.escape(namespace)).replaceAll("\\{" + "path" + "\\}",apiInvoker.escape(_path))

    val contentTypes = List("*/*")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (name == null) throw new Exception("Missing required parameter 'name' when calling Core_v1Api->connectCoreV1HeadNamespacedPodProxyWithPath")

    if (namespace == null) throw new Exception("Missing required parameter 'namespace' when calling Core_v1Api->connectCoreV1HeadNamespacedPodProxyWithPath")

    if (_path == null) throw new Exception("Missing required parameter '_path' when calling Core_v1Api->connectCoreV1HeadNamespacedPodProxyWithPath")

    _path2.map(paramVal => queryParams += "path" -> paramVal.toString)
    

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "HEAD", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "", classOf[String]).asInstanceOf[String])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * 
   * connect HEAD requests to proxy of Service
   * @param name name of the Service 
   * @param namespace object name and auth scope, such as for teams and projects 
   * @param _path Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q&#x3D;user:kimchy. Path is _search?q&#x3D;user:kimchy. (optional)
   * @return String
   */
  def connectCoreV1HeadNamespacedServiceProxy(name: String, namespace: String, _path: Option[String] = None): Option[String] = {
    // create path and map variables
    val path = "/api/v1/namespaces/{namespace}/services/{name}/proxy".replaceAll("\\{format\\}", "json").replaceAll("\\{" + "name" + "\\}",apiInvoker.escape(name)).replaceAll("\\{" + "namespace" + "\\}",apiInvoker.escape(namespace))

    val contentTypes = List("*/*")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (name == null) throw new Exception("Missing required parameter 'name' when calling Core_v1Api->connectCoreV1HeadNamespacedServiceProxy")

    if (namespace == null) throw new Exception("Missing required parameter 'namespace' when calling Core_v1Api->connectCoreV1HeadNamespacedServiceProxy")

    _path.map(paramVal => queryParams += "path" -> paramVal.toString)
    

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "HEAD", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "", classOf[String]).asInstanceOf[String])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * 
   * connect HEAD requests to proxy of Service
   * @param name name of the Service 
   * @param namespace object name and auth scope, such as for teams and projects 
   * @param _path path to the resource 
   * @param _path2 Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q&#x3D;user:kimchy. Path is _search?q&#x3D;user:kimchy. (optional)
   * @return String
   */
  def connectCoreV1HeadNamespacedServiceProxyWithPath(name: String, namespace: String, _path: String, _path2: Option[String] = None): Option[String] = {
    // create path and map variables
    val path = "/api/v1/namespaces/{namespace}/services/{name}/proxy/{path}".replaceAll("\\{format\\}", "json").replaceAll("\\{" + "name" + "\\}",apiInvoker.escape(name)).replaceAll("\\{" + "namespace" + "\\}",apiInvoker.escape(namespace)).replaceAll("\\{" + "path" + "\\}",apiInvoker.escape(_path))

    val contentTypes = List("*/*")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (name == null) throw new Exception("Missing required parameter 'name' when calling Core_v1Api->connectCoreV1HeadNamespacedServiceProxyWithPath")

    if (namespace == null) throw new Exception("Missing required parameter 'namespace' when calling Core_v1Api->connectCoreV1HeadNamespacedServiceProxyWithPath")

    if (_path == null) throw new Exception("Missing required parameter '_path' when calling Core_v1Api->connectCoreV1HeadNamespacedServiceProxyWithPath")

    _path2.map(paramVal => queryParams += "path" -> paramVal.toString)
    

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "HEAD", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "", classOf[String]).asInstanceOf[String])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * 
   * connect HEAD requests to proxy of Node
   * @param name name of the Node 
   * @param _path Path is the URL path to use for the current proxy request to node. (optional)
   * @return String
   */
  def connectCoreV1HeadNodeProxy(name: String, _path: Option[String] = None): Option[String] = {
    // create path and map variables
    val path = "/api/v1/nodes/{name}/proxy".replaceAll("\\{format\\}", "json").replaceAll("\\{" + "name" + "\\}",apiInvoker.escape(name))

    val contentTypes = List("*/*")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (name == null) throw new Exception("Missing required parameter 'name' when calling Core_v1Api->connectCoreV1HeadNodeProxy")

    _path.map(paramVal => queryParams += "path" -> paramVal.toString)
    

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "HEAD", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "", classOf[String]).asInstanceOf[String])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * 
   * connect HEAD requests to proxy of Node
   * @param name name of the Node 
   * @param _path path to the resource 
   * @param _path2 Path is the URL path to use for the current proxy request to node. (optional)
   * @return String
   */
  def connectCoreV1HeadNodeProxyWithPath(name: String, _path: String, _path2: Option[String] = None): Option[String] = {
    // create path and map variables
    val path = "/api/v1/nodes/{name}/proxy/{path}".replaceAll("\\{format\\}", "json").replaceAll("\\{" + "name" + "\\}",apiInvoker.escape(name)).replaceAll("\\{" + "path" + "\\}",apiInvoker.escape(_path))

    val contentTypes = List("*/*")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (name == null) throw new Exception("Missing required parameter 'name' when calling Core_v1Api->connectCoreV1HeadNodeProxyWithPath")

    if (_path == null) throw new Exception("Missing required parameter '_path' when calling Core_v1Api->connectCoreV1HeadNodeProxyWithPath")

    _path2.map(paramVal => queryParams += "path" -> paramVal.toString)
    

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "HEAD", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "", classOf[String]).asInstanceOf[String])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * 
   * connect OPTIONS requests to proxy of Pod
   * @param name name of the Pod 
   * @param namespace object name and auth scope, such as for teams and projects 
   * @param _path Path is the URL path to use for the current proxy request to pod. (optional)
   * @return String
   */
  def connectCoreV1OptionsNamespacedPodProxy(name: String, namespace: String, _path: Option[String] = None): Option[String] = {
    // create path and map variables
    val path = "/api/v1/namespaces/{namespace}/pods/{name}/proxy".replaceAll("\\{format\\}", "json").replaceAll("\\{" + "name" + "\\}",apiInvoker.escape(name)).replaceAll("\\{" + "namespace" + "\\}",apiInvoker.escape(namespace))

    val contentTypes = List("*/*")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (name == null) throw new Exception("Missing required parameter 'name' when calling Core_v1Api->connectCoreV1OptionsNamespacedPodProxy")

    if (namespace == null) throw new Exception("Missing required parameter 'namespace' when calling Core_v1Api->connectCoreV1OptionsNamespacedPodProxy")

    _path.map(paramVal => queryParams += "path" -> paramVal.toString)
    

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "OPTIONS", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "", classOf[String]).asInstanceOf[String])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * 
   * connect OPTIONS requests to proxy of Pod
   * @param name name of the Pod 
   * @param namespace object name and auth scope, such as for teams and projects 
   * @param _path path to the resource 
   * @param _path2 Path is the URL path to use for the current proxy request to pod. (optional)
   * @return String
   */
  def connectCoreV1OptionsNamespacedPodProxyWithPath(name: String, namespace: String, _path: String, _path2: Option[String] = None): Option[String] = {
    // create path and map variables
    val path = "/api/v1/namespaces/{namespace}/pods/{name}/proxy/{path}".replaceAll("\\{format\\}", "json").replaceAll("\\{" + "name" + "\\}",apiInvoker.escape(name)).replaceAll("\\{" + "namespace" + "\\}",apiInvoker.escape(namespace)).replaceAll("\\{" + "path" + "\\}",apiInvoker.escape(_path))

    val contentTypes = List("*/*")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (name == null) throw new Exception("Missing required parameter 'name' when calling Core_v1Api->connectCoreV1OptionsNamespacedPodProxyWithPath")

    if (namespace == null) throw new Exception("Missing required parameter 'namespace' when calling Core_v1Api->connectCoreV1OptionsNamespacedPodProxyWithPath")

    if (_path == null) throw new Exception("Missing required parameter '_path' when calling Core_v1Api->connectCoreV1OptionsNamespacedPodProxyWithPath")

    _path2.map(paramVal => queryParams += "path" -> paramVal.toString)
    

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "OPTIONS", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "", classOf[String]).asInstanceOf[String])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * 
   * connect OPTIONS requests to proxy of Service
   * @param name name of the Service 
   * @param namespace object name and auth scope, such as for teams and projects 
   * @param _path Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q&#x3D;user:kimchy. Path is _search?q&#x3D;user:kimchy. (optional)
   * @return String
   */
  def connectCoreV1OptionsNamespacedServiceProxy(name: String, namespace: String, _path: Option[String] = None): Option[String] = {
    // create path and map variables
    val path = "/api/v1/namespaces/{namespace}/services/{name}/proxy".replaceAll("\\{format\\}", "json").replaceAll("\\{" + "name" + "\\}",apiInvoker.escape(name)).replaceAll("\\{" + "namespace" + "\\}",apiInvoker.escape(namespace))

    val contentTypes = List("*/*")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (name == null) throw new Exception("Missing required parameter 'name' when calling Core_v1Api->connectCoreV1OptionsNamespacedServiceProxy")

    if (namespace == null) throw new Exception("Missing required parameter 'namespace' when calling Core_v1Api->connectCoreV1OptionsNamespacedServiceProxy")

    _path.map(paramVal => queryParams += "path" -> paramVal.toString)
    

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "OPTIONS", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "", classOf[String]).asInstanceOf[String])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * 
   * connect OPTIONS requests to proxy of Service
   * @param name name of the Service 
   * @param namespace object name and auth scope, such as for teams and projects 
   * @param _path path to the resource 
   * @param _path2 Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q&#x3D;user:kimchy. Path is _search?q&#x3D;user:kimchy. (optional)
   * @return String
   */
  def connectCoreV1OptionsNamespacedServiceProxyWithPath(name: String, namespace: String, _path: String, _path2: Option[String] = None): Option[String] = {
    // create path and map variables
    val path = "/api/v1/namespaces/{namespace}/services/{name}/proxy/{path}".replaceAll("\\{format\\}", "json").replaceAll("\\{" + "name" + "\\}",apiInvoker.escape(name)).replaceAll("\\{" + "namespace" + "\\}",apiInvoker.escape(namespace)).replaceAll("\\{" + "path" + "\\}",apiInvoker.escape(_path))

    val contentTypes = List("*/*")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (name == null) throw new Exception("Missing required parameter 'name' when calling Core_v1Api->connectCoreV1OptionsNamespacedServiceProxyWithPath")

    if (namespace == null) throw new Exception("Missing required parameter 'namespace' when calling Core_v1Api->connectCoreV1OptionsNamespacedServiceProxyWithPath")

    if (_path == null) throw new Exception("Missing required parameter '_path' when calling Core_v1Api->connectCoreV1OptionsNamespacedServiceProxyWithPath")

    _path2.map(paramVal => queryParams += "path" -> paramVal.toString)
    

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "OPTIONS", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "", classOf[String]).asInstanceOf[String])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * 
   * connect OPTIONS requests to proxy of Node
   * @param name name of the Node 
   * @param _path Path is the URL path to use for the current proxy request to node. (optional)
   * @return String
   */
  def connectCoreV1OptionsNodeProxy(name: String, _path: Option[String] = None): Option[String] = {
    // create path and map variables
    val path = "/api/v1/nodes/{name}/proxy".replaceAll("\\{format\\}", "json").replaceAll("\\{" + "name" + "\\}",apiInvoker.escape(name))

    val contentTypes = List("*/*")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (name == null) throw new Exception("Missing required parameter 'name' when calling Core_v1Api->connectCoreV1OptionsNodeProxy")

    _path.map(paramVal => queryParams += "path" -> paramVal.toString)
    

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "OPTIONS", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "", classOf[String]).asInstanceOf[String])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * 
   * connect OPTIONS requests to proxy of Node
   * @param name name of the Node 
   * @param _path path to the resource 
   * @param _path2 Path is the URL path to use for the current proxy request to node. (optional)
   * @return String
   */
  def connectCoreV1OptionsNodeProxyWithPath(name: String, _path: String, _path2: Option[String] = None): Option[String] = {
    // create path and map variables
    val path = "/api/v1/nodes/{name}/proxy/{path}".replaceAll("\\{format\\}", "json").replaceAll("\\{" + "name" + "\\}",apiInvoker.escape(name)).replaceAll("\\{" + "path" + "\\}",apiInvoker.escape(_path))

    val contentTypes = List("*/*")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (name == null) throw new Exception("Missing required parameter 'name' when calling Core_v1Api->connectCoreV1OptionsNodeProxyWithPath")

    if (_path == null) throw new Exception("Missing required parameter '_path' when calling Core_v1Api->connectCoreV1OptionsNodeProxyWithPath")

    _path2.map(paramVal => queryParams += "path" -> paramVal.toString)
    

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "OPTIONS", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "", classOf[String]).asInstanceOf[String])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * 
   * connect PATCH requests to proxy of Pod
   * @param name name of the Pod 
   * @param namespace object name and auth scope, such as for teams and projects 
   * @param _path Path is the URL path to use for the current proxy request to pod. (optional)
   * @return String
   */
  def connectCoreV1PatchNamespacedPodProxy(name: String, namespace: String, _path: Option[String] = None): Option[String] = {
    // create path and map variables
    val path = "/api/v1/namespaces/{namespace}/pods/{name}/proxy".replaceAll("\\{format\\}", "json").replaceAll("\\{" + "name" + "\\}",apiInvoker.escape(name)).replaceAll("\\{" + "namespace" + "\\}",apiInvoker.escape(namespace))

    val contentTypes = List("*/*")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (name == null) throw new Exception("Missing required parameter 'name' when calling Core_v1Api->connectCoreV1PatchNamespacedPodProxy")

    if (namespace == null) throw new Exception("Missing required parameter 'namespace' when calling Core_v1Api->connectCoreV1PatchNamespacedPodProxy")

    _path.map(paramVal => queryParams += "path" -> paramVal.toString)
    

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "PATCH", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "", classOf[String]).asInstanceOf[String])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * 
   * connect PATCH requests to proxy of Pod
   * @param name name of the Pod 
   * @param namespace object name and auth scope, such as for teams and projects 
   * @param _path path to the resource 
   * @param _path2 Path is the URL path to use for the current proxy request to pod. (optional)
   * @return String
   */
  def connectCoreV1PatchNamespacedPodProxyWithPath(name: String, namespace: String, _path: String, _path2: Option[String] = None): Option[String] = {
    // create path and map variables
    val path = "/api/v1/namespaces/{namespace}/pods/{name}/proxy/{path}".replaceAll("\\{format\\}", "json").replaceAll("\\{" + "name" + "\\}",apiInvoker.escape(name)).replaceAll("\\{" + "namespace" + "\\}",apiInvoker.escape(namespace)).replaceAll("\\{" + "path" + "\\}",apiInvoker.escape(_path))

    val contentTypes = List("*/*")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (name == null) throw new Exception("Missing required parameter 'name' when calling Core_v1Api->connectCoreV1PatchNamespacedPodProxyWithPath")

    if (namespace == null) throw new Exception("Missing required parameter 'namespace' when calling Core_v1Api->connectCoreV1PatchNamespacedPodProxyWithPath")

    if (_path == null) throw new Exception("Missing required parameter '_path' when calling Core_v1Api->connectCoreV1PatchNamespacedPodProxyWithPath")

    _path2.map(paramVal => queryParams += "path" -> paramVal.toString)
    

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "PATCH", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "", classOf[String]).asInstanceOf[String])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * 
   * connect PATCH requests to proxy of Service
   * @param name name of the Service 
   * @param namespace object name and auth scope, such as for teams and projects 
   * @param _path Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q&#x3D;user:kimchy. Path is _search?q&#x3D;user:kimchy. (optional)
   * @return String
   */
  def connectCoreV1PatchNamespacedServiceProxy(name: String, namespace: String, _path: Option[String] = None): Option[String] = {
    // create path and map variables
    val path = "/api/v1/namespaces/{namespace}/services/{name}/proxy".replaceAll("\\{format\\}", "json").replaceAll("\\{" + "name" + "\\}",apiInvoker.escape(name)).replaceAll("\\{" + "namespace" + "\\}",apiInvoker.escape(namespace))

    val contentTypes = List("*/*")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (name == null) throw new Exception("Missing required parameter 'name' when calling Core_v1Api->connectCoreV1PatchNamespacedServiceProxy")

    if (namespace == null) throw new Exception("Missing required parameter 'namespace' when calling Core_v1Api->connectCoreV1PatchNamespacedServiceProxy")

    _path.map(paramVal => queryParams += "path" -> paramVal.toString)
    

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "PATCH", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "", classOf[String]).asInstanceOf[String])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * 
   * connect PATCH requests to proxy of Service
   * @param name name of the Service 
   * @param namespace object name and auth scope, such as for teams and projects 
   * @param _path path to the resource 
   * @param _path2 Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q&#x3D;user:kimchy. Path is _search?q&#x3D;user:kimchy. (optional)
   * @return String
   */
  def connectCoreV1PatchNamespacedServiceProxyWithPath(name: String, namespace: String, _path: String, _path2: Option[String] = None): Option[String] = {
    // create path and map variables
    val path = "/api/v1/namespaces/{namespace}/services/{name}/proxy/{path}".replaceAll("\\{format\\}", "json").replaceAll("\\{" + "name" + "\\}",apiInvoker.escape(name)).replaceAll("\\{" + "namespace" + "\\}",apiInvoker.escape(namespace)).replaceAll("\\{" + "path" + "\\}",apiInvoker.escape(_path))

    val contentTypes = List("*/*")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (name == null) throw new Exception("Missing required parameter 'name' when calling Core_v1Api->connectCoreV1PatchNamespacedServiceProxyWithPath")

    if (namespace == null) throw new Exception("Missing required parameter 'namespace' when calling Core_v1Api->connectCoreV1PatchNamespacedServiceProxyWithPath")

    if (_path == null) throw new Exception("Missing required parameter '_path' when calling Core_v1Api->connectCoreV1PatchNamespacedServiceProxyWithPath")

    _path2.map(paramVal => queryParams += "path" -> paramVal.toString)
    

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "PATCH", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "", classOf[String]).asInstanceOf[String])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * 
   * connect PATCH requests to proxy of Node
   * @param name name of the Node 
   * @param _path Path is the URL path to use for the current proxy request to node. (optional)
   * @return String
   */
  def connectCoreV1PatchNodeProxy(name: String, _path: Option[String] = None): Option[String] = {
    // create path and map variables
    val path = "/api/v1/nodes/{name}/proxy".replaceAll("\\{format\\}", "json").replaceAll("\\{" + "name" + "\\}",apiInvoker.escape(name))

    val contentTypes = List("*/*")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (name == null) throw new Exception("Missing required parameter 'name' when calling Core_v1Api->connectCoreV1PatchNodeProxy")

    _path.map(paramVal => queryParams += "path" -> paramVal.toString)
    

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "PATCH", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "", classOf[String]).asInstanceOf[String])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * 
   * connect PATCH requests to proxy of Node
   * @param name name of the Node 
   * @param _path path to the resource 
   * @param _path2 Path is the URL path to use for the current proxy request to node. (optional)
   * @return String
   */
  def connectCoreV1PatchNodeProxyWithPath(name: String, _path: String, _path2: Option[String] = None): Option[String] = {
    // create path and map variables
    val path = "/api/v1/nodes/{name}/proxy/{path}".replaceAll("\\{format\\}", "json").replaceAll("\\{" + "name" + "\\}",apiInvoker.escape(name)).replaceAll("\\{" + "path" + "\\}",apiInvoker.escape(_path))

    val contentTypes = List("*/*")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (name == null) throw new Exception("Missing required parameter 'name' when calling Core_v1Api->connectCoreV1PatchNodeProxyWithPath")

    if (_path == null) throw new Exception("Missing required parameter '_path' when calling Core_v1Api->connectCoreV1PatchNodeProxyWithPath")

    _path2.map(paramVal => queryParams += "path" -> paramVal.toString)
    

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "PATCH", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "", classOf[String]).asInstanceOf[String])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * 
   * connect POST requests to attach of Pod
   * @param name name of the Pod 
   * @param namespace object name and auth scope, such as for teams and projects 
   * @param container The container in which to execute the command. Defaults to only container if there is only one container in the pod. (optional)
   * @param stderr Stderr if true indicates that stderr is to be redirected for the attach call. Defaults to true. (optional)
   * @param stdin Stdin if true, redirects the standard input stream of the pod for this call. Defaults to false. (optional)
   * @param stdout Stdout if true indicates that stdout is to be redirected for the attach call. Defaults to true. (optional)
   * @param tty TTY if true indicates that a tty will be allocated for the attach call. This is passed through the container runtime so the tty is allocated on the worker node by the container runtime. Defaults to false. (optional)
   * @return String
   */
  def connectCoreV1PostNamespacedPodAttach(name: String, namespace: String, container: Option[String] = None, stderr: Option[Boolean] = None, stdin: Option[Boolean] = None, stdout: Option[Boolean] = None, tty: Option[Boolean] = None): Option[String] = {
    // create path and map variables
    val path = "/api/v1/namespaces/{namespace}/pods/{name}/attach".replaceAll("\\{format\\}", "json").replaceAll("\\{" + "name" + "\\}",apiInvoker.escape(name)).replaceAll("\\{" + "namespace" + "\\}",apiInvoker.escape(namespace))

    val contentTypes = List("*/*")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (name == null) throw new Exception("Missing required parameter 'name' when calling Core_v1Api->connectCoreV1PostNamespacedPodAttach")

    if (namespace == null) throw new Exception("Missing required parameter 'namespace' when calling Core_v1Api->connectCoreV1PostNamespacedPodAttach")

    container.map(paramVal => queryParams += "container" -> paramVal.toString)
    stderr.map(paramVal => queryParams += "stderr" -> paramVal.toString)
    stdin.map(paramVal => queryParams += "stdin" -> paramVal.toString)
    stdout.map(paramVal => queryParams += "stdout" -> paramVal.toString)
    tty.map(paramVal => queryParams += "tty" -> paramVal.toString)
    

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "POST", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "", classOf[String]).asInstanceOf[String])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * 
   * connect POST requests to exec of Pod
   * @param name name of the Pod 
   * @param namespace object name and auth scope, such as for teams and projects 
   * @param command Command is the remote command to execute. argv array. Not executed within a shell. (optional)
   * @param container Container in which to execute the command. Defaults to only container if there is only one container in the pod. (optional)
   * @param stderr Redirect the standard error stream of the pod for this call. Defaults to true. (optional)
   * @param stdin Redirect the standard input stream of the pod for this call. Defaults to false. (optional)
   * @param stdout Redirect the standard output stream of the pod for this call. Defaults to true. (optional)
   * @param tty TTY if true indicates that a tty will be allocated for the exec call. Defaults to false. (optional)
   * @return String
   */
  def connectCoreV1PostNamespacedPodExec(name: String, namespace: String, command: Option[String] = None, container: Option[String] = None, stderr: Option[Boolean] = None, stdin: Option[Boolean] = None, stdout: Option[Boolean] = None, tty: Option[Boolean] = None): Option[String] = {
    // create path and map variables
    val path = "/api/v1/namespaces/{namespace}/pods/{name}/exec".replaceAll("\\{format\\}", "json").replaceAll("\\{" + "name" + "\\}",apiInvoker.escape(name)).replaceAll("\\{" + "namespace" + "\\}",apiInvoker.escape(namespace))

    val contentTypes = List("*/*")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (name == null) throw new Exception("Missing required parameter 'name' when calling Core_v1Api->connectCoreV1PostNamespacedPodExec")

    if (namespace == null) throw new Exception("Missing required parameter 'namespace' when calling Core_v1Api->connectCoreV1PostNamespacedPodExec")

    command.map(paramVal => queryParams += "command" -> paramVal.toString)
    container.map(paramVal => queryParams += "container" -> paramVal.toString)
    stderr.map(paramVal => queryParams += "stderr" -> paramVal.toString)
    stdin.map(paramVal => queryParams += "stdin" -> paramVal.toString)
    stdout.map(paramVal => queryParams += "stdout" -> paramVal.toString)
    tty.map(paramVal => queryParams += "tty" -> paramVal.toString)
    

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "POST", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "", classOf[String]).asInstanceOf[String])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * 
   * connect POST requests to portforward of Pod
   * @param name name of the Pod 
   * @param namespace object name and auth scope, such as for teams and projects 
   * @param ports List of ports to forward Required when using WebSockets (optional)
   * @return String
   */
  def connectCoreV1PostNamespacedPodPortforward(name: String, namespace: String, ports: Option[Integer] = None): Option[String] = {
    // create path and map variables
    val path = "/api/v1/namespaces/{namespace}/pods/{name}/portforward".replaceAll("\\{format\\}", "json").replaceAll("\\{" + "name" + "\\}",apiInvoker.escape(name)).replaceAll("\\{" + "namespace" + "\\}",apiInvoker.escape(namespace))

    val contentTypes = List("*/*")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (name == null) throw new Exception("Missing required parameter 'name' when calling Core_v1Api->connectCoreV1PostNamespacedPodPortforward")

    if (namespace == null) throw new Exception("Missing required parameter 'namespace' when calling Core_v1Api->connectCoreV1PostNamespacedPodPortforward")

    ports.map(paramVal => queryParams += "ports" -> paramVal.toString)
    

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "POST", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "", classOf[String]).asInstanceOf[String])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * 
   * connect POST requests to proxy of Pod
   * @param name name of the Pod 
   * @param namespace object name and auth scope, such as for teams and projects 
   * @param _path Path is the URL path to use for the current proxy request to pod. (optional)
   * @return String
   */
  def connectCoreV1PostNamespacedPodProxy(name: String, namespace: String, _path: Option[String] = None): Option[String] = {
    // create path and map variables
    val path = "/api/v1/namespaces/{namespace}/pods/{name}/proxy".replaceAll("\\{format\\}", "json").replaceAll("\\{" + "name" + "\\}",apiInvoker.escape(name)).replaceAll("\\{" + "namespace" + "\\}",apiInvoker.escape(namespace))

    val contentTypes = List("*/*")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (name == null) throw new Exception("Missing required parameter 'name' when calling Core_v1Api->connectCoreV1PostNamespacedPodProxy")

    if (namespace == null) throw new Exception("Missing required parameter 'namespace' when calling Core_v1Api->connectCoreV1PostNamespacedPodProxy")

    _path.map(paramVal => queryParams += "path" -> paramVal.toString)
    

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "POST", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "", classOf[String]).asInstanceOf[String])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * 
   * connect POST requests to proxy of Pod
   * @param name name of the Pod 
   * @param namespace object name and auth scope, such as for teams and projects 
   * @param _path path to the resource 
   * @param _path2 Path is the URL path to use for the current proxy request to pod. (optional)
   * @return String
   */
  def connectCoreV1PostNamespacedPodProxyWithPath(name: String, namespace: String, _path: String, _path2: Option[String] = None): Option[String] = {
    // create path and map variables
    val path = "/api/v1/namespaces/{namespace}/pods/{name}/proxy/{path}".replaceAll("\\{format\\}", "json").replaceAll("\\{" + "name" + "\\}",apiInvoker.escape(name)).replaceAll("\\{" + "namespace" + "\\}",apiInvoker.escape(namespace)).replaceAll("\\{" + "path" + "\\}",apiInvoker.escape(_path))

    val contentTypes = List("*/*")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (name == null) throw new Exception("Missing required parameter 'name' when calling Core_v1Api->connectCoreV1PostNamespacedPodProxyWithPath")

    if (namespace == null) throw new Exception("Missing required parameter 'namespace' when calling Core_v1Api->connectCoreV1PostNamespacedPodProxyWithPath")

    if (_path == null) throw new Exception("Missing required parameter '_path' when calling Core_v1Api->connectCoreV1PostNamespacedPodProxyWithPath")

    _path2.map(paramVal => queryParams += "path" -> paramVal.toString)
    

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "POST", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "", classOf[String]).asInstanceOf[String])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * 
   * connect POST requests to proxy of Service
   * @param name name of the Service 
   * @param namespace object name and auth scope, such as for teams and projects 
   * @param _path Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q&#x3D;user:kimchy. Path is _search?q&#x3D;user:kimchy. (optional)
   * @return String
   */
  def connectCoreV1PostNamespacedServiceProxy(name: String, namespace: String, _path: Option[String] = None): Option[String] = {
    // create path and map variables
    val path = "/api/v1/namespaces/{namespace}/services/{name}/proxy".replaceAll("\\{format\\}", "json").replaceAll("\\{" + "name" + "\\}",apiInvoker.escape(name)).replaceAll("\\{" + "namespace" + "\\}",apiInvoker.escape(namespace))

    val contentTypes = List("*/*")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (name == null) throw new Exception("Missing required parameter 'name' when calling Core_v1Api->connectCoreV1PostNamespacedServiceProxy")

    if (namespace == null) throw new Exception("Missing required parameter 'namespace' when calling Core_v1Api->connectCoreV1PostNamespacedServiceProxy")

    _path.map(paramVal => queryParams += "path" -> paramVal.toString)
    

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "POST", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "", classOf[String]).asInstanceOf[String])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * 
   * connect POST requests to proxy of Service
   * @param name name of the Service 
   * @param namespace object name and auth scope, such as for teams and projects 
   * @param _path path to the resource 
   * @param _path2 Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q&#x3D;user:kimchy. Path is _search?q&#x3D;user:kimchy. (optional)
   * @return String
   */
  def connectCoreV1PostNamespacedServiceProxyWithPath(name: String, namespace: String, _path: String, _path2: Option[String] = None): Option[String] = {
    // create path and map variables
    val path = "/api/v1/namespaces/{namespace}/services/{name}/proxy/{path}".replaceAll("\\{format\\}", "json").replaceAll("\\{" + "name" + "\\}",apiInvoker.escape(name)).replaceAll("\\{" + "namespace" + "\\}",apiInvoker.escape(namespace)).replaceAll("\\{" + "path" + "\\}",apiInvoker.escape(_path))

    val contentTypes = List("*/*")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (name == null) throw new Exception("Missing required parameter 'name' when calling Core_v1Api->connectCoreV1PostNamespacedServiceProxyWithPath")

    if (namespace == null) throw new Exception("Missing required parameter 'namespace' when calling Core_v1Api->connectCoreV1PostNamespacedServiceProxyWithPath")

    if (_path == null) throw new Exception("Missing required parameter '_path' when calling Core_v1Api->connectCoreV1PostNamespacedServiceProxyWithPath")

    _path2.map(paramVal => queryParams += "path" -> paramVal.toString)
    

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "POST", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "", classOf[String]).asInstanceOf[String])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * 
   * connect POST requests to proxy of Node
   * @param name name of the Node 
   * @param _path Path is the URL path to use for the current proxy request to node. (optional)
   * @return String
   */
  def connectCoreV1PostNodeProxy(name: String, _path: Option[String] = None): Option[String] = {
    // create path and map variables
    val path = "/api/v1/nodes/{name}/proxy".replaceAll("\\{format\\}", "json").replaceAll("\\{" + "name" + "\\}",apiInvoker.escape(name))

    val contentTypes = List("*/*")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (name == null) throw new Exception("Missing required parameter 'name' when calling Core_v1Api->connectCoreV1PostNodeProxy")

    _path.map(paramVal => queryParams += "path" -> paramVal.toString)
    

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "POST", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "", classOf[String]).asInstanceOf[String])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * 
   * connect POST requests to proxy of Node
   * @param name name of the Node 
   * @param _path path to the resource 
   * @param _path2 Path is the URL path to use for the current proxy request to node. (optional)
   * @return String
   */
  def connectCoreV1PostNodeProxyWithPath(name: String, _path: String, _path2: Option[String] = None): Option[String] = {
    // create path and map variables
    val path = "/api/v1/nodes/{name}/proxy/{path}".replaceAll("\\{format\\}", "json").replaceAll("\\{" + "name" + "\\}",apiInvoker.escape(name)).replaceAll("\\{" + "path" + "\\}",apiInvoker.escape(_path))

    val contentTypes = List("*/*")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (name == null) throw new Exception("Missing required parameter 'name' when calling Core_v1Api->connectCoreV1PostNodeProxyWithPath")

    if (_path == null) throw new Exception("Missing required parameter '_path' when calling Core_v1Api->connectCoreV1PostNodeProxyWithPath")

    _path2.map(paramVal => queryParams += "path" -> paramVal.toString)
    

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "POST", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "", classOf[String]).asInstanceOf[String])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * 
   * connect PUT requests to proxy of Pod
   * @param name name of the Pod 
   * @param namespace object name and auth scope, such as for teams and projects 
   * @param _path Path is the URL path to use for the current proxy request to pod. (optional)
   * @return String
   */
  def connectCoreV1PutNamespacedPodProxy(name: String, namespace: String, _path: Option[String] = None): Option[String] = {
    // create path and map variables
    val path = "/api/v1/namespaces/{namespace}/pods/{name}/proxy".replaceAll("\\{format\\}", "json").replaceAll("\\{" + "name" + "\\}",apiInvoker.escape(name)).replaceAll("\\{" + "namespace" + "\\}",apiInvoker.escape(namespace))

    val contentTypes = List("*/*")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (name == null) throw new Exception("Missing required parameter 'name' when calling Core_v1Api->connectCoreV1PutNamespacedPodProxy")

    if (namespace == null) throw new Exception("Missing required parameter 'namespace' when calling Core_v1Api->connectCoreV1PutNamespacedPodProxy")

    _path.map(paramVal => queryParams += "path" -> paramVal.toString)
    

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "PUT", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "", classOf[String]).asInstanceOf[String])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * 
   * connect PUT requests to proxy of Pod
   * @param name name of the Pod 
   * @param namespace object name and auth scope, such as for teams and projects 
   * @param _path path to the resource 
   * @param _path2 Path is the URL path to use for the current proxy request to pod. (optional)
   * @return String
   */
  def connectCoreV1PutNamespacedPodProxyWithPath(name: String, namespace: String, _path: String, _path2: Option[String] = None): Option[String] = {
    // create path and map variables
    val path = "/api/v1/namespaces/{namespace}/pods/{name}/proxy/{path}".replaceAll("\\{format\\}", "json").replaceAll("\\{" + "name" + "\\}",apiInvoker.escape(name)).replaceAll("\\{" + "namespace" + "\\}",apiInvoker.escape(namespace)).replaceAll("\\{" + "path" + "\\}",apiInvoker.escape(_path))

    val contentTypes = List("*/*")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (name == null) throw new Exception("Missing required parameter 'name' when calling Core_v1Api->connectCoreV1PutNamespacedPodProxyWithPath")

    if (namespace == null) throw new Exception("Missing required parameter 'namespace' when calling Core_v1Api->connectCoreV1PutNamespacedPodProxyWithPath")

    if (_path == null) throw new Exception("Missing required parameter '_path' when calling Core_v1Api->connectCoreV1PutNamespacedPodProxyWithPath")

    _path2.map(paramVal => queryParams += "path" -> paramVal.toString)
    

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "PUT", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "", classOf[String]).asInstanceOf[String])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * 
   * connect PUT requests to proxy of Service
   * @param name name of the Service 
   * @param namespace object name and auth scope, such as for teams and projects 
   * @param _path Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q&#x3D;user:kimchy. Path is _search?q&#x3D;user:kimchy. (optional)
   * @return String
   */
  def connectCoreV1PutNamespacedServiceProxy(name: String, namespace: String, _path: Option[String] = None): Option[String] = {
    // create path and map variables
    val path = "/api/v1/namespaces/{namespace}/services/{name}/proxy".replaceAll("\\{format\\}", "json").replaceAll("\\{" + "name" + "\\}",apiInvoker.escape(name)).replaceAll("\\{" + "namespace" + "\\}",apiInvoker.escape(namespace))

    val contentTypes = List("*/*")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (name == null) throw new Exception("Missing required parameter 'name' when calling Core_v1Api->connectCoreV1PutNamespacedServiceProxy")

    if (namespace == null) throw new Exception("Missing required parameter 'namespace' when calling Core_v1Api->connectCoreV1PutNamespacedServiceProxy")

    _path.map(paramVal => queryParams += "path" -> paramVal.toString)
    

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "PUT", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "", classOf[String]).asInstanceOf[String])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * 
   * connect PUT requests to proxy of Service
   * @param name name of the Service 
   * @param namespace object name and auth scope, such as for teams and projects 
   * @param _path path to the resource 
   * @param _path2 Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q&#x3D;user:kimchy. Path is _search?q&#x3D;user:kimchy. (optional)
   * @return String
   */
  def connectCoreV1PutNamespacedServiceProxyWithPath(name: String, namespace: String, _path: String, _path2: Option[String] = None): Option[String] = {
    // create path and map variables
    val path = "/api/v1/namespaces/{namespace}/services/{name}/proxy/{path}".replaceAll("\\{format\\}", "json").replaceAll("\\{" + "name" + "\\}",apiInvoker.escape(name)).replaceAll("\\{" + "namespace" + "\\}",apiInvoker.escape(namespace)).replaceAll("\\{" + "path" + "\\}",apiInvoker.escape(_path))

    val contentTypes = List("*/*")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (name == null) throw new Exception("Missing required parameter 'name' when calling Core_v1Api->connectCoreV1PutNamespacedServiceProxyWithPath")

    if (namespace == null) throw new Exception("Missing required parameter 'namespace' when calling Core_v1Api->connectCoreV1PutNamespacedServiceProxyWithPath")

    if (_path == null) throw new Exception("Missing required parameter '_path' when calling Core_v1Api->connectCoreV1PutNamespacedServiceProxyWithPath")

    _path2.map(paramVal => queryParams += "path" -> paramVal.toString)
    

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "PUT", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "", classOf[String]).asInstanceOf[String])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * 
   * connect PUT requests to proxy of Node
   * @param name name of the Node 
   * @param _path Path is the URL path to use for the current proxy request to node. (optional)
   * @return String
   */
  def connectCoreV1PutNodeProxy(name: String, _path: Option[String] = None): Option[String] = {
    // create path and map variables
    val path = "/api/v1/nodes/{name}/proxy".replaceAll("\\{format\\}", "json").replaceAll("\\{" + "name" + "\\}",apiInvoker.escape(name))

    val contentTypes = List("*/*")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (name == null) throw new Exception("Missing required parameter 'name' when calling Core_v1Api->connectCoreV1PutNodeProxy")

    _path.map(paramVal => queryParams += "path" -> paramVal.toString)
    

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "PUT", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "", classOf[String]).asInstanceOf[String])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * 
   * connect PUT requests to proxy of Node
   * @param name name of the Node 
   * @param _path path to the resource 
   * @param _path2 Path is the URL path to use for the current proxy request to node. (optional)
   * @return String
   */
  def connectCoreV1PutNodeProxyWithPath(name: String, _path: String, _path2: Option[String] = None): Option[String] = {
    // create path and map variables
    val path = "/api/v1/nodes/{name}/proxy/{path}".replaceAll("\\{format\\}", "json").replaceAll("\\{" + "name" + "\\}",apiInvoker.escape(name)).replaceAll("\\{" + "path" + "\\}",apiInvoker.escape(_path))

    val contentTypes = List("*/*")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (name == null) throw new Exception("Missing required parameter 'name' when calling Core_v1Api->connectCoreV1PutNodeProxyWithPath")

    if (_path == null) throw new Exception("Missing required parameter '_path' when calling Core_v1Api->connectCoreV1PutNodeProxyWithPath")

    _path2.map(paramVal => queryParams += "path" -> paramVal.toString)
    

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "PUT", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "", classOf[String]).asInstanceOf[String])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * 
   * create a Namespace
   * @param body  
   * @param pretty If &#39;true&#39;, then the output is pretty printed. (optional)
   * @return IoK8sApiCoreV1Namespace
   */
  def createCoreV1Namespace(body: IoK8sApiCoreV1Namespace, pretty: Option[String] = None): Option[IoK8sApiCoreV1Namespace] = {
    // create path and map variables
    val path = "/api/v1/namespaces".replaceAll("\\{format\\}", "json")

    val contentTypes = List("*/*")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (body == null) throw new Exception("Missing required parameter 'body' when calling Core_v1Api->createCoreV1Namespace")

    pretty.map(paramVal => queryParams += "pretty" -> paramVal.toString)
    

    var postBody: AnyRef = body

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "POST", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "", classOf[IoK8sApiCoreV1Namespace]).asInstanceOf[IoK8sApiCoreV1Namespace])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * 
   * create a Binding
   * @param namespace object name and auth scope, such as for teams and projects 
   * @param body  
   * @param pretty If &#39;true&#39;, then the output is pretty printed. (optional)
   * @return IoK8sApiCoreV1Binding
   */
  def createCoreV1NamespacedBinding(namespace: String, body: IoK8sApiCoreV1Binding, pretty: Option[String] = None): Option[IoK8sApiCoreV1Binding] = {
    // create path and map variables
    val path = "/api/v1/namespaces/{namespace}/bindings".replaceAll("\\{format\\}", "json").replaceAll("\\{" + "namespace" + "\\}",apiInvoker.escape(namespace))

    val contentTypes = List("*/*")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (namespace == null) throw new Exception("Missing required parameter 'namespace' when calling Core_v1Api->createCoreV1NamespacedBinding")

    if (body == null) throw new Exception("Missing required parameter 'body' when calling Core_v1Api->createCoreV1NamespacedBinding")

    pretty.map(paramVal => queryParams += "pretty" -> paramVal.toString)
    

    var postBody: AnyRef = body

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "POST", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "", classOf[IoK8sApiCoreV1Binding]).asInstanceOf[IoK8sApiCoreV1Binding])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * 
   * create a ConfigMap
   * @param namespace object name and auth scope, such as for teams and projects 
   * @param body  
   * @param pretty If &#39;true&#39;, then the output is pretty printed. (optional)
   * @return IoK8sApiCoreV1ConfigMap
   */
  def createCoreV1NamespacedConfigMap(namespace: String, body: IoK8sApiCoreV1ConfigMap, pretty: Option[String] = None): Option[IoK8sApiCoreV1ConfigMap] = {
    // create path and map variables
    val path = "/api/v1/namespaces/{namespace}/configmaps".replaceAll("\\{format\\}", "json").replaceAll("\\{" + "namespace" + "\\}",apiInvoker.escape(namespace))

    val contentTypes = List("*/*")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (namespace == null) throw new Exception("Missing required parameter 'namespace' when calling Core_v1Api->createCoreV1NamespacedConfigMap")

    if (body == null) throw new Exception("Missing required parameter 'body' when calling Core_v1Api->createCoreV1NamespacedConfigMap")

    pretty.map(paramVal => queryParams += "pretty" -> paramVal.toString)
    

    var postBody: AnyRef = body

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "POST", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "", classOf[IoK8sApiCoreV1ConfigMap]).asInstanceOf[IoK8sApiCoreV1ConfigMap])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * 
   * create Endpoints
   * @param namespace object name and auth scope, such as for teams and projects 
   * @param body  
   * @param pretty If &#39;true&#39;, then the output is pretty printed. (optional)
   * @return IoK8sApiCoreV1Endpoints
   */
  def createCoreV1NamespacedEndpoints(namespace: String, body: IoK8sApiCoreV1Endpoints, pretty: Option[String] = None): Option[IoK8sApiCoreV1Endpoints] = {
    // create path and map variables
    val path = "/api/v1/namespaces/{namespace}/endpoints".replaceAll("\\{format\\}", "json").replaceAll("\\{" + "namespace" + "\\}",apiInvoker.escape(namespace))

    val contentTypes = List("*/*")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (namespace == null) throw new Exception("Missing required parameter 'namespace' when calling Core_v1Api->createCoreV1NamespacedEndpoints")

    if (body == null) throw new Exception("Missing required parameter 'body' when calling Core_v1Api->createCoreV1NamespacedEndpoints")

    pretty.map(paramVal => queryParams += "pretty" -> paramVal.toString)
    

    var postBody: AnyRef = body

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "POST", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "", classOf[IoK8sApiCoreV1Endpoints]).asInstanceOf[IoK8sApiCoreV1Endpoints])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * 
   * create an Event
   * @param namespace object name and auth scope, such as for teams and projects 
   * @param body  
   * @param pretty If &#39;true&#39;, then the output is pretty printed. (optional)
   * @return IoK8sApiCoreV1Event
   */
  def createCoreV1NamespacedEvent(namespace: String, body: IoK8sApiCoreV1Event, pretty: Option[String] = None): Option[IoK8sApiCoreV1Event] = {
    // create path and map variables
    val path = "/api/v1/namespaces/{namespace}/events".replaceAll("\\{format\\}", "json").replaceAll("\\{" + "namespace" + "\\}",apiInvoker.escape(namespace))

    val contentTypes = List("*/*")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (namespace == null) throw new Exception("Missing required parameter 'namespace' when calling Core_v1Api->createCoreV1NamespacedEvent")

    if (body == null) throw new Exception("Missing required parameter 'body' when calling Core_v1Api->createCoreV1NamespacedEvent")

    pretty.map(paramVal => queryParams += "pretty" -> paramVal.toString)
    

    var postBody: AnyRef = body

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "POST", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "", classOf[IoK8sApiCoreV1Event]).asInstanceOf[IoK8sApiCoreV1Event])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * 
   * create a LimitRange
   * @param namespace object name and auth scope, such as for teams and projects 
   * @param body  
   * @param pretty If &#39;true&#39;, then the output is pretty printed. (optional)
   * @return IoK8sApiCoreV1LimitRange
   */
  def createCoreV1NamespacedLimitRange(namespace: String, body: IoK8sApiCoreV1LimitRange, pretty: Option[String] = None): Option[IoK8sApiCoreV1LimitRange] = {
    // create path and map variables
    val path = "/api/v1/namespaces/{namespace}/limitranges".replaceAll("\\{format\\}", "json").replaceAll("\\{" + "namespace" + "\\}",apiInvoker.escape(namespace))

    val contentTypes = List("*/*")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (namespace == null) throw new Exception("Missing required parameter 'namespace' when calling Core_v1Api->createCoreV1NamespacedLimitRange")

    if (body == null) throw new Exception("Missing required parameter 'body' when calling Core_v1Api->createCoreV1NamespacedLimitRange")

    pretty.map(paramVal => queryParams += "pretty" -> paramVal.toString)
    

    var postBody: AnyRef = body

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "POST", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "", classOf[IoK8sApiCoreV1LimitRange]).asInstanceOf[IoK8sApiCoreV1LimitRange])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * 
   * create a PersistentVolumeClaim
   * @param namespace object name and auth scope, such as for teams and projects 
   * @param body  
   * @param pretty If &#39;true&#39;, then the output is pretty printed. (optional)
   * @return IoK8sApiCoreV1PersistentVolumeClaim
   */
  def createCoreV1NamespacedPersistentVolumeClaim(namespace: String, body: IoK8sApiCoreV1PersistentVolumeClaim, pretty: Option[String] = None): Option[IoK8sApiCoreV1PersistentVolumeClaim] = {
    // create path and map variables
    val path = "/api/v1/namespaces/{namespace}/persistentvolumeclaims".replaceAll("\\{format\\}", "json").replaceAll("\\{" + "namespace" + "\\}",apiInvoker.escape(namespace))

    val contentTypes = List("*/*")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (namespace == null) throw new Exception("Missing required parameter 'namespace' when calling Core_v1Api->createCoreV1NamespacedPersistentVolumeClaim")

    if (body == null) throw new Exception("Missing required parameter 'body' when calling Core_v1Api->createCoreV1NamespacedPersistentVolumeClaim")

    pretty.map(paramVal => queryParams += "pretty" -> paramVal.toString)
    

    var postBody: AnyRef = body

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "POST", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "", classOf[IoK8sApiCoreV1PersistentVolumeClaim]).asInstanceOf[IoK8sApiCoreV1PersistentVolumeClaim])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * 
   * create a Pod
   * @param namespace object name and auth scope, such as for teams and projects 
   * @param body  
   * @param pretty If &#39;true&#39;, then the output is pretty printed. (optional)
   * @return IoK8sApiCoreV1Pod
   */
  def createCoreV1NamespacedPod(namespace: String, body: IoK8sApiCoreV1Pod, pretty: Option[String] = None): Option[IoK8sApiCoreV1Pod] = {
    // create path and map variables
    val path = "/api/v1/namespaces/{namespace}/pods".replaceAll("\\{format\\}", "json").replaceAll("\\{" + "namespace" + "\\}",apiInvoker.escape(namespace))

    val contentTypes = List("*/*")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (namespace == null) throw new Exception("Missing required parameter 'namespace' when calling Core_v1Api->createCoreV1NamespacedPod")

    if (body == null) throw new Exception("Missing required parameter 'body' when calling Core_v1Api->createCoreV1NamespacedPod")

    pretty.map(paramVal => queryParams += "pretty" -> paramVal.toString)
    

    var postBody: AnyRef = body

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "POST", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "", classOf[IoK8sApiCoreV1Pod]).asInstanceOf[IoK8sApiCoreV1Pod])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * 
   * create binding of a Pod
   * @param name name of the Binding 
   * @param namespace object name and auth scope, such as for teams and projects 
   * @param body  
   * @param pretty If &#39;true&#39;, then the output is pretty printed. (optional)
   * @return IoK8sApiCoreV1Binding
   */
  def createCoreV1NamespacedPodBinding(name: String, namespace: String, body: IoK8sApiCoreV1Binding, pretty: Option[String] = None): Option[IoK8sApiCoreV1Binding] = {
    // create path and map variables
    val path = "/api/v1/namespaces/{namespace}/pods/{name}/binding".replaceAll("\\{format\\}", "json").replaceAll("\\{" + "name" + "\\}",apiInvoker.escape(name)).replaceAll("\\{" + "namespace" + "\\}",apiInvoker.escape(namespace))

    val contentTypes = List("*/*")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (name == null) throw new Exception("Missing required parameter 'name' when calling Core_v1Api->createCoreV1NamespacedPodBinding")

    if (namespace == null) throw new Exception("Missing required parameter 'namespace' when calling Core_v1Api->createCoreV1NamespacedPodBinding")

    if (body == null) throw new Exception("Missing required parameter 'body' when calling Core_v1Api->createCoreV1NamespacedPodBinding")

    pretty.map(paramVal => queryParams += "pretty" -> paramVal.toString)
    

    var postBody: AnyRef = body

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "POST", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "", classOf[IoK8sApiCoreV1Binding]).asInstanceOf[IoK8sApiCoreV1Binding])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * 
   * create eviction of a Pod
   * @param name name of the Eviction 
   * @param namespace object name and auth scope, such as for teams and projects 
   * @param body  
   * @param pretty If &#39;true&#39;, then the output is pretty printed. (optional)
   * @return IoK8sApiPolicyV1beta1Eviction
   */
  def createCoreV1NamespacedPodEviction(name: String, namespace: String, body: IoK8sApiPolicyV1beta1Eviction, pretty: Option[String] = None): Option[IoK8sApiPolicyV1beta1Eviction] = {
    // create path and map variables
    val path = "/api/v1/namespaces/{namespace}/pods/{name}/eviction".replaceAll("\\{format\\}", "json").replaceAll("\\{" + "name" + "\\}",apiInvoker.escape(name)).replaceAll("\\{" + "namespace" + "\\}",apiInvoker.escape(namespace))

    val contentTypes = List("*/*")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (name == null) throw new Exception("Missing required parameter 'name' when calling Core_v1Api->createCoreV1NamespacedPodEviction")

    if (namespace == null) throw new Exception("Missing required parameter 'namespace' when calling Core_v1Api->createCoreV1NamespacedPodEviction")

    if (body == null) throw new Exception("Missing required parameter 'body' when calling Core_v1Api->createCoreV1NamespacedPodEviction")

    pretty.map(paramVal => queryParams += "pretty" -> paramVal.toString)
    

    var postBody: AnyRef = body

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "POST", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "", classOf[IoK8sApiPolicyV1beta1Eviction]).asInstanceOf[IoK8sApiPolicyV1beta1Eviction])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * 
   * create a PodTemplate
   * @param namespace object name and auth scope, such as for teams and projects 
   * @param body  
   * @param pretty If &#39;true&#39;, then the output is pretty printed. (optional)
   * @return IoK8sApiCoreV1PodTemplate
   */
  def createCoreV1NamespacedPodTemplate(namespace: String, body: IoK8sApiCoreV1PodTemplate, pretty: Option[String] = None): Option[IoK8sApiCoreV1PodTemplate] = {
    // create path and map variables
    val path = "/api/v1/namespaces/{namespace}/podtemplates".replaceAll("\\{format\\}", "json").replaceAll("\\{" + "namespace" + "\\}",apiInvoker.escape(namespace))

    val contentTypes = List("*/*")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (namespace == null) throw new Exception("Missing required parameter 'namespace' when calling Core_v1Api->createCoreV1NamespacedPodTemplate")

    if (body == null) throw new Exception("Missing required parameter 'body' when calling Core_v1Api->createCoreV1NamespacedPodTemplate")

    pretty.map(paramVal => queryParams += "pretty" -> paramVal.toString)
    

    var postBody: AnyRef = body

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "POST", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "", classOf[IoK8sApiCoreV1PodTemplate]).asInstanceOf[IoK8sApiCoreV1PodTemplate])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * 
   * create a ReplicationController
   * @param namespace object name and auth scope, such as for teams and projects 
   * @param body  
   * @param pretty If &#39;true&#39;, then the output is pretty printed. (optional)
   * @return IoK8sApiCoreV1ReplicationController
   */
  def createCoreV1NamespacedReplicationController(namespace: String, body: IoK8sApiCoreV1ReplicationController, pretty: Option[String] = None): Option[IoK8sApiCoreV1ReplicationController] = {
    // create path and map variables
    val path = "/api/v1/namespaces/{namespace}/replicationcontrollers".replaceAll("\\{format\\}", "json").replaceAll("\\{" + "namespace" + "\\}",apiInvoker.escape(namespace))

    val contentTypes = List("*/*")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (namespace == null) throw new Exception("Missing required parameter 'namespace' when calling Core_v1Api->createCoreV1NamespacedReplicationController")

    if (body == null) throw new Exception("Missing required parameter 'body' when calling Core_v1Api->createCoreV1NamespacedReplicationController")

    pretty.map(paramVal => queryParams += "pretty" -> paramVal.toString)
    

    var postBody: AnyRef = body

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "POST", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "", classOf[IoK8sApiCoreV1ReplicationController]).asInstanceOf[IoK8sApiCoreV1ReplicationController])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * 
   * create a ResourceQuota
   * @param namespace object name and auth scope, such as for teams and projects 
   * @param body  
   * @param pretty If &#39;true&#39;, then the output is pretty printed. (optional)
   * @return IoK8sApiCoreV1ResourceQuota
   */
  def createCoreV1NamespacedResourceQuota(namespace: String, body: IoK8sApiCoreV1ResourceQuota, pretty: Option[String] = None): Option[IoK8sApiCoreV1ResourceQuota] = {
    // create path and map variables
    val path = "/api/v1/namespaces/{namespace}/resourcequotas".replaceAll("\\{format\\}", "json").replaceAll("\\{" + "namespace" + "\\}",apiInvoker.escape(namespace))

    val contentTypes = List("*/*")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (namespace == null) throw new Exception("Missing required parameter 'namespace' when calling Core_v1Api->createCoreV1NamespacedResourceQuota")

    if (body == null) throw new Exception("Missing required parameter 'body' when calling Core_v1Api->createCoreV1NamespacedResourceQuota")

    pretty.map(paramVal => queryParams += "pretty" -> paramVal.toString)
    

    var postBody: AnyRef = body

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "POST", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "", classOf[IoK8sApiCoreV1ResourceQuota]).asInstanceOf[IoK8sApiCoreV1ResourceQuota])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * 
   * create a Secret
   * @param namespace object name and auth scope, such as for teams and projects 
   * @param body  
   * @param pretty If &#39;true&#39;, then the output is pretty printed. (optional)
   * @return IoK8sApiCoreV1Secret
   */
  def createCoreV1NamespacedSecret(namespace: String, body: IoK8sApiCoreV1Secret, pretty: Option[String] = None): Option[IoK8sApiCoreV1Secret] = {
    // create path and map variables
    val path = "/api/v1/namespaces/{namespace}/secrets".replaceAll("\\{format\\}", "json").replaceAll("\\{" + "namespace" + "\\}",apiInvoker.escape(namespace))

    val contentTypes = List("*/*")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (namespace == null) throw new Exception("Missing required parameter 'namespace' when calling Core_v1Api->createCoreV1NamespacedSecret")

    if (body == null) throw new Exception("Missing required parameter 'body' when calling Core_v1Api->createCoreV1NamespacedSecret")

    pretty.map(paramVal => queryParams += "pretty" -> paramVal.toString)
    

    var postBody: AnyRef = body

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "POST", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "", classOf[IoK8sApiCoreV1Secret]).asInstanceOf[IoK8sApiCoreV1Secret])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * 
   * create a Service
   * @param namespace object name and auth scope, such as for teams and projects 
   * @param body  
   * @param pretty If &#39;true&#39;, then the output is pretty printed. (optional)
   * @return IoK8sApiCoreV1Service
   */
  def createCoreV1NamespacedService(namespace: String, body: IoK8sApiCoreV1Service, pretty: Option[String] = None): Option[IoK8sApiCoreV1Service] = {
    // create path and map variables
    val path = "/api/v1/namespaces/{namespace}/services".replaceAll("\\{format\\}", "json").replaceAll("\\{" + "namespace" + "\\}",apiInvoker.escape(namespace))

    val contentTypes = List("*/*")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (namespace == null) throw new Exception("Missing required parameter 'namespace' when calling Core_v1Api->createCoreV1NamespacedService")

    if (body == null) throw new Exception("Missing required parameter 'body' when calling Core_v1Api->createCoreV1NamespacedService")

    pretty.map(paramVal => queryParams += "pretty" -> paramVal.toString)
    

    var postBody: AnyRef = body

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "POST", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "", classOf[IoK8sApiCoreV1Service]).asInstanceOf[IoK8sApiCoreV1Service])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * 
   * create a ServiceAccount
   * @param namespace object name and auth scope, such as for teams and projects 
   * @param body  
   * @param pretty If &#39;true&#39;, then the output is pretty printed. (optional)
   * @return IoK8sApiCoreV1ServiceAccount
   */
  def createCoreV1NamespacedServiceAccount(namespace: String, body: IoK8sApiCoreV1ServiceAccount, pretty: Option[String] = None): Option[IoK8sApiCoreV1ServiceAccount] = {
    // create path and map variables
    val path = "/api/v1/namespaces/{namespace}/serviceaccounts".replaceAll("\\{format\\}", "json").replaceAll("\\{" + "namespace" + "\\}",apiInvoker.escape(namespace))

    val contentTypes = List("*/*")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (namespace == null) throw new Exception("Missing required parameter 'namespace' when calling Core_v1Api->createCoreV1NamespacedServiceAccount")

    if (body == null) throw new Exception("Missing required parameter 'body' when calling Core_v1Api->createCoreV1NamespacedServiceAccount")

    pretty.map(paramVal => queryParams += "pretty" -> paramVal.toString)
    

    var postBody: AnyRef = body

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "POST", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "", classOf[IoK8sApiCoreV1ServiceAccount]).asInstanceOf[IoK8sApiCoreV1ServiceAccount])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * 
   * create a Node
   * @param body  
   * @param pretty If &#39;true&#39;, then the output is pretty printed. (optional)
   * @return IoK8sApiCoreV1Node
   */
  def createCoreV1Node(body: IoK8sApiCoreV1Node, pretty: Option[String] = None): Option[IoK8sApiCoreV1Node] = {
    // create path and map variables
    val path = "/api/v1/nodes".replaceAll("\\{format\\}", "json")

    val contentTypes = List("*/*")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (body == null) throw new Exception("Missing required parameter 'body' when calling Core_v1Api->createCoreV1Node")

    pretty.map(paramVal => queryParams += "pretty" -> paramVal.toString)
    

    var postBody: AnyRef = body

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "POST", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "", classOf[IoK8sApiCoreV1Node]).asInstanceOf[IoK8sApiCoreV1Node])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * 
   * create a PersistentVolume
   * @param body  
   * @param pretty If &#39;true&#39;, then the output is pretty printed. (optional)
   * @return IoK8sApiCoreV1PersistentVolume
   */
  def createCoreV1PersistentVolume(body: IoK8sApiCoreV1PersistentVolume, pretty: Option[String] = None): Option[IoK8sApiCoreV1PersistentVolume] = {
    // create path and map variables
    val path = "/api/v1/persistentvolumes".replaceAll("\\{format\\}", "json")

    val contentTypes = List("*/*")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (body == null) throw new Exception("Missing required parameter 'body' when calling Core_v1Api->createCoreV1PersistentVolume")

    pretty.map(paramVal => queryParams += "pretty" -> paramVal.toString)
    

    var postBody: AnyRef = body

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "POST", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "", classOf[IoK8sApiCoreV1PersistentVolume]).asInstanceOf[IoK8sApiCoreV1PersistentVolume])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * 
   * delete collection of ConfigMap
   * @param namespace object name and auth scope, such as for teams and projects 
   * @param pretty If &#39;true&#39;, then the output is pretty printed. (optional)
   * @param continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. (optional)
   * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
   * @param includeUninitialized If true, partially initialized resources are included in the response. (optional)
   * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
   * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. (optional)
   * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
   * @param timeoutSeconds Timeout for the list/watch call. (optional)
   * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
   * @return IoK8sApimachineryPkgApisMetaV1Status
   */
  def deleteCoreV1CollectionNamespacedConfigMap(namespace: String, pretty: Option[String] = None, continue: Option[String] = None, fieldSelector: Option[String] = None, includeUninitialized: Option[Boolean] = None, labelSelector: Option[String] = None, limit: Option[Integer] = None, resourceVersion: Option[String] = None, timeoutSeconds: Option[Integer] = None, watch: Option[Boolean] = None): Option[IoK8sApimachineryPkgApisMetaV1Status] = {
    // create path and map variables
    val path = "/api/v1/namespaces/{namespace}/configmaps".replaceAll("\\{format\\}", "json").replaceAll("\\{" + "namespace" + "\\}",apiInvoker.escape(namespace))

    val contentTypes = List("*/*")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (namespace == null) throw new Exception("Missing required parameter 'namespace' when calling Core_v1Api->deleteCoreV1CollectionNamespacedConfigMap")

    pretty.map(paramVal => queryParams += "pretty" -> paramVal.toString)
    continue.map(paramVal => queryParams += "continue" -> paramVal.toString)
    fieldSelector.map(paramVal => queryParams += "fieldSelector" -> paramVal.toString)
    includeUninitialized.map(paramVal => queryParams += "includeUninitialized" -> paramVal.toString)
    labelSelector.map(paramVal => queryParams += "labelSelector" -> paramVal.toString)
    limit.map(paramVal => queryParams += "limit" -> paramVal.toString)
    resourceVersion.map(paramVal => queryParams += "resourceVersion" -> paramVal.toString)
    timeoutSeconds.map(paramVal => queryParams += "timeoutSeconds" -> paramVal.toString)
    watch.map(paramVal => queryParams += "watch" -> paramVal.toString)
    

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "DELETE", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "", classOf[IoK8sApimachineryPkgApisMetaV1Status]).asInstanceOf[IoK8sApimachineryPkgApisMetaV1Status])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * 
   * delete collection of Endpoints
   * @param namespace object name and auth scope, such as for teams and projects 
   * @param pretty If &#39;true&#39;, then the output is pretty printed. (optional)
   * @param continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. (optional)
   * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
   * @param includeUninitialized If true, partially initialized resources are included in the response. (optional)
   * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
   * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. (optional)
   * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
   * @param timeoutSeconds Timeout for the list/watch call. (optional)
   * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
   * @return IoK8sApimachineryPkgApisMetaV1Status
   */
  def deleteCoreV1CollectionNamespacedEndpoints(namespace: String, pretty: Option[String] = None, continue: Option[String] = None, fieldSelector: Option[String] = None, includeUninitialized: Option[Boolean] = None, labelSelector: Option[String] = None, limit: Option[Integer] = None, resourceVersion: Option[String] = None, timeoutSeconds: Option[Integer] = None, watch: Option[Boolean] = None): Option[IoK8sApimachineryPkgApisMetaV1Status] = {
    // create path and map variables
    val path = "/api/v1/namespaces/{namespace}/endpoints".replaceAll("\\{format\\}", "json").replaceAll("\\{" + "namespace" + "\\}",apiInvoker.escape(namespace))

    val contentTypes = List("*/*")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (namespace == null) throw new Exception("Missing required parameter 'namespace' when calling Core_v1Api->deleteCoreV1CollectionNamespacedEndpoints")

    pretty.map(paramVal => queryParams += "pretty" -> paramVal.toString)
    continue.map(paramVal => queryParams += "continue" -> paramVal.toString)
    fieldSelector.map(paramVal => queryParams += "fieldSelector" -> paramVal.toString)
    includeUninitialized.map(paramVal => queryParams += "includeUninitialized" -> paramVal.toString)
    labelSelector.map(paramVal => queryParams += "labelSelector" -> paramVal.toString)
    limit.map(paramVal => queryParams += "limit" -> paramVal.toString)
    resourceVersion.map(paramVal => queryParams += "resourceVersion" -> paramVal.toString)
    timeoutSeconds.map(paramVal => queryParams += "timeoutSeconds" -> paramVal.toString)
    watch.map(paramVal => queryParams += "watch" -> paramVal.toString)
    

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "DELETE", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "", classOf[IoK8sApimachineryPkgApisMetaV1Status]).asInstanceOf[IoK8sApimachineryPkgApisMetaV1Status])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * 
   * delete collection of Event
   * @param namespace object name and auth scope, such as for teams and projects 
   * @param pretty If &#39;true&#39;, then the output is pretty printed. (optional)
   * @param continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. (optional)
   * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
   * @param includeUninitialized If true, partially initialized resources are included in the response. (optional)
   * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
   * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. (optional)
   * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
   * @param timeoutSeconds Timeout for the list/watch call. (optional)
   * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
   * @return IoK8sApimachineryPkgApisMetaV1Status
   */
  def deleteCoreV1CollectionNamespacedEvent(namespace: String, pretty: Option[String] = None, continue: Option[String] = None, fieldSelector: Option[String] = None, includeUninitialized: Option[Boolean] = None, labelSelector: Option[String] = None, limit: Option[Integer] = None, resourceVersion: Option[String] = None, timeoutSeconds: Option[Integer] = None, watch: Option[Boolean] = None): Option[IoK8sApimachineryPkgApisMetaV1Status] = {
    // create path and map variables
    val path = "/api/v1/namespaces/{namespace}/events".replaceAll("\\{format\\}", "json").replaceAll("\\{" + "namespace" + "\\}",apiInvoker.escape(namespace))

    val contentTypes = List("*/*")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (namespace == null) throw new Exception("Missing required parameter 'namespace' when calling Core_v1Api->deleteCoreV1CollectionNamespacedEvent")

    pretty.map(paramVal => queryParams += "pretty" -> paramVal.toString)
    continue.map(paramVal => queryParams += "continue" -> paramVal.toString)
    fieldSelector.map(paramVal => queryParams += "fieldSelector" -> paramVal.toString)
    includeUninitialized.map(paramVal => queryParams += "includeUninitialized" -> paramVal.toString)
    labelSelector.map(paramVal => queryParams += "labelSelector" -> paramVal.toString)
    limit.map(paramVal => queryParams += "limit" -> paramVal.toString)
    resourceVersion.map(paramVal => queryParams += "resourceVersion" -> paramVal.toString)
    timeoutSeconds.map(paramVal => queryParams += "timeoutSeconds" -> paramVal.toString)
    watch.map(paramVal => queryParams += "watch" -> paramVal.toString)
    

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "DELETE", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "", classOf[IoK8sApimachineryPkgApisMetaV1Status]).asInstanceOf[IoK8sApimachineryPkgApisMetaV1Status])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * 
   * delete collection of LimitRange
   * @param namespace object name and auth scope, such as for teams and projects 
   * @param pretty If &#39;true&#39;, then the output is pretty printed. (optional)
   * @param continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. (optional)
   * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
   * @param includeUninitialized If true, partially initialized resources are included in the response. (optional)
   * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
   * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. (optional)
   * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
   * @param timeoutSeconds Timeout for the list/watch call. (optional)
   * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
   * @return IoK8sApimachineryPkgApisMetaV1Status
   */
  def deleteCoreV1CollectionNamespacedLimitRange(namespace: String, pretty: Option[String] = None, continue: Option[String] = None, fieldSelector: Option[String] = None, includeUninitialized: Option[Boolean] = None, labelSelector: Option[String] = None, limit: Option[Integer] = None, resourceVersion: Option[String] = None, timeoutSeconds: Option[Integer] = None, watch: Option[Boolean] = None): Option[IoK8sApimachineryPkgApisMetaV1Status] = {
    // create path and map variables
    val path = "/api/v1/namespaces/{namespace}/limitranges".replaceAll("\\{format\\}", "json").replaceAll("\\{" + "namespace" + "\\}",apiInvoker.escape(namespace))

    val contentTypes = List("*/*")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (namespace == null) throw new Exception("Missing required parameter 'namespace' when calling Core_v1Api->deleteCoreV1CollectionNamespacedLimitRange")

    pretty.map(paramVal => queryParams += "pretty" -> paramVal.toString)
    continue.map(paramVal => queryParams += "continue" -> paramVal.toString)
    fieldSelector.map(paramVal => queryParams += "fieldSelector" -> paramVal.toString)
    includeUninitialized.map(paramVal => queryParams += "includeUninitialized" -> paramVal.toString)
    labelSelector.map(paramVal => queryParams += "labelSelector" -> paramVal.toString)
    limit.map(paramVal => queryParams += "limit" -> paramVal.toString)
    resourceVersion.map(paramVal => queryParams += "resourceVersion" -> paramVal.toString)
    timeoutSeconds.map(paramVal => queryParams += "timeoutSeconds" -> paramVal.toString)
    watch.map(paramVal => queryParams += "watch" -> paramVal.toString)
    

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "DELETE", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "", classOf[IoK8sApimachineryPkgApisMetaV1Status]).asInstanceOf[IoK8sApimachineryPkgApisMetaV1Status])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * 
   * delete collection of PersistentVolumeClaim
   * @param namespace object name and auth scope, such as for teams and projects 
   * @param pretty If &#39;true&#39;, then the output is pretty printed. (optional)
   * @param continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. (optional)
   * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
   * @param includeUninitialized If true, partially initialized resources are included in the response. (optional)
   * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
   * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. (optional)
   * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
   * @param timeoutSeconds Timeout for the list/watch call. (optional)
   * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
   * @return IoK8sApimachineryPkgApisMetaV1Status
   */
  def deleteCoreV1CollectionNamespacedPersistentVolumeClaim(namespace: String, pretty: Option[String] = None, continue: Option[String] = None, fieldSelector: Option[String] = None, includeUninitialized: Option[Boolean] = None, labelSelector: Option[String] = None, limit: Option[Integer] = None, resourceVersion: Option[String] = None, timeoutSeconds: Option[Integer] = None, watch: Option[Boolean] = None): Option[IoK8sApimachineryPkgApisMetaV1Status] = {
    // create path and map variables
    val path = "/api/v1/namespaces/{namespace}/persistentvolumeclaims".replaceAll("\\{format\\}", "json").replaceAll("\\{" + "namespace" + "\\}",apiInvoker.escape(namespace))

    val contentTypes = List("*/*")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (namespace == null) throw new Exception("Missing required parameter 'namespace' when calling Core_v1Api->deleteCoreV1CollectionNamespacedPersistentVolumeClaim")

    pretty.map(paramVal => queryParams += "pretty" -> paramVal.toString)
    continue.map(paramVal => queryParams += "continue" -> paramVal.toString)
    fieldSelector.map(paramVal => queryParams += "fieldSelector" -> paramVal.toString)
    includeUninitialized.map(paramVal => queryParams += "includeUninitialized" -> paramVal.toString)
    labelSelector.map(paramVal => queryParams += "labelSelector" -> paramVal.toString)
    limit.map(paramVal => queryParams += "limit" -> paramVal.toString)
    resourceVersion.map(paramVal => queryParams += "resourceVersion" -> paramVal.toString)
    timeoutSeconds.map(paramVal => queryParams += "timeoutSeconds" -> paramVal.toString)
    watch.map(paramVal => queryParams += "watch" -> paramVal.toString)
    

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "DELETE", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "", classOf[IoK8sApimachineryPkgApisMetaV1Status]).asInstanceOf[IoK8sApimachineryPkgApisMetaV1Status])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * 
   * delete collection of Pod
   * @param namespace object name and auth scope, such as for teams and projects 
   * @param pretty If &#39;true&#39;, then the output is pretty printed. (optional)
   * @param continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. (optional)
   * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
   * @param includeUninitialized If true, partially initialized resources are included in the response. (optional)
   * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
   * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. (optional)
   * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
   * @param timeoutSeconds Timeout for the list/watch call. (optional)
   * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
   * @return IoK8sApimachineryPkgApisMetaV1Status
   */
  def deleteCoreV1CollectionNamespacedPod(namespace: String, pretty: Option[String] = None, continue: Option[String] = None, fieldSelector: Option[String] = None, includeUninitialized: Option[Boolean] = None, labelSelector: Option[String] = None, limit: Option[Integer] = None, resourceVersion: Option[String] = None, timeoutSeconds: Option[Integer] = None, watch: Option[Boolean] = None): Option[IoK8sApimachineryPkgApisMetaV1Status] = {
    // create path and map variables
    val path = "/api/v1/namespaces/{namespace}/pods".replaceAll("\\{format\\}", "json").replaceAll("\\{" + "namespace" + "\\}",apiInvoker.escape(namespace))

    val contentTypes = List("*/*")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (namespace == null) throw new Exception("Missing required parameter 'namespace' when calling Core_v1Api->deleteCoreV1CollectionNamespacedPod")

    pretty.map(paramVal => queryParams += "pretty" -> paramVal.toString)
    continue.map(paramVal => queryParams += "continue" -> paramVal.toString)
    fieldSelector.map(paramVal => queryParams += "fieldSelector" -> paramVal.toString)
    includeUninitialized.map(paramVal => queryParams += "includeUninitialized" -> paramVal.toString)
    labelSelector.map(paramVal => queryParams += "labelSelector" -> paramVal.toString)
    limit.map(paramVal => queryParams += "limit" -> paramVal.toString)
    resourceVersion.map(paramVal => queryParams += "resourceVersion" -> paramVal.toString)
    timeoutSeconds.map(paramVal => queryParams += "timeoutSeconds" -> paramVal.toString)
    watch.map(paramVal => queryParams += "watch" -> paramVal.toString)
    

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "DELETE", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "", classOf[IoK8sApimachineryPkgApisMetaV1Status]).asInstanceOf[IoK8sApimachineryPkgApisMetaV1Status])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * 
   * delete collection of PodTemplate
   * @param namespace object name and auth scope, such as for teams and projects 
   * @param pretty If &#39;true&#39;, then the output is pretty printed. (optional)
   * @param continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. (optional)
   * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
   * @param includeUninitialized If true, partially initialized resources are included in the response. (optional)
   * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
   * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. (optional)
   * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
   * @param timeoutSeconds Timeout for the list/watch call. (optional)
   * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
   * @return IoK8sApimachineryPkgApisMetaV1Status
   */
  def deleteCoreV1CollectionNamespacedPodTemplate(namespace: String, pretty: Option[String] = None, continue: Option[String] = None, fieldSelector: Option[String] = None, includeUninitialized: Option[Boolean] = None, labelSelector: Option[String] = None, limit: Option[Integer] = None, resourceVersion: Option[String] = None, timeoutSeconds: Option[Integer] = None, watch: Option[Boolean] = None): Option[IoK8sApimachineryPkgApisMetaV1Status] = {
    // create path and map variables
    val path = "/api/v1/namespaces/{namespace}/podtemplates".replaceAll("\\{format\\}", "json").replaceAll("\\{" + "namespace" + "\\}",apiInvoker.escape(namespace))

    val contentTypes = List("*/*")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (namespace == null) throw new Exception("Missing required parameter 'namespace' when calling Core_v1Api->deleteCoreV1CollectionNamespacedPodTemplate")

    pretty.map(paramVal => queryParams += "pretty" -> paramVal.toString)
    continue.map(paramVal => queryParams += "continue" -> paramVal.toString)
    fieldSelector.map(paramVal => queryParams += "fieldSelector" -> paramVal.toString)
    includeUninitialized.map(paramVal => queryParams += "includeUninitialized" -> paramVal.toString)
    labelSelector.map(paramVal => queryParams += "labelSelector" -> paramVal.toString)
    limit.map(paramVal => queryParams += "limit" -> paramVal.toString)
    resourceVersion.map(paramVal => queryParams += "resourceVersion" -> paramVal.toString)
    timeoutSeconds.map(paramVal => queryParams += "timeoutSeconds" -> paramVal.toString)
    watch.map(paramVal => queryParams += "watch" -> paramVal.toString)
    

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "DELETE", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "", classOf[IoK8sApimachineryPkgApisMetaV1Status]).asInstanceOf[IoK8sApimachineryPkgApisMetaV1Status])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * 
   * delete collection of ReplicationController
   * @param namespace object name and auth scope, such as for teams and projects 
   * @param pretty If &#39;true&#39;, then the output is pretty printed. (optional)
   * @param continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. (optional)
   * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
   * @param includeUninitialized If true, partially initialized resources are included in the response. (optional)
   * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
   * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. (optional)
   * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
   * @param timeoutSeconds Timeout for the list/watch call. (optional)
   * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
   * @return IoK8sApimachineryPkgApisMetaV1Status
   */
  def deleteCoreV1CollectionNamespacedReplicationController(namespace: String, pretty: Option[String] = None, continue: Option[String] = None, fieldSelector: Option[String] = None, includeUninitialized: Option[Boolean] = None, labelSelector: Option[String] = None, limit: Option[Integer] = None, resourceVersion: Option[String] = None, timeoutSeconds: Option[Integer] = None, watch: Option[Boolean] = None): Option[IoK8sApimachineryPkgApisMetaV1Status] = {
    // create path and map variables
    val path = "/api/v1/namespaces/{namespace}/replicationcontrollers".replaceAll("\\{format\\}", "json").replaceAll("\\{" + "namespace" + "\\}",apiInvoker.escape(namespace))

    val contentTypes = List("*/*")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (namespace == null) throw new Exception("Missing required parameter 'namespace' when calling Core_v1Api->deleteCoreV1CollectionNamespacedReplicationController")

    pretty.map(paramVal => queryParams += "pretty" -> paramVal.toString)
    continue.map(paramVal => queryParams += "continue" -> paramVal.toString)
    fieldSelector.map(paramVal => queryParams += "fieldSelector" -> paramVal.toString)
    includeUninitialized.map(paramVal => queryParams += "includeUninitialized" -> paramVal.toString)
    labelSelector.map(paramVal => queryParams += "labelSelector" -> paramVal.toString)
    limit.map(paramVal => queryParams += "limit" -> paramVal.toString)
    resourceVersion.map(paramVal => queryParams += "resourceVersion" -> paramVal.toString)
    timeoutSeconds.map(paramVal => queryParams += "timeoutSeconds" -> paramVal.toString)
    watch.map(paramVal => queryParams += "watch" -> paramVal.toString)
    

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "DELETE", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "", classOf[IoK8sApimachineryPkgApisMetaV1Status]).asInstanceOf[IoK8sApimachineryPkgApisMetaV1Status])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * 
   * delete collection of ResourceQuota
   * @param namespace object name and auth scope, such as for teams and projects 
   * @param pretty If &#39;true&#39;, then the output is pretty printed. (optional)
   * @param continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. (optional)
   * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
   * @param includeUninitialized If true, partially initialized resources are included in the response. (optional)
   * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
   * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. (optional)
   * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
   * @param timeoutSeconds Timeout for the list/watch call. (optional)
   * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
   * @return IoK8sApimachineryPkgApisMetaV1Status
   */
  def deleteCoreV1CollectionNamespacedResourceQuota(namespace: String, pretty: Option[String] = None, continue: Option[String] = None, fieldSelector: Option[String] = None, includeUninitialized: Option[Boolean] = None, labelSelector: Option[String] = None, limit: Option[Integer] = None, resourceVersion: Option[String] = None, timeoutSeconds: Option[Integer] = None, watch: Option[Boolean] = None): Option[IoK8sApimachineryPkgApisMetaV1Status] = {
    // create path and map variables
    val path = "/api/v1/namespaces/{namespace}/resourcequotas".replaceAll("\\{format\\}", "json").replaceAll("\\{" + "namespace" + "\\}",apiInvoker.escape(namespace))

    val contentTypes = List("*/*")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (namespace == null) throw new Exception("Missing required parameter 'namespace' when calling Core_v1Api->deleteCoreV1CollectionNamespacedResourceQuota")

    pretty.map(paramVal => queryParams += "pretty" -> paramVal.toString)
    continue.map(paramVal => queryParams += "continue" -> paramVal.toString)
    fieldSelector.map(paramVal => queryParams += "fieldSelector" -> paramVal.toString)
    includeUninitialized.map(paramVal => queryParams += "includeUninitialized" -> paramVal.toString)
    labelSelector.map(paramVal => queryParams += "labelSelector" -> paramVal.toString)
    limit.map(paramVal => queryParams += "limit" -> paramVal.toString)
    resourceVersion.map(paramVal => queryParams += "resourceVersion" -> paramVal.toString)
    timeoutSeconds.map(paramVal => queryParams += "timeoutSeconds" -> paramVal.toString)
    watch.map(paramVal => queryParams += "watch" -> paramVal.toString)
    

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "DELETE", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "", classOf[IoK8sApimachineryPkgApisMetaV1Status]).asInstanceOf[IoK8sApimachineryPkgApisMetaV1Status])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * 
   * delete collection of Secret
   * @param namespace object name and auth scope, such as for teams and projects 
   * @param pretty If &#39;true&#39;, then the output is pretty printed. (optional)
   * @param continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. (optional)
   * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
   * @param includeUninitialized If true, partially initialized resources are included in the response. (optional)
   * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
   * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. (optional)
   * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
   * @param timeoutSeconds Timeout for the list/watch call. (optional)
   * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
   * @return IoK8sApimachineryPkgApisMetaV1Status
   */
  def deleteCoreV1CollectionNamespacedSecret(namespace: String, pretty: Option[String] = None, continue: Option[String] = None, fieldSelector: Option[String] = None, includeUninitialized: Option[Boolean] = None, labelSelector: Option[String] = None, limit: Option[Integer] = None, resourceVersion: Option[String] = None, timeoutSeconds: Option[Integer] = None, watch: Option[Boolean] = None): Option[IoK8sApimachineryPkgApisMetaV1Status] = {
    // create path and map variables
    val path = "/api/v1/namespaces/{namespace}/secrets".replaceAll("\\{format\\}", "json").replaceAll("\\{" + "namespace" + "\\}",apiInvoker.escape(namespace))

    val contentTypes = List("*/*")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (namespace == null) throw new Exception("Missing required parameter 'namespace' when calling Core_v1Api->deleteCoreV1CollectionNamespacedSecret")

    pretty.map(paramVal => queryParams += "pretty" -> paramVal.toString)
    continue.map(paramVal => queryParams += "continue" -> paramVal.toString)
    fieldSelector.map(paramVal => queryParams += "fieldSelector" -> paramVal.toString)
    includeUninitialized.map(paramVal => queryParams += "includeUninitialized" -> paramVal.toString)
    labelSelector.map(paramVal => queryParams += "labelSelector" -> paramVal.toString)
    limit.map(paramVal => queryParams += "limit" -> paramVal.toString)
    resourceVersion.map(paramVal => queryParams += "resourceVersion" -> paramVal.toString)
    timeoutSeconds.map(paramVal => queryParams += "timeoutSeconds" -> paramVal.toString)
    watch.map(paramVal => queryParams += "watch" -> paramVal.toString)
    

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "DELETE", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "", classOf[IoK8sApimachineryPkgApisMetaV1Status]).asInstanceOf[IoK8sApimachineryPkgApisMetaV1Status])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * 
   * delete collection of ServiceAccount
   * @param namespace object name and auth scope, such as for teams and projects 
   * @param pretty If &#39;true&#39;, then the output is pretty printed. (optional)
   * @param continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. (optional)
   * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
   * @param includeUninitialized If true, partially initialized resources are included in the response. (optional)
   * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
   * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. (optional)
   * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
   * @param timeoutSeconds Timeout for the list/watch call. (optional)
   * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
   * @return IoK8sApimachineryPkgApisMetaV1Status
   */
  def deleteCoreV1CollectionNamespacedServiceAccount(namespace: String, pretty: Option[String] = None, continue: Option[String] = None, fieldSelector: Option[String] = None, includeUninitialized: Option[Boolean] = None, labelSelector: Option[String] = None, limit: Option[Integer] = None, resourceVersion: Option[String] = None, timeoutSeconds: Option[Integer] = None, watch: Option[Boolean] = None): Option[IoK8sApimachineryPkgApisMetaV1Status] = {
    // create path and map variables
    val path = "/api/v1/namespaces/{namespace}/serviceaccounts".replaceAll("\\{format\\}", "json").replaceAll("\\{" + "namespace" + "\\}",apiInvoker.escape(namespace))

    val contentTypes = List("*/*")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (namespace == null) throw new Exception("Missing required parameter 'namespace' when calling Core_v1Api->deleteCoreV1CollectionNamespacedServiceAccount")

    pretty.map(paramVal => queryParams += "pretty" -> paramVal.toString)
    continue.map(paramVal => queryParams += "continue" -> paramVal.toString)
    fieldSelector.map(paramVal => queryParams += "fieldSelector" -> paramVal.toString)
    includeUninitialized.map(paramVal => queryParams += "includeUninitialized" -> paramVal.toString)
    labelSelector.map(paramVal => queryParams += "labelSelector" -> paramVal.toString)
    limit.map(paramVal => queryParams += "limit" -> paramVal.toString)
    resourceVersion.map(paramVal => queryParams += "resourceVersion" -> paramVal.toString)
    timeoutSeconds.map(paramVal => queryParams += "timeoutSeconds" -> paramVal.toString)
    watch.map(paramVal => queryParams += "watch" -> paramVal.toString)
    

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "DELETE", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "", classOf[IoK8sApimachineryPkgApisMetaV1Status]).asInstanceOf[IoK8sApimachineryPkgApisMetaV1Status])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * 
   * delete collection of Node
   * @param pretty If &#39;true&#39;, then the output is pretty printed. (optional)
   * @param continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. (optional)
   * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
   * @param includeUninitialized If true, partially initialized resources are included in the response. (optional)
   * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
   * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. (optional)
   * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
   * @param timeoutSeconds Timeout for the list/watch call. (optional)
   * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
   * @return IoK8sApimachineryPkgApisMetaV1Status
   */
  def deleteCoreV1CollectionNode(pretty: Option[String] = None, continue: Option[String] = None, fieldSelector: Option[String] = None, includeUninitialized: Option[Boolean] = None, labelSelector: Option[String] = None, limit: Option[Integer] = None, resourceVersion: Option[String] = None, timeoutSeconds: Option[Integer] = None, watch: Option[Boolean] = None): Option[IoK8sApimachineryPkgApisMetaV1Status] = {
    // create path and map variables
    val path = "/api/v1/nodes".replaceAll("\\{format\\}", "json")

    val contentTypes = List("*/*")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    pretty.map(paramVal => queryParams += "pretty" -> paramVal.toString)
    continue.map(paramVal => queryParams += "continue" -> paramVal.toString)
    fieldSelector.map(paramVal => queryParams += "fieldSelector" -> paramVal.toString)
    includeUninitialized.map(paramVal => queryParams += "includeUninitialized" -> paramVal.toString)
    labelSelector.map(paramVal => queryParams += "labelSelector" -> paramVal.toString)
    limit.map(paramVal => queryParams += "limit" -> paramVal.toString)
    resourceVersion.map(paramVal => queryParams += "resourceVersion" -> paramVal.toString)
    timeoutSeconds.map(paramVal => queryParams += "timeoutSeconds" -> paramVal.toString)
    watch.map(paramVal => queryParams += "watch" -> paramVal.toString)
    

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "DELETE", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "", classOf[IoK8sApimachineryPkgApisMetaV1Status]).asInstanceOf[IoK8sApimachineryPkgApisMetaV1Status])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * 
   * delete collection of PersistentVolume
   * @param pretty If &#39;true&#39;, then the output is pretty printed. (optional)
   * @param continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. (optional)
   * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
   * @param includeUninitialized If true, partially initialized resources are included in the response. (optional)
   * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
   * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. (optional)
   * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
   * @param timeoutSeconds Timeout for the list/watch call. (optional)
   * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
   * @return IoK8sApimachineryPkgApisMetaV1Status
   */
  def deleteCoreV1CollectionPersistentVolume(pretty: Option[String] = None, continue: Option[String] = None, fieldSelector: Option[String] = None, includeUninitialized: Option[Boolean] = None, labelSelector: Option[String] = None, limit: Option[Integer] = None, resourceVersion: Option[String] = None, timeoutSeconds: Option[Integer] = None, watch: Option[Boolean] = None): Option[IoK8sApimachineryPkgApisMetaV1Status] = {
    // create path and map variables
    val path = "/api/v1/persistentvolumes".replaceAll("\\{format\\}", "json")

    val contentTypes = List("*/*")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    pretty.map(paramVal => queryParams += "pretty" -> paramVal.toString)
    continue.map(paramVal => queryParams += "continue" -> paramVal.toString)
    fieldSelector.map(paramVal => queryParams += "fieldSelector" -> paramVal.toString)
    includeUninitialized.map(paramVal => queryParams += "includeUninitialized" -> paramVal.toString)
    labelSelector.map(paramVal => queryParams += "labelSelector" -> paramVal.toString)
    limit.map(paramVal => queryParams += "limit" -> paramVal.toString)
    resourceVersion.map(paramVal => queryParams += "resourceVersion" -> paramVal.toString)
    timeoutSeconds.map(paramVal => queryParams += "timeoutSeconds" -> paramVal.toString)
    watch.map(paramVal => queryParams += "watch" -> paramVal.toString)
    

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "DELETE", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "", classOf[IoK8sApimachineryPkgApisMetaV1Status]).asInstanceOf[IoK8sApimachineryPkgApisMetaV1Status])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * 
   * delete a Namespace
   * @param name name of the Namespace 
   * @param body  
   * @param pretty If &#39;true&#39;, then the output is pretty printed. (optional)
   * @param gracePeriodSeconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)
   * @param orphanDependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)
   * @param propagationPolicy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. (optional)
   * @return IoK8sApimachineryPkgApisMetaV1Status
   */
  def deleteCoreV1Namespace(name: String, body: IoK8sApimachineryPkgApisMetaV1DeleteOptions, pretty: Option[String] = None, gracePeriodSeconds: Option[Integer] = None, orphanDependents: Option[Boolean] = None, propagationPolicy: Option[String] = None): Option[IoK8sApimachineryPkgApisMetaV1Status] = {
    // create path and map variables
    val path = "/api/v1/namespaces/{name}".replaceAll("\\{format\\}", "json").replaceAll("\\{" + "name" + "\\}",apiInvoker.escape(name))

    val contentTypes = List("*/*")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (name == null) throw new Exception("Missing required parameter 'name' when calling Core_v1Api->deleteCoreV1Namespace")

    if (body == null) throw new Exception("Missing required parameter 'body' when calling Core_v1Api->deleteCoreV1Namespace")

    pretty.map(paramVal => queryParams += "pretty" -> paramVal.toString)
    gracePeriodSeconds.map(paramVal => queryParams += "gracePeriodSeconds" -> paramVal.toString)
    orphanDependents.map(paramVal => queryParams += "orphanDependents" -> paramVal.toString)
    propagationPolicy.map(paramVal => queryParams += "propagationPolicy" -> paramVal.toString)
    

    var postBody: AnyRef = body

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "DELETE", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "", classOf[IoK8sApimachineryPkgApisMetaV1Status]).asInstanceOf[IoK8sApimachineryPkgApisMetaV1Status])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * 
   * delete a ConfigMap
   * @param name name of the ConfigMap 
   * @param namespace object name and auth scope, such as for teams and projects 
   * @param body  
   * @param pretty If &#39;true&#39;, then the output is pretty printed. (optional)
   * @param gracePeriodSeconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)
   * @param orphanDependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)
   * @param propagationPolicy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. (optional)
   * @return IoK8sApimachineryPkgApisMetaV1Status
   */
  def deleteCoreV1NamespacedConfigMap(name: String, namespace: String, body: IoK8sApimachineryPkgApisMetaV1DeleteOptions, pretty: Option[String] = None, gracePeriodSeconds: Option[Integer] = None, orphanDependents: Option[Boolean] = None, propagationPolicy: Option[String] = None): Option[IoK8sApimachineryPkgApisMetaV1Status] = {
    // create path and map variables
    val path = "/api/v1/namespaces/{namespace}/configmaps/{name}".replaceAll("\\{format\\}", "json").replaceAll("\\{" + "name" + "\\}",apiInvoker.escape(name)).replaceAll("\\{" + "namespace" + "\\}",apiInvoker.escape(namespace))

    val contentTypes = List("*/*")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (name == null) throw new Exception("Missing required parameter 'name' when calling Core_v1Api->deleteCoreV1NamespacedConfigMap")

    if (namespace == null) throw new Exception("Missing required parameter 'namespace' when calling Core_v1Api->deleteCoreV1NamespacedConfigMap")

    if (body == null) throw new Exception("Missing required parameter 'body' when calling Core_v1Api->deleteCoreV1NamespacedConfigMap")

    pretty.map(paramVal => queryParams += "pretty" -> paramVal.toString)
    gracePeriodSeconds.map(paramVal => queryParams += "gracePeriodSeconds" -> paramVal.toString)
    orphanDependents.map(paramVal => queryParams += "orphanDependents" -> paramVal.toString)
    propagationPolicy.map(paramVal => queryParams += "propagationPolicy" -> paramVal.toString)
    

    var postBody: AnyRef = body

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "DELETE", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "", classOf[IoK8sApimachineryPkgApisMetaV1Status]).asInstanceOf[IoK8sApimachineryPkgApisMetaV1Status])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * 
   * delete Endpoints
   * @param name name of the Endpoints 
   * @param namespace object name and auth scope, such as for teams and projects 
   * @param body  
   * @param pretty If &#39;true&#39;, then the output is pretty printed. (optional)
   * @param gracePeriodSeconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)
   * @param orphanDependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)
   * @param propagationPolicy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. (optional)
   * @return IoK8sApimachineryPkgApisMetaV1Status
   */
  def deleteCoreV1NamespacedEndpoints(name: String, namespace: String, body: IoK8sApimachineryPkgApisMetaV1DeleteOptions, pretty: Option[String] = None, gracePeriodSeconds: Option[Integer] = None, orphanDependents: Option[Boolean] = None, propagationPolicy: Option[String] = None): Option[IoK8sApimachineryPkgApisMetaV1Status] = {
    // create path and map variables
    val path = "/api/v1/namespaces/{namespace}/endpoints/{name}".replaceAll("\\{format\\}", "json").replaceAll("\\{" + "name" + "\\}",apiInvoker.escape(name)).replaceAll("\\{" + "namespace" + "\\}",apiInvoker.escape(namespace))

    val contentTypes = List("*/*")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (name == null) throw new Exception("Missing required parameter 'name' when calling Core_v1Api->deleteCoreV1NamespacedEndpoints")

    if (namespace == null) throw new Exception("Missing required parameter 'namespace' when calling Core_v1Api->deleteCoreV1NamespacedEndpoints")

    if (body == null) throw new Exception("Missing required parameter 'body' when calling Core_v1Api->deleteCoreV1NamespacedEndpoints")

    pretty.map(paramVal => queryParams += "pretty" -> paramVal.toString)
    gracePeriodSeconds.map(paramVal => queryParams += "gracePeriodSeconds" -> paramVal.toString)
    orphanDependents.map(paramVal => queryParams += "orphanDependents" -> paramVal.toString)
    propagationPolicy.map(paramVal => queryParams += "propagationPolicy" -> paramVal.toString)
    

    var postBody: AnyRef = body

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "DELETE", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "", classOf[IoK8sApimachineryPkgApisMetaV1Status]).asInstanceOf[IoK8sApimachineryPkgApisMetaV1Status])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * 
   * delete an Event
   * @param name name of the Event 
   * @param namespace object name and auth scope, such as for teams and projects 
   * @param body  
   * @param pretty If &#39;true&#39;, then the output is pretty printed. (optional)
   * @param gracePeriodSeconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)
   * @param orphanDependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)
   * @param propagationPolicy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. (optional)
   * @return IoK8sApimachineryPkgApisMetaV1Status
   */
  def deleteCoreV1NamespacedEvent(name: String, namespace: String, body: IoK8sApimachineryPkgApisMetaV1DeleteOptions, pretty: Option[String] = None, gracePeriodSeconds: Option[Integer] = None, orphanDependents: Option[Boolean] = None, propagationPolicy: Option[String] = None): Option[IoK8sApimachineryPkgApisMetaV1Status] = {
    // create path and map variables
    val path = "/api/v1/namespaces/{namespace}/events/{name}".replaceAll("\\{format\\}", "json").replaceAll("\\{" + "name" + "\\}",apiInvoker.escape(name)).replaceAll("\\{" + "namespace" + "\\}",apiInvoker.escape(namespace))

    val contentTypes = List("*/*")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (name == null) throw new Exception("Missing required parameter 'name' when calling Core_v1Api->deleteCoreV1NamespacedEvent")

    if (namespace == null) throw new Exception("Missing required parameter 'namespace' when calling Core_v1Api->deleteCoreV1NamespacedEvent")

    if (body == null) throw new Exception("Missing required parameter 'body' when calling Core_v1Api->deleteCoreV1NamespacedEvent")

    pretty.map(paramVal => queryParams += "pretty" -> paramVal.toString)
    gracePeriodSeconds.map(paramVal => queryParams += "gracePeriodSeconds" -> paramVal.toString)
    orphanDependents.map(paramVal => queryParams += "orphanDependents" -> paramVal.toString)
    propagationPolicy.map(paramVal => queryParams += "propagationPolicy" -> paramVal.toString)
    

    var postBody: AnyRef = body

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "DELETE", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "", classOf[IoK8sApimachineryPkgApisMetaV1Status]).asInstanceOf[IoK8sApimachineryPkgApisMetaV1Status])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * 
   * delete a LimitRange
   * @param name name of the LimitRange 
   * @param namespace object name and auth scope, such as for teams and projects 
   * @param body  
   * @param pretty If &#39;true&#39;, then the output is pretty printed. (optional)
   * @param gracePeriodSeconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)
   * @param orphanDependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)
   * @param propagationPolicy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. (optional)
   * @return IoK8sApimachineryPkgApisMetaV1Status
   */
  def deleteCoreV1NamespacedLimitRange(name: String, namespace: String, body: IoK8sApimachineryPkgApisMetaV1DeleteOptions, pretty: Option[String] = None, gracePeriodSeconds: Option[Integer] = None, orphanDependents: Option[Boolean] = None, propagationPolicy: Option[String] = None): Option[IoK8sApimachineryPkgApisMetaV1Status] = {
    // create path and map variables
    val path = "/api/v1/namespaces/{namespace}/limitranges/{name}".replaceAll("\\{format\\}", "json").replaceAll("\\{" + "name" + "\\}",apiInvoker.escape(name)).replaceAll("\\{" + "namespace" + "\\}",apiInvoker.escape(namespace))

    val contentTypes = List("*/*")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (name == null) throw new Exception("Missing required parameter 'name' when calling Core_v1Api->deleteCoreV1NamespacedLimitRange")

    if (namespace == null) throw new Exception("Missing required parameter 'namespace' when calling Core_v1Api->deleteCoreV1NamespacedLimitRange")

    if (body == null) throw new Exception("Missing required parameter 'body' when calling Core_v1Api->deleteCoreV1NamespacedLimitRange")

    pretty.map(paramVal => queryParams += "pretty" -> paramVal.toString)
    gracePeriodSeconds.map(paramVal => queryParams += "gracePeriodSeconds" -> paramVal.toString)
    orphanDependents.map(paramVal => queryParams += "orphanDependents" -> paramVal.toString)
    propagationPolicy.map(paramVal => queryParams += "propagationPolicy" -> paramVal.toString)
    

    var postBody: AnyRef = body

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "DELETE", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "", classOf[IoK8sApimachineryPkgApisMetaV1Status]).asInstanceOf[IoK8sApimachineryPkgApisMetaV1Status])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * 
   * delete a PersistentVolumeClaim
   * @param name name of the PersistentVolumeClaim 
   * @param namespace object name and auth scope, such as for teams and projects 
   * @param body  
   * @param pretty If &#39;true&#39;, then the output is pretty printed. (optional)
   * @param gracePeriodSeconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)
   * @param orphanDependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)
   * @param propagationPolicy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. (optional)
   * @return IoK8sApimachineryPkgApisMetaV1Status
   */
  def deleteCoreV1NamespacedPersistentVolumeClaim(name: String, namespace: String, body: IoK8sApimachineryPkgApisMetaV1DeleteOptions, pretty: Option[String] = None, gracePeriodSeconds: Option[Integer] = None, orphanDependents: Option[Boolean] = None, propagationPolicy: Option[String] = None): Option[IoK8sApimachineryPkgApisMetaV1Status] = {
    // create path and map variables
    val path = "/api/v1/namespaces/{namespace}/persistentvolumeclaims/{name}".replaceAll("\\{format\\}", "json").replaceAll("\\{" + "name" + "\\}",apiInvoker.escape(name)).replaceAll("\\{" + "namespace" + "\\}",apiInvoker.escape(namespace))

    val contentTypes = List("*/*")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (name == null) throw new Exception("Missing required parameter 'name' when calling Core_v1Api->deleteCoreV1NamespacedPersistentVolumeClaim")

    if (namespace == null) throw new Exception("Missing required parameter 'namespace' when calling Core_v1Api->deleteCoreV1NamespacedPersistentVolumeClaim")

    if (body == null) throw new Exception("Missing required parameter 'body' when calling Core_v1Api->deleteCoreV1NamespacedPersistentVolumeClaim")

    pretty.map(paramVal => queryParams += "pretty" -> paramVal.toString)
    gracePeriodSeconds.map(paramVal => queryParams += "gracePeriodSeconds" -> paramVal.toString)
    orphanDependents.map(paramVal => queryParams += "orphanDependents" -> paramVal.toString)
    propagationPolicy.map(paramVal => queryParams += "propagationPolicy" -> paramVal.toString)
    

    var postBody: AnyRef = body

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "DELETE", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "", classOf[IoK8sApimachineryPkgApisMetaV1Status]).asInstanceOf[IoK8sApimachineryPkgApisMetaV1Status])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * 
   * delete a Pod
   * @param name name of the Pod 
   * @param namespace object name and auth scope, such as for teams and projects 
   * @param body  
   * @param pretty If &#39;true&#39;, then the output is pretty printed. (optional)
   * @param gracePeriodSeconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)
   * @param orphanDependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)
   * @param propagationPolicy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. (optional)
   * @return IoK8sApimachineryPkgApisMetaV1Status
   */
  def deleteCoreV1NamespacedPod(name: String, namespace: String, body: IoK8sApimachineryPkgApisMetaV1DeleteOptions, pretty: Option[String] = None, gracePeriodSeconds: Option[Integer] = None, orphanDependents: Option[Boolean] = None, propagationPolicy: Option[String] = None): Option[IoK8sApimachineryPkgApisMetaV1Status] = {
    // create path and map variables
    val path = "/api/v1/namespaces/{namespace}/pods/{name}".replaceAll("\\{format\\}", "json").replaceAll("\\{" + "name" + "\\}",apiInvoker.escape(name)).replaceAll("\\{" + "namespace" + "\\}",apiInvoker.escape(namespace))

    val contentTypes = List("*/*")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (name == null) throw new Exception("Missing required parameter 'name' when calling Core_v1Api->deleteCoreV1NamespacedPod")

    if (namespace == null) throw new Exception("Missing required parameter 'namespace' when calling Core_v1Api->deleteCoreV1NamespacedPod")

    if (body == null) throw new Exception("Missing required parameter 'body' when calling Core_v1Api->deleteCoreV1NamespacedPod")

    pretty.map(paramVal => queryParams += "pretty" -> paramVal.toString)
    gracePeriodSeconds.map(paramVal => queryParams += "gracePeriodSeconds" -> paramVal.toString)
    orphanDependents.map(paramVal => queryParams += "orphanDependents" -> paramVal.toString)
    propagationPolicy.map(paramVal => queryParams += "propagationPolicy" -> paramVal.toString)
    

    var postBody: AnyRef = body

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "DELETE", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "", classOf[IoK8sApimachineryPkgApisMetaV1Status]).asInstanceOf[IoK8sApimachineryPkgApisMetaV1Status])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * 
   * delete a PodTemplate
   * @param name name of the PodTemplate 
   * @param namespace object name and auth scope, such as for teams and projects 
   * @param body  
   * @param pretty If &#39;true&#39;, then the output is pretty printed. (optional)
   * @param gracePeriodSeconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)
   * @param orphanDependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)
   * @param propagationPolicy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. (optional)
   * @return IoK8sApimachineryPkgApisMetaV1Status
   */
  def deleteCoreV1NamespacedPodTemplate(name: String, namespace: String, body: IoK8sApimachineryPkgApisMetaV1DeleteOptions, pretty: Option[String] = None, gracePeriodSeconds: Option[Integer] = None, orphanDependents: Option[Boolean] = None, propagationPolicy: Option[String] = None): Option[IoK8sApimachineryPkgApisMetaV1Status] = {
    // create path and map variables
    val path = "/api/v1/namespaces/{namespace}/podtemplates/{name}".replaceAll("\\{format\\}", "json").replaceAll("\\{" + "name" + "\\}",apiInvoker.escape(name)).replaceAll("\\{" + "namespace" + "\\}",apiInvoker.escape(namespace))

    val contentTypes = List("*/*")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (name == null) throw new Exception("Missing required parameter 'name' when calling Core_v1Api->deleteCoreV1NamespacedPodTemplate")

    if (namespace == null) throw new Exception("Missing required parameter 'namespace' when calling Core_v1Api->deleteCoreV1NamespacedPodTemplate")

    if (body == null) throw new Exception("Missing required parameter 'body' when calling Core_v1Api->deleteCoreV1NamespacedPodTemplate")

    pretty.map(paramVal => queryParams += "pretty" -> paramVal.toString)
    gracePeriodSeconds.map(paramVal => queryParams += "gracePeriodSeconds" -> paramVal.toString)
    orphanDependents.map(paramVal => queryParams += "orphanDependents" -> paramVal.toString)
    propagationPolicy.map(paramVal => queryParams += "propagationPolicy" -> paramVal.toString)
    

    var postBody: AnyRef = body

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "DELETE", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "", classOf[IoK8sApimachineryPkgApisMetaV1Status]).asInstanceOf[IoK8sApimachineryPkgApisMetaV1Status])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * 
   * delete a ReplicationController
   * @param name name of the ReplicationController 
   * @param namespace object name and auth scope, such as for teams and projects 
   * @param body  
   * @param pretty If &#39;true&#39;, then the output is pretty printed. (optional)
   * @param gracePeriodSeconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)
   * @param orphanDependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)
   * @param propagationPolicy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. (optional)
   * @return IoK8sApimachineryPkgApisMetaV1Status
   */
  def deleteCoreV1NamespacedReplicationController(name: String, namespace: String, body: IoK8sApimachineryPkgApisMetaV1DeleteOptions, pretty: Option[String] = None, gracePeriodSeconds: Option[Integer] = None, orphanDependents: Option[Boolean] = None, propagationPolicy: Option[String] = None): Option[IoK8sApimachineryPkgApisMetaV1Status] = {
    // create path and map variables
    val path = "/api/v1/namespaces/{namespace}/replicationcontrollers/{name}".replaceAll("\\{format\\}", "json").replaceAll("\\{" + "name" + "\\}",apiInvoker.escape(name)).replaceAll("\\{" + "namespace" + "\\}",apiInvoker.escape(namespace))

    val contentTypes = List("*/*")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (name == null) throw new Exception("Missing required parameter 'name' when calling Core_v1Api->deleteCoreV1NamespacedReplicationController")

    if (namespace == null) throw new Exception("Missing required parameter 'namespace' when calling Core_v1Api->deleteCoreV1NamespacedReplicationController")

    if (body == null) throw new Exception("Missing required parameter 'body' when calling Core_v1Api->deleteCoreV1NamespacedReplicationController")

    pretty.map(paramVal => queryParams += "pretty" -> paramVal.toString)
    gracePeriodSeconds.map(paramVal => queryParams += "gracePeriodSeconds" -> paramVal.toString)
    orphanDependents.map(paramVal => queryParams += "orphanDependents" -> paramVal.toString)
    propagationPolicy.map(paramVal => queryParams += "propagationPolicy" -> paramVal.toString)
    

    var postBody: AnyRef = body

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "DELETE", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "", classOf[IoK8sApimachineryPkgApisMetaV1Status]).asInstanceOf[IoK8sApimachineryPkgApisMetaV1Status])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * 
   * delete a ResourceQuota
   * @param name name of the ResourceQuota 
   * @param namespace object name and auth scope, such as for teams and projects 
   * @param body  
   * @param pretty If &#39;true&#39;, then the output is pretty printed. (optional)
   * @param gracePeriodSeconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)
   * @param orphanDependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)
   * @param propagationPolicy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. (optional)
   * @return IoK8sApimachineryPkgApisMetaV1Status
   */
  def deleteCoreV1NamespacedResourceQuota(name: String, namespace: String, body: IoK8sApimachineryPkgApisMetaV1DeleteOptions, pretty: Option[String] = None, gracePeriodSeconds: Option[Integer] = None, orphanDependents: Option[Boolean] = None, propagationPolicy: Option[String] = None): Option[IoK8sApimachineryPkgApisMetaV1Status] = {
    // create path and map variables
    val path = "/api/v1/namespaces/{namespace}/resourcequotas/{name}".replaceAll("\\{format\\}", "json").replaceAll("\\{" + "name" + "\\}",apiInvoker.escape(name)).replaceAll("\\{" + "namespace" + "\\}",apiInvoker.escape(namespace))

    val contentTypes = List("*/*")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (name == null) throw new Exception("Missing required parameter 'name' when calling Core_v1Api->deleteCoreV1NamespacedResourceQuota")

    if (namespace == null) throw new Exception("Missing required parameter 'namespace' when calling Core_v1Api->deleteCoreV1NamespacedResourceQuota")

    if (body == null) throw new Exception("Missing required parameter 'body' when calling Core_v1Api->deleteCoreV1NamespacedResourceQuota")

    pretty.map(paramVal => queryParams += "pretty" -> paramVal.toString)
    gracePeriodSeconds.map(paramVal => queryParams += "gracePeriodSeconds" -> paramVal.toString)
    orphanDependents.map(paramVal => queryParams += "orphanDependents" -> paramVal.toString)
    propagationPolicy.map(paramVal => queryParams += "propagationPolicy" -> paramVal.toString)
    

    var postBody: AnyRef = body

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "DELETE", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "", classOf[IoK8sApimachineryPkgApisMetaV1Status]).asInstanceOf[IoK8sApimachineryPkgApisMetaV1Status])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * 
   * delete a Secret
   * @param name name of the Secret 
   * @param namespace object name and auth scope, such as for teams and projects 
   * @param body  
   * @param pretty If &#39;true&#39;, then the output is pretty printed. (optional)
   * @param gracePeriodSeconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)
   * @param orphanDependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)
   * @param propagationPolicy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. (optional)
   * @return IoK8sApimachineryPkgApisMetaV1Status
   */
  def deleteCoreV1NamespacedSecret(name: String, namespace: String, body: IoK8sApimachineryPkgApisMetaV1DeleteOptions, pretty: Option[String] = None, gracePeriodSeconds: Option[Integer] = None, orphanDependents: Option[Boolean] = None, propagationPolicy: Option[String] = None): Option[IoK8sApimachineryPkgApisMetaV1Status] = {
    // create path and map variables
    val path = "/api/v1/namespaces/{namespace}/secrets/{name}".replaceAll("\\{format\\}", "json").replaceAll("\\{" + "name" + "\\}",apiInvoker.escape(name)).replaceAll("\\{" + "namespace" + "\\}",apiInvoker.escape(namespace))

    val contentTypes = List("*/*")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (name == null) throw new Exception("Missing required parameter 'name' when calling Core_v1Api->deleteCoreV1NamespacedSecret")

    if (namespace == null) throw new Exception("Missing required parameter 'namespace' when calling Core_v1Api->deleteCoreV1NamespacedSecret")

    if (body == null) throw new Exception("Missing required parameter 'body' when calling Core_v1Api->deleteCoreV1NamespacedSecret")

    pretty.map(paramVal => queryParams += "pretty" -> paramVal.toString)
    gracePeriodSeconds.map(paramVal => queryParams += "gracePeriodSeconds" -> paramVal.toString)
    orphanDependents.map(paramVal => queryParams += "orphanDependents" -> paramVal.toString)
    propagationPolicy.map(paramVal => queryParams += "propagationPolicy" -> paramVal.toString)
    

    var postBody: AnyRef = body

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "DELETE", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "", classOf[IoK8sApimachineryPkgApisMetaV1Status]).asInstanceOf[IoK8sApimachineryPkgApisMetaV1Status])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * 
   * delete a Service
   * @param name name of the Service 
   * @param namespace object name and auth scope, such as for teams and projects 
   * @param pretty If &#39;true&#39;, then the output is pretty printed. (optional)
   * @return IoK8sApimachineryPkgApisMetaV1Status
   */
  def deleteCoreV1NamespacedService(name: String, namespace: String, pretty: Option[String] = None): Option[IoK8sApimachineryPkgApisMetaV1Status] = {
    // create path and map variables
    val path = "/api/v1/namespaces/{namespace}/services/{name}".replaceAll("\\{format\\}", "json").replaceAll("\\{" + "name" + "\\}",apiInvoker.escape(name)).replaceAll("\\{" + "namespace" + "\\}",apiInvoker.escape(namespace))

    val contentTypes = List("*/*")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (name == null) throw new Exception("Missing required parameter 'name' when calling Core_v1Api->deleteCoreV1NamespacedService")

    if (namespace == null) throw new Exception("Missing required parameter 'namespace' when calling Core_v1Api->deleteCoreV1NamespacedService")

    pretty.map(paramVal => queryParams += "pretty" -> paramVal.toString)
    

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "DELETE", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "", classOf[IoK8sApimachineryPkgApisMetaV1Status]).asInstanceOf[IoK8sApimachineryPkgApisMetaV1Status])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * 
   * delete a ServiceAccount
   * @param name name of the ServiceAccount 
   * @param namespace object name and auth scope, such as for teams and projects 
   * @param body  
   * @param pretty If &#39;true&#39;, then the output is pretty printed. (optional)
   * @param gracePeriodSeconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)
   * @param orphanDependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)
   * @param propagationPolicy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. (optional)
   * @return IoK8sApimachineryPkgApisMetaV1Status
   */
  def deleteCoreV1NamespacedServiceAccount(name: String, namespace: String, body: IoK8sApimachineryPkgApisMetaV1DeleteOptions, pretty: Option[String] = None, gracePeriodSeconds: Option[Integer] = None, orphanDependents: Option[Boolean] = None, propagationPolicy: Option[String] = None): Option[IoK8sApimachineryPkgApisMetaV1Status] = {
    // create path and map variables
    val path = "/api/v1/namespaces/{namespace}/serviceaccounts/{name}".replaceAll("\\{format\\}", "json").replaceAll("\\{" + "name" + "\\}",apiInvoker.escape(name)).replaceAll("\\{" + "namespace" + "\\}",apiInvoker.escape(namespace))

    val contentTypes = List("*/*")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (name == null) throw new Exception("Missing required parameter 'name' when calling Core_v1Api->deleteCoreV1NamespacedServiceAccount")

    if (namespace == null) throw new Exception("Missing required parameter 'namespace' when calling Core_v1Api->deleteCoreV1NamespacedServiceAccount")

    if (body == null) throw new Exception("Missing required parameter 'body' when calling Core_v1Api->deleteCoreV1NamespacedServiceAccount")

    pretty.map(paramVal => queryParams += "pretty" -> paramVal.toString)
    gracePeriodSeconds.map(paramVal => queryParams += "gracePeriodSeconds" -> paramVal.toString)
    orphanDependents.map(paramVal => queryParams += "orphanDependents" -> paramVal.toString)
    propagationPolicy.map(paramVal => queryParams += "propagationPolicy" -> paramVal.toString)
    

    var postBody: AnyRef = body

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "DELETE", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "", classOf[IoK8sApimachineryPkgApisMetaV1Status]).asInstanceOf[IoK8sApimachineryPkgApisMetaV1Status])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * 
   * delete a Node
   * @param name name of the Node 
   * @param body  
   * @param pretty If &#39;true&#39;, then the output is pretty printed. (optional)
   * @param gracePeriodSeconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)
   * @param orphanDependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)
   * @param propagationPolicy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. (optional)
   * @return IoK8sApimachineryPkgApisMetaV1Status
   */
  def deleteCoreV1Node(name: String, body: IoK8sApimachineryPkgApisMetaV1DeleteOptions, pretty: Option[String] = None, gracePeriodSeconds: Option[Integer] = None, orphanDependents: Option[Boolean] = None, propagationPolicy: Option[String] = None): Option[IoK8sApimachineryPkgApisMetaV1Status] = {
    // create path and map variables
    val path = "/api/v1/nodes/{name}".replaceAll("\\{format\\}", "json").replaceAll("\\{" + "name" + "\\}",apiInvoker.escape(name))

    val contentTypes = List("*/*")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (name == null) throw new Exception("Missing required parameter 'name' when calling Core_v1Api->deleteCoreV1Node")

    if (body == null) throw new Exception("Missing required parameter 'body' when calling Core_v1Api->deleteCoreV1Node")

    pretty.map(paramVal => queryParams += "pretty" -> paramVal.toString)
    gracePeriodSeconds.map(paramVal => queryParams += "gracePeriodSeconds" -> paramVal.toString)
    orphanDependents.map(paramVal => queryParams += "orphanDependents" -> paramVal.toString)
    propagationPolicy.map(paramVal => queryParams += "propagationPolicy" -> paramVal.toString)
    

    var postBody: AnyRef = body

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "DELETE", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "", classOf[IoK8sApimachineryPkgApisMetaV1Status]).asInstanceOf[IoK8sApimachineryPkgApisMetaV1Status])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * 
   * delete a PersistentVolume
   * @param name name of the PersistentVolume 
   * @param body  
   * @param pretty If &#39;true&#39;, then the output is pretty printed. (optional)
   * @param gracePeriodSeconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)
   * @param orphanDependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)
   * @param propagationPolicy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. (optional)
   * @return IoK8sApimachineryPkgApisMetaV1Status
   */
  def deleteCoreV1PersistentVolume(name: String, body: IoK8sApimachineryPkgApisMetaV1DeleteOptions, pretty: Option[String] = None, gracePeriodSeconds: Option[Integer] = None, orphanDependents: Option[Boolean] = None, propagationPolicy: Option[String] = None): Option[IoK8sApimachineryPkgApisMetaV1Status] = {
    // create path and map variables
    val path = "/api/v1/persistentvolumes/{name}".replaceAll("\\{format\\}", "json").replaceAll("\\{" + "name" + "\\}",apiInvoker.escape(name))

    val contentTypes = List("*/*")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (name == null) throw new Exception("Missing required parameter 'name' when calling Core_v1Api->deleteCoreV1PersistentVolume")

    if (body == null) throw new Exception("Missing required parameter 'body' when calling Core_v1Api->deleteCoreV1PersistentVolume")

    pretty.map(paramVal => queryParams += "pretty" -> paramVal.toString)
    gracePeriodSeconds.map(paramVal => queryParams += "gracePeriodSeconds" -> paramVal.toString)
    orphanDependents.map(paramVal => queryParams += "orphanDependents" -> paramVal.toString)
    propagationPolicy.map(paramVal => queryParams += "propagationPolicy" -> paramVal.toString)
    

    var postBody: AnyRef = body

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "DELETE", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "", classOf[IoK8sApimachineryPkgApisMetaV1Status]).asInstanceOf[IoK8sApimachineryPkgApisMetaV1Status])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * 
   * get available resources
   * @return IoK8sApimachineryPkgApisMetaV1APIResourceList
   */
  def getCoreV1APIResources(): Option[IoK8sApimachineryPkgApisMetaV1APIResourceList] = {
    // create path and map variables
    val path = "/api/v1/".replaceAll("\\{format\\}", "json")

    val contentTypes = List("application/json", "application/yaml", "application/vnd.kubernetes.protobuf")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "GET", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "", classOf[IoK8sApimachineryPkgApisMetaV1APIResourceList]).asInstanceOf[IoK8sApimachineryPkgApisMetaV1APIResourceList])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * 
   * list objects of kind ComponentStatus
   * @param continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. (optional)
   * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
   * @param includeUninitialized If true, partially initialized resources are included in the response. (optional)
   * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
   * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. (optional)
   * @param pretty If &#39;true&#39;, then the output is pretty printed. (optional)
   * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
   * @param timeoutSeconds Timeout for the list/watch call. (optional)
   * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
   * @return IoK8sApiCoreV1ComponentStatusList
   */
  def listCoreV1ComponentStatus(continue: Option[String] = None, fieldSelector: Option[String] = None, includeUninitialized: Option[Boolean] = None, labelSelector: Option[String] = None, limit: Option[Integer] = None, pretty: Option[String] = None, resourceVersion: Option[String] = None, timeoutSeconds: Option[Integer] = None, watch: Option[Boolean] = None): Option[IoK8sApiCoreV1ComponentStatusList] = {
    // create path and map variables
    val path = "/api/v1/componentstatuses".replaceAll("\\{format\\}", "json")

    val contentTypes = List("*/*")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    continue.map(paramVal => queryParams += "continue" -> paramVal.toString)
    fieldSelector.map(paramVal => queryParams += "fieldSelector" -> paramVal.toString)
    includeUninitialized.map(paramVal => queryParams += "includeUninitialized" -> paramVal.toString)
    labelSelector.map(paramVal => queryParams += "labelSelector" -> paramVal.toString)
    limit.map(paramVal => queryParams += "limit" -> paramVal.toString)
    pretty.map(paramVal => queryParams += "pretty" -> paramVal.toString)
    resourceVersion.map(paramVal => queryParams += "resourceVersion" -> paramVal.toString)
    timeoutSeconds.map(paramVal => queryParams += "timeoutSeconds" -> paramVal.toString)
    watch.map(paramVal => queryParams += "watch" -> paramVal.toString)
    

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "GET", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "", classOf[IoK8sApiCoreV1ComponentStatusList]).asInstanceOf[IoK8sApiCoreV1ComponentStatusList])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * 
   * list or watch objects of kind ConfigMap
   * @param continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. (optional)
   * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
   * @param includeUninitialized If true, partially initialized resources are included in the response. (optional)
   * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
   * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. (optional)
   * @param pretty If &#39;true&#39;, then the output is pretty printed. (optional)
   * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
   * @param timeoutSeconds Timeout for the list/watch call. (optional)
   * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
   * @return IoK8sApiCoreV1ConfigMapList
   */
  def listCoreV1ConfigMapForAllNamespaces(continue: Option[String] = None, fieldSelector: Option[String] = None, includeUninitialized: Option[Boolean] = None, labelSelector: Option[String] = None, limit: Option[Integer] = None, pretty: Option[String] = None, resourceVersion: Option[String] = None, timeoutSeconds: Option[Integer] = None, watch: Option[Boolean] = None): Option[IoK8sApiCoreV1ConfigMapList] = {
    // create path and map variables
    val path = "/api/v1/configmaps".replaceAll("\\{format\\}", "json")

    val contentTypes = List("*/*")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    continue.map(paramVal => queryParams += "continue" -> paramVal.toString)
    fieldSelector.map(paramVal => queryParams += "fieldSelector" -> paramVal.toString)
    includeUninitialized.map(paramVal => queryParams += "includeUninitialized" -> paramVal.toString)
    labelSelector.map(paramVal => queryParams += "labelSelector" -> paramVal.toString)
    limit.map(paramVal => queryParams += "limit" -> paramVal.toString)
    pretty.map(paramVal => queryParams += "pretty" -> paramVal.toString)
    resourceVersion.map(paramVal => queryParams += "resourceVersion" -> paramVal.toString)
    timeoutSeconds.map(paramVal => queryParams += "timeoutSeconds" -> paramVal.toString)
    watch.map(paramVal => queryParams += "watch" -> paramVal.toString)
    

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "GET", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "", classOf[IoK8sApiCoreV1ConfigMapList]).asInstanceOf[IoK8sApiCoreV1ConfigMapList])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * 
   * list or watch objects of kind Endpoints
   * @param continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. (optional)
   * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
   * @param includeUninitialized If true, partially initialized resources are included in the response. (optional)
   * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
   * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. (optional)
   * @param pretty If &#39;true&#39;, then the output is pretty printed. (optional)
   * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
   * @param timeoutSeconds Timeout for the list/watch call. (optional)
   * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
   * @return IoK8sApiCoreV1EndpointsList
   */
  def listCoreV1EndpointsForAllNamespaces(continue: Option[String] = None, fieldSelector: Option[String] = None, includeUninitialized: Option[Boolean] = None, labelSelector: Option[String] = None, limit: Option[Integer] = None, pretty: Option[String] = None, resourceVersion: Option[String] = None, timeoutSeconds: Option[Integer] = None, watch: Option[Boolean] = None): Option[IoK8sApiCoreV1EndpointsList] = {
    // create path and map variables
    val path = "/api/v1/endpoints".replaceAll("\\{format\\}", "json")

    val contentTypes = List("*/*")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    continue.map(paramVal => queryParams += "continue" -> paramVal.toString)
    fieldSelector.map(paramVal => queryParams += "fieldSelector" -> paramVal.toString)
    includeUninitialized.map(paramVal => queryParams += "includeUninitialized" -> paramVal.toString)
    labelSelector.map(paramVal => queryParams += "labelSelector" -> paramVal.toString)
    limit.map(paramVal => queryParams += "limit" -> paramVal.toString)
    pretty.map(paramVal => queryParams += "pretty" -> paramVal.toString)
    resourceVersion.map(paramVal => queryParams += "resourceVersion" -> paramVal.toString)
    timeoutSeconds.map(paramVal => queryParams += "timeoutSeconds" -> paramVal.toString)
    watch.map(paramVal => queryParams += "watch" -> paramVal.toString)
    

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "GET", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "", classOf[IoK8sApiCoreV1EndpointsList]).asInstanceOf[IoK8sApiCoreV1EndpointsList])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * 
   * list or watch objects of kind Event
   * @param continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. (optional)
   * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
   * @param includeUninitialized If true, partially initialized resources are included in the response. (optional)
   * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
   * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. (optional)
   * @param pretty If &#39;true&#39;, then the output is pretty printed. (optional)
   * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
   * @param timeoutSeconds Timeout for the list/watch call. (optional)
   * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
   * @return IoK8sApiCoreV1EventList
   */
  def listCoreV1EventForAllNamespaces(continue: Option[String] = None, fieldSelector: Option[String] = None, includeUninitialized: Option[Boolean] = None, labelSelector: Option[String] = None, limit: Option[Integer] = None, pretty: Option[String] = None, resourceVersion: Option[String] = None, timeoutSeconds: Option[Integer] = None, watch: Option[Boolean] = None): Option[IoK8sApiCoreV1EventList] = {
    // create path and map variables
    val path = "/api/v1/events".replaceAll("\\{format\\}", "json")

    val contentTypes = List("*/*")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    continue.map(paramVal => queryParams += "continue" -> paramVal.toString)
    fieldSelector.map(paramVal => queryParams += "fieldSelector" -> paramVal.toString)
    includeUninitialized.map(paramVal => queryParams += "includeUninitialized" -> paramVal.toString)
    labelSelector.map(paramVal => queryParams += "labelSelector" -> paramVal.toString)
    limit.map(paramVal => queryParams += "limit" -> paramVal.toString)
    pretty.map(paramVal => queryParams += "pretty" -> paramVal.toString)
    resourceVersion.map(paramVal => queryParams += "resourceVersion" -> paramVal.toString)
    timeoutSeconds.map(paramVal => queryParams += "timeoutSeconds" -> paramVal.toString)
    watch.map(paramVal => queryParams += "watch" -> paramVal.toString)
    

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "GET", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "", classOf[IoK8sApiCoreV1EventList]).asInstanceOf[IoK8sApiCoreV1EventList])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * 
   * list or watch objects of kind LimitRange
   * @param continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. (optional)
   * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
   * @param includeUninitialized If true, partially initialized resources are included in the response. (optional)
   * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
   * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. (optional)
   * @param pretty If &#39;true&#39;, then the output is pretty printed. (optional)
   * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
   * @param timeoutSeconds Timeout for the list/watch call. (optional)
   * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
   * @return IoK8sApiCoreV1LimitRangeList
   */
  def listCoreV1LimitRangeForAllNamespaces(continue: Option[String] = None, fieldSelector: Option[String] = None, includeUninitialized: Option[Boolean] = None, labelSelector: Option[String] = None, limit: Option[Integer] = None, pretty: Option[String] = None, resourceVersion: Option[String] = None, timeoutSeconds: Option[Integer] = None, watch: Option[Boolean] = None): Option[IoK8sApiCoreV1LimitRangeList] = {
    // create path and map variables
    val path = "/api/v1/limitranges".replaceAll("\\{format\\}", "json")

    val contentTypes = List("*/*")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    continue.map(paramVal => queryParams += "continue" -> paramVal.toString)
    fieldSelector.map(paramVal => queryParams += "fieldSelector" -> paramVal.toString)
    includeUninitialized.map(paramVal => queryParams += "includeUninitialized" -> paramVal.toString)
    labelSelector.map(paramVal => queryParams += "labelSelector" -> paramVal.toString)
    limit.map(paramVal => queryParams += "limit" -> paramVal.toString)
    pretty.map(paramVal => queryParams += "pretty" -> paramVal.toString)
    resourceVersion.map(paramVal => queryParams += "resourceVersion" -> paramVal.toString)
    timeoutSeconds.map(paramVal => queryParams += "timeoutSeconds" -> paramVal.toString)
    watch.map(paramVal => queryParams += "watch" -> paramVal.toString)
    

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "GET", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "", classOf[IoK8sApiCoreV1LimitRangeList]).asInstanceOf[IoK8sApiCoreV1LimitRangeList])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * 
   * list or watch objects of kind Namespace
   * @param pretty If &#39;true&#39;, then the output is pretty printed. (optional)
   * @param continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. (optional)
   * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
   * @param includeUninitialized If true, partially initialized resources are included in the response. (optional)
   * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
   * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. (optional)
   * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
   * @param timeoutSeconds Timeout for the list/watch call. (optional)
   * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
   * @return IoK8sApiCoreV1NamespaceList
   */
  def listCoreV1Namespace(pretty: Option[String] = None, continue: Option[String] = None, fieldSelector: Option[String] = None, includeUninitialized: Option[Boolean] = None, labelSelector: Option[String] = None, limit: Option[Integer] = None, resourceVersion: Option[String] = None, timeoutSeconds: Option[Integer] = None, watch: Option[Boolean] = None): Option[IoK8sApiCoreV1NamespaceList] = {
    // create path and map variables
    val path = "/api/v1/namespaces".replaceAll("\\{format\\}", "json")

    val contentTypes = List("*/*")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    pretty.map(paramVal => queryParams += "pretty" -> paramVal.toString)
    continue.map(paramVal => queryParams += "continue" -> paramVal.toString)
    fieldSelector.map(paramVal => queryParams += "fieldSelector" -> paramVal.toString)
    includeUninitialized.map(paramVal => queryParams += "includeUninitialized" -> paramVal.toString)
    labelSelector.map(paramVal => queryParams += "labelSelector" -> paramVal.toString)
    limit.map(paramVal => queryParams += "limit" -> paramVal.toString)
    resourceVersion.map(paramVal => queryParams += "resourceVersion" -> paramVal.toString)
    timeoutSeconds.map(paramVal => queryParams += "timeoutSeconds" -> paramVal.toString)
    watch.map(paramVal => queryParams += "watch" -> paramVal.toString)
    

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "GET", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "", classOf[IoK8sApiCoreV1NamespaceList]).asInstanceOf[IoK8sApiCoreV1NamespaceList])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * 
   * list or watch objects of kind ConfigMap
   * @param namespace object name and auth scope, such as for teams and projects 
   * @param pretty If &#39;true&#39;, then the output is pretty printed. (optional)
   * @param continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. (optional)
   * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
   * @param includeUninitialized If true, partially initialized resources are included in the response. (optional)
   * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
   * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. (optional)
   * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
   * @param timeoutSeconds Timeout for the list/watch call. (optional)
   * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
   * @return IoK8sApiCoreV1ConfigMapList
   */
  def listCoreV1NamespacedConfigMap(namespace: String, pretty: Option[String] = None, continue: Option[String] = None, fieldSelector: Option[String] = None, includeUninitialized: Option[Boolean] = None, labelSelector: Option[String] = None, limit: Option[Integer] = None, resourceVersion: Option[String] = None, timeoutSeconds: Option[Integer] = None, watch: Option[Boolean] = None): Option[IoK8sApiCoreV1ConfigMapList] = {
    // create path and map variables
    val path = "/api/v1/namespaces/{namespace}/configmaps".replaceAll("\\{format\\}", "json").replaceAll("\\{" + "namespace" + "\\}",apiInvoker.escape(namespace))

    val contentTypes = List("*/*")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (namespace == null) throw new Exception("Missing required parameter 'namespace' when calling Core_v1Api->listCoreV1NamespacedConfigMap")

    pretty.map(paramVal => queryParams += "pretty" -> paramVal.toString)
    continue.map(paramVal => queryParams += "continue" -> paramVal.toString)
    fieldSelector.map(paramVal => queryParams += "fieldSelector" -> paramVal.toString)
    includeUninitialized.map(paramVal => queryParams += "includeUninitialized" -> paramVal.toString)
    labelSelector.map(paramVal => queryParams += "labelSelector" -> paramVal.toString)
    limit.map(paramVal => queryParams += "limit" -> paramVal.toString)
    resourceVersion.map(paramVal => queryParams += "resourceVersion" -> paramVal.toString)
    timeoutSeconds.map(paramVal => queryParams += "timeoutSeconds" -> paramVal.toString)
    watch.map(paramVal => queryParams += "watch" -> paramVal.toString)
    

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "GET", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "", classOf[IoK8sApiCoreV1ConfigMapList]).asInstanceOf[IoK8sApiCoreV1ConfigMapList])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * 
   * list or watch objects of kind Endpoints
   * @param namespace object name and auth scope, such as for teams and projects 
   * @param pretty If &#39;true&#39;, then the output is pretty printed. (optional)
   * @param continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. (optional)
   * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
   * @param includeUninitialized If true, partially initialized resources are included in the response. (optional)
   * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
   * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. (optional)
   * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
   * @param timeoutSeconds Timeout for the list/watch call. (optional)
   * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
   * @return IoK8sApiCoreV1EndpointsList
   */
  def listCoreV1NamespacedEndpoints(namespace: String, pretty: Option[String] = None, continue: Option[String] = None, fieldSelector: Option[String] = None, includeUninitialized: Option[Boolean] = None, labelSelector: Option[String] = None, limit: Option[Integer] = None, resourceVersion: Option[String] = None, timeoutSeconds: Option[Integer] = None, watch: Option[Boolean] = None): Option[IoK8sApiCoreV1EndpointsList] = {
    // create path and map variables
    val path = "/api/v1/namespaces/{namespace}/endpoints".replaceAll("\\{format\\}", "json").replaceAll("\\{" + "namespace" + "\\}",apiInvoker.escape(namespace))

    val contentTypes = List("*/*")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (namespace == null) throw new Exception("Missing required parameter 'namespace' when calling Core_v1Api->listCoreV1NamespacedEndpoints")

    pretty.map(paramVal => queryParams += "pretty" -> paramVal.toString)
    continue.map(paramVal => queryParams += "continue" -> paramVal.toString)
    fieldSelector.map(paramVal => queryParams += "fieldSelector" -> paramVal.toString)
    includeUninitialized.map(paramVal => queryParams += "includeUninitialized" -> paramVal.toString)
    labelSelector.map(paramVal => queryParams += "labelSelector" -> paramVal.toString)
    limit.map(paramVal => queryParams += "limit" -> paramVal.toString)
    resourceVersion.map(paramVal => queryParams += "resourceVersion" -> paramVal.toString)
    timeoutSeconds.map(paramVal => queryParams += "timeoutSeconds" -> paramVal.toString)
    watch.map(paramVal => queryParams += "watch" -> paramVal.toString)
    

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "GET", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "", classOf[IoK8sApiCoreV1EndpointsList]).asInstanceOf[IoK8sApiCoreV1EndpointsList])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * 
   * list or watch objects of kind Event
   * @param namespace object name and auth scope, such as for teams and projects 
   * @param pretty If &#39;true&#39;, then the output is pretty printed. (optional)
   * @param continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. (optional)
   * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
   * @param includeUninitialized If true, partially initialized resources are included in the response. (optional)
   * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
   * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. (optional)
   * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
   * @param timeoutSeconds Timeout for the list/watch call. (optional)
   * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
   * @return IoK8sApiCoreV1EventList
   */
  def listCoreV1NamespacedEvent(namespace: String, pretty: Option[String] = None, continue: Option[String] = None, fieldSelector: Option[String] = None, includeUninitialized: Option[Boolean] = None, labelSelector: Option[String] = None, limit: Option[Integer] = None, resourceVersion: Option[String] = None, timeoutSeconds: Option[Integer] = None, watch: Option[Boolean] = None): Option[IoK8sApiCoreV1EventList] = {
    // create path and map variables
    val path = "/api/v1/namespaces/{namespace}/events".replaceAll("\\{format\\}", "json").replaceAll("\\{" + "namespace" + "\\}",apiInvoker.escape(namespace))

    val contentTypes = List("*/*")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (namespace == null) throw new Exception("Missing required parameter 'namespace' when calling Core_v1Api->listCoreV1NamespacedEvent")

    pretty.map(paramVal => queryParams += "pretty" -> paramVal.toString)
    continue.map(paramVal => queryParams += "continue" -> paramVal.toString)
    fieldSelector.map(paramVal => queryParams += "fieldSelector" -> paramVal.toString)
    includeUninitialized.map(paramVal => queryParams += "includeUninitialized" -> paramVal.toString)
    labelSelector.map(paramVal => queryParams += "labelSelector" -> paramVal.toString)
    limit.map(paramVal => queryParams += "limit" -> paramVal.toString)
    resourceVersion.map(paramVal => queryParams += "resourceVersion" -> paramVal.toString)
    timeoutSeconds.map(paramVal => queryParams += "timeoutSeconds" -> paramVal.toString)
    watch.map(paramVal => queryParams += "watch" -> paramVal.toString)
    

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "GET", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "", classOf[IoK8sApiCoreV1EventList]).asInstanceOf[IoK8sApiCoreV1EventList])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * 
   * list or watch objects of kind LimitRange
   * @param namespace object name and auth scope, such as for teams and projects 
   * @param pretty If &#39;true&#39;, then the output is pretty printed. (optional)
   * @param continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. (optional)
   * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
   * @param includeUninitialized If true, partially initialized resources are included in the response. (optional)
   * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
   * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. (optional)
   * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
   * @param timeoutSeconds Timeout for the list/watch call. (optional)
   * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
   * @return IoK8sApiCoreV1LimitRangeList
   */
  def listCoreV1NamespacedLimitRange(namespace: String, pretty: Option[String] = None, continue: Option[String] = None, fieldSelector: Option[String] = None, includeUninitialized: Option[Boolean] = None, labelSelector: Option[String] = None, limit: Option[Integer] = None, resourceVersion: Option[String] = None, timeoutSeconds: Option[Integer] = None, watch: Option[Boolean] = None): Option[IoK8sApiCoreV1LimitRangeList] = {
    // create path and map variables
    val path = "/api/v1/namespaces/{namespace}/limitranges".replaceAll("\\{format\\}", "json").replaceAll("\\{" + "namespace" + "\\}",apiInvoker.escape(namespace))

    val contentTypes = List("*/*")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (namespace == null) throw new Exception("Missing required parameter 'namespace' when calling Core_v1Api->listCoreV1NamespacedLimitRange")

    pretty.map(paramVal => queryParams += "pretty" -> paramVal.toString)
    continue.map(paramVal => queryParams += "continue" -> paramVal.toString)
    fieldSelector.map(paramVal => queryParams += "fieldSelector" -> paramVal.toString)
    includeUninitialized.map(paramVal => queryParams += "includeUninitialized" -> paramVal.toString)
    labelSelector.map(paramVal => queryParams += "labelSelector" -> paramVal.toString)
    limit.map(paramVal => queryParams += "limit" -> paramVal.toString)
    resourceVersion.map(paramVal => queryParams += "resourceVersion" -> paramVal.toString)
    timeoutSeconds.map(paramVal => queryParams += "timeoutSeconds" -> paramVal.toString)
    watch.map(paramVal => queryParams += "watch" -> paramVal.toString)
    

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "GET", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "", classOf[IoK8sApiCoreV1LimitRangeList]).asInstanceOf[IoK8sApiCoreV1LimitRangeList])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * 
   * list or watch objects of kind PersistentVolumeClaim
   * @param namespace object name and auth scope, such as for teams and projects 
   * @param pretty If &#39;true&#39;, then the output is pretty printed. (optional)
   * @param continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. (optional)
   * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
   * @param includeUninitialized If true, partially initialized resources are included in the response. (optional)
   * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
   * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. (optional)
   * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
   * @param timeoutSeconds Timeout for the list/watch call. (optional)
   * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
   * @return IoK8sApiCoreV1PersistentVolumeClaimList
   */
  def listCoreV1NamespacedPersistentVolumeClaim(namespace: String, pretty: Option[String] = None, continue: Option[String] = None, fieldSelector: Option[String] = None, includeUninitialized: Option[Boolean] = None, labelSelector: Option[String] = None, limit: Option[Integer] = None, resourceVersion: Option[String] = None, timeoutSeconds: Option[Integer] = None, watch: Option[Boolean] = None): Option[IoK8sApiCoreV1PersistentVolumeClaimList] = {
    // create path and map variables
    val path = "/api/v1/namespaces/{namespace}/persistentvolumeclaims".replaceAll("\\{format\\}", "json").replaceAll("\\{" + "namespace" + "\\}",apiInvoker.escape(namespace))

    val contentTypes = List("*/*")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (namespace == null) throw new Exception("Missing required parameter 'namespace' when calling Core_v1Api->listCoreV1NamespacedPersistentVolumeClaim")

    pretty.map(paramVal => queryParams += "pretty" -> paramVal.toString)
    continue.map(paramVal => queryParams += "continue" -> paramVal.toString)
    fieldSelector.map(paramVal => queryParams += "fieldSelector" -> paramVal.toString)
    includeUninitialized.map(paramVal => queryParams += "includeUninitialized" -> paramVal.toString)
    labelSelector.map(paramVal => queryParams += "labelSelector" -> paramVal.toString)
    limit.map(paramVal => queryParams += "limit" -> paramVal.toString)
    resourceVersion.map(paramVal => queryParams += "resourceVersion" -> paramVal.toString)
    timeoutSeconds.map(paramVal => queryParams += "timeoutSeconds" -> paramVal.toString)
    watch.map(paramVal => queryParams += "watch" -> paramVal.toString)
    

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "GET", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "", classOf[IoK8sApiCoreV1PersistentVolumeClaimList]).asInstanceOf[IoK8sApiCoreV1PersistentVolumeClaimList])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * 
   * list or watch objects of kind Pod
   * @param namespace object name and auth scope, such as for teams and projects 
   * @param pretty If &#39;true&#39;, then the output is pretty printed. (optional)
   * @param continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. (optional)
   * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
   * @param includeUninitialized If true, partially initialized resources are included in the response. (optional)
   * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
   * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. (optional)
   * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
   * @param timeoutSeconds Timeout for the list/watch call. (optional)
   * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
   * @return IoK8sApiCoreV1PodList
   */
  def listCoreV1NamespacedPod(namespace: String, pretty: Option[String] = None, continue: Option[String] = None, fieldSelector: Option[String] = None, includeUninitialized: Option[Boolean] = None, labelSelector: Option[String] = None, limit: Option[Integer] = None, resourceVersion: Option[String] = None, timeoutSeconds: Option[Integer] = None, watch: Option[Boolean] = None): Option[IoK8sApiCoreV1PodList] = {
    // create path and map variables
    val path = "/api/v1/namespaces/{namespace}/pods".replaceAll("\\{format\\}", "json").replaceAll("\\{" + "namespace" + "\\}",apiInvoker.escape(namespace))

    val contentTypes = List("*/*")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (namespace == null) throw new Exception("Missing required parameter 'namespace' when calling Core_v1Api->listCoreV1NamespacedPod")

    pretty.map(paramVal => queryParams += "pretty" -> paramVal.toString)
    continue.map(paramVal => queryParams += "continue" -> paramVal.toString)
    fieldSelector.map(paramVal => queryParams += "fieldSelector" -> paramVal.toString)
    includeUninitialized.map(paramVal => queryParams += "includeUninitialized" -> paramVal.toString)
    labelSelector.map(paramVal => queryParams += "labelSelector" -> paramVal.toString)
    limit.map(paramVal => queryParams += "limit" -> paramVal.toString)
    resourceVersion.map(paramVal => queryParams += "resourceVersion" -> paramVal.toString)
    timeoutSeconds.map(paramVal => queryParams += "timeoutSeconds" -> paramVal.toString)
    watch.map(paramVal => queryParams += "watch" -> paramVal.toString)
    

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "GET", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "", classOf[IoK8sApiCoreV1PodList]).asInstanceOf[IoK8sApiCoreV1PodList])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * 
   * list or watch objects of kind PodTemplate
   * @param namespace object name and auth scope, such as for teams and projects 
   * @param pretty If &#39;true&#39;, then the output is pretty printed. (optional)
   * @param continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. (optional)
   * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
   * @param includeUninitialized If true, partially initialized resources are included in the response. (optional)
   * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
   * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. (optional)
   * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
   * @param timeoutSeconds Timeout for the list/watch call. (optional)
   * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
   * @return IoK8sApiCoreV1PodTemplateList
   */
  def listCoreV1NamespacedPodTemplate(namespace: String, pretty: Option[String] = None, continue: Option[String] = None, fieldSelector: Option[String] = None, includeUninitialized: Option[Boolean] = None, labelSelector: Option[String] = None, limit: Option[Integer] = None, resourceVersion: Option[String] = None, timeoutSeconds: Option[Integer] = None, watch: Option[Boolean] = None): Option[IoK8sApiCoreV1PodTemplateList] = {
    // create path and map variables
    val path = "/api/v1/namespaces/{namespace}/podtemplates".replaceAll("\\{format\\}", "json").replaceAll("\\{" + "namespace" + "\\}",apiInvoker.escape(namespace))

    val contentTypes = List("*/*")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (namespace == null) throw new Exception("Missing required parameter 'namespace' when calling Core_v1Api->listCoreV1NamespacedPodTemplate")

    pretty.map(paramVal => queryParams += "pretty" -> paramVal.toString)
    continue.map(paramVal => queryParams += "continue" -> paramVal.toString)
    fieldSelector.map(paramVal => queryParams += "fieldSelector" -> paramVal.toString)
    includeUninitialized.map(paramVal => queryParams += "includeUninitialized" -> paramVal.toString)
    labelSelector.map(paramVal => queryParams += "labelSelector" -> paramVal.toString)
    limit.map(paramVal => queryParams += "limit" -> paramVal.toString)
    resourceVersion.map(paramVal => queryParams += "resourceVersion" -> paramVal.toString)
    timeoutSeconds.map(paramVal => queryParams += "timeoutSeconds" -> paramVal.toString)
    watch.map(paramVal => queryParams += "watch" -> paramVal.toString)
    

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "GET", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "", classOf[IoK8sApiCoreV1PodTemplateList]).asInstanceOf[IoK8sApiCoreV1PodTemplateList])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * 
   * list or watch objects of kind ReplicationController
   * @param namespace object name and auth scope, such as for teams and projects 
   * @param pretty If &#39;true&#39;, then the output is pretty printed. (optional)
   * @param continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. (optional)
   * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
   * @param includeUninitialized If true, partially initialized resources are included in the response. (optional)
   * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
   * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. (optional)
   * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
   * @param timeoutSeconds Timeout for the list/watch call. (optional)
   * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
   * @return IoK8sApiCoreV1ReplicationControllerList
   */
  def listCoreV1NamespacedReplicationController(namespace: String, pretty: Option[String] = None, continue: Option[String] = None, fieldSelector: Option[String] = None, includeUninitialized: Option[Boolean] = None, labelSelector: Option[String] = None, limit: Option[Integer] = None, resourceVersion: Option[String] = None, timeoutSeconds: Option[Integer] = None, watch: Option[Boolean] = None): Option[IoK8sApiCoreV1ReplicationControllerList] = {
    // create path and map variables
    val path = "/api/v1/namespaces/{namespace}/replicationcontrollers".replaceAll("\\{format\\}", "json").replaceAll("\\{" + "namespace" + "\\}",apiInvoker.escape(namespace))

    val contentTypes = List("*/*")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (namespace == null) throw new Exception("Missing required parameter 'namespace' when calling Core_v1Api->listCoreV1NamespacedReplicationController")

    pretty.map(paramVal => queryParams += "pretty" -> paramVal.toString)
    continue.map(paramVal => queryParams += "continue" -> paramVal.toString)
    fieldSelector.map(paramVal => queryParams += "fieldSelector" -> paramVal.toString)
    includeUninitialized.map(paramVal => queryParams += "includeUninitialized" -> paramVal.toString)
    labelSelector.map(paramVal => queryParams += "labelSelector" -> paramVal.toString)
    limit.map(paramVal => queryParams += "limit" -> paramVal.toString)
    resourceVersion.map(paramVal => queryParams += "resourceVersion" -> paramVal.toString)
    timeoutSeconds.map(paramVal => queryParams += "timeoutSeconds" -> paramVal.toString)
    watch.map(paramVal => queryParams += "watch" -> paramVal.toString)
    

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "GET", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "", classOf[IoK8sApiCoreV1ReplicationControllerList]).asInstanceOf[IoK8sApiCoreV1ReplicationControllerList])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * 
   * list or watch objects of kind ResourceQuota
   * @param namespace object name and auth scope, such as for teams and projects 
   * @param pretty If &#39;true&#39;, then the output is pretty printed. (optional)
   * @param continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. (optional)
   * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
   * @param includeUninitialized If true, partially initialized resources are included in the response. (optional)
   * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
   * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. (optional)
   * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
   * @param timeoutSeconds Timeout for the list/watch call. (optional)
   * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
   * @return IoK8sApiCoreV1ResourceQuotaList
   */
  def listCoreV1NamespacedResourceQuota(namespace: String, pretty: Option[String] = None, continue: Option[String] = None, fieldSelector: Option[String] = None, includeUninitialized: Option[Boolean] = None, labelSelector: Option[String] = None, limit: Option[Integer] = None, resourceVersion: Option[String] = None, timeoutSeconds: Option[Integer] = None, watch: Option[Boolean] = None): Option[IoK8sApiCoreV1ResourceQuotaList] = {
    // create path and map variables
    val path = "/api/v1/namespaces/{namespace}/resourcequotas".replaceAll("\\{format\\}", "json").replaceAll("\\{" + "namespace" + "\\}",apiInvoker.escape(namespace))

    val contentTypes = List("*/*")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (namespace == null) throw new Exception("Missing required parameter 'namespace' when calling Core_v1Api->listCoreV1NamespacedResourceQuota")

    pretty.map(paramVal => queryParams += "pretty" -> paramVal.toString)
    continue.map(paramVal => queryParams += "continue" -> paramVal.toString)
    fieldSelector.map(paramVal => queryParams += "fieldSelector" -> paramVal.toString)
    includeUninitialized.map(paramVal => queryParams += "includeUninitialized" -> paramVal.toString)
    labelSelector.map(paramVal => queryParams += "labelSelector" -> paramVal.toString)
    limit.map(paramVal => queryParams += "limit" -> paramVal.toString)
    resourceVersion.map(paramVal => queryParams += "resourceVersion" -> paramVal.toString)
    timeoutSeconds.map(paramVal => queryParams += "timeoutSeconds" -> paramVal.toString)
    watch.map(paramVal => queryParams += "watch" -> paramVal.toString)
    

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "GET", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "", classOf[IoK8sApiCoreV1ResourceQuotaList]).asInstanceOf[IoK8sApiCoreV1ResourceQuotaList])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * 
   * list or watch objects of kind Secret
   * @param namespace object name and auth scope, such as for teams and projects 
   * @param pretty If &#39;true&#39;, then the output is pretty printed. (optional)
   * @param continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. (optional)
   * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
   * @param includeUninitialized If true, partially initialized resources are included in the response. (optional)
   * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
   * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. (optional)
   * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
   * @param timeoutSeconds Timeout for the list/watch call. (optional)
   * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
   * @return IoK8sApiCoreV1SecretList
   */
  def listCoreV1NamespacedSecret(namespace: String, pretty: Option[String] = None, continue: Option[String] = None, fieldSelector: Option[String] = None, includeUninitialized: Option[Boolean] = None, labelSelector: Option[String] = None, limit: Option[Integer] = None, resourceVersion: Option[String] = None, timeoutSeconds: Option[Integer] = None, watch: Option[Boolean] = None): Option[IoK8sApiCoreV1SecretList] = {
    // create path and map variables
    val path = "/api/v1/namespaces/{namespace}/secrets".replaceAll("\\{format\\}", "json").replaceAll("\\{" + "namespace" + "\\}",apiInvoker.escape(namespace))

    val contentTypes = List("*/*")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (namespace == null) throw new Exception("Missing required parameter 'namespace' when calling Core_v1Api->listCoreV1NamespacedSecret")

    pretty.map(paramVal => queryParams += "pretty" -> paramVal.toString)
    continue.map(paramVal => queryParams += "continue" -> paramVal.toString)
    fieldSelector.map(paramVal => queryParams += "fieldSelector" -> paramVal.toString)
    includeUninitialized.map(paramVal => queryParams += "includeUninitialized" -> paramVal.toString)
    labelSelector.map(paramVal => queryParams += "labelSelector" -> paramVal.toString)
    limit.map(paramVal => queryParams += "limit" -> paramVal.toString)
    resourceVersion.map(paramVal => queryParams += "resourceVersion" -> paramVal.toString)
    timeoutSeconds.map(paramVal => queryParams += "timeoutSeconds" -> paramVal.toString)
    watch.map(paramVal => queryParams += "watch" -> paramVal.toString)
    

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "GET", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "", classOf[IoK8sApiCoreV1SecretList]).asInstanceOf[IoK8sApiCoreV1SecretList])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * 
   * list or watch objects of kind Service
   * @param namespace object name and auth scope, such as for teams and projects 
   * @param pretty If &#39;true&#39;, then the output is pretty printed. (optional)
   * @param continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. (optional)
   * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
   * @param includeUninitialized If true, partially initialized resources are included in the response. (optional)
   * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
   * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. (optional)
   * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
   * @param timeoutSeconds Timeout for the list/watch call. (optional)
   * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
   * @return IoK8sApiCoreV1ServiceList
   */
  def listCoreV1NamespacedService(namespace: String, pretty: Option[String] = None, continue: Option[String] = None, fieldSelector: Option[String] = None, includeUninitialized: Option[Boolean] = None, labelSelector: Option[String] = None, limit: Option[Integer] = None, resourceVersion: Option[String] = None, timeoutSeconds: Option[Integer] = None, watch: Option[Boolean] = None): Option[IoK8sApiCoreV1ServiceList] = {
    // create path and map variables
    val path = "/api/v1/namespaces/{namespace}/services".replaceAll("\\{format\\}", "json").replaceAll("\\{" + "namespace" + "\\}",apiInvoker.escape(namespace))

    val contentTypes = List("*/*")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (namespace == null) throw new Exception("Missing required parameter 'namespace' when calling Core_v1Api->listCoreV1NamespacedService")

    pretty.map(paramVal => queryParams += "pretty" -> paramVal.toString)
    continue.map(paramVal => queryParams += "continue" -> paramVal.toString)
    fieldSelector.map(paramVal => queryParams += "fieldSelector" -> paramVal.toString)
    includeUninitialized.map(paramVal => queryParams += "includeUninitialized" -> paramVal.toString)
    labelSelector.map(paramVal => queryParams += "labelSelector" -> paramVal.toString)
    limit.map(paramVal => queryParams += "limit" -> paramVal.toString)
    resourceVersion.map(paramVal => queryParams += "resourceVersion" -> paramVal.toString)
    timeoutSeconds.map(paramVal => queryParams += "timeoutSeconds" -> paramVal.toString)
    watch.map(paramVal => queryParams += "watch" -> paramVal.toString)
    

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "GET", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "", classOf[IoK8sApiCoreV1ServiceList]).asInstanceOf[IoK8sApiCoreV1ServiceList])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * 
   * list or watch objects of kind ServiceAccount
   * @param namespace object name and auth scope, such as for teams and projects 
   * @param pretty If &#39;true&#39;, then the output is pretty printed. (optional)
   * @param continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. (optional)
   * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
   * @param includeUninitialized If true, partially initialized resources are included in the response. (optional)
   * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
   * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. (optional)
   * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
   * @param timeoutSeconds Timeout for the list/watch call. (optional)
   * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
   * @return IoK8sApiCoreV1ServiceAccountList
   */
  def listCoreV1NamespacedServiceAccount(namespace: String, pretty: Option[String] = None, continue: Option[String] = None, fieldSelector: Option[String] = None, includeUninitialized: Option[Boolean] = None, labelSelector: Option[String] = None, limit: Option[Integer] = None, resourceVersion: Option[String] = None, timeoutSeconds: Option[Integer] = None, watch: Option[Boolean] = None): Option[IoK8sApiCoreV1ServiceAccountList] = {
    // create path and map variables
    val path = "/api/v1/namespaces/{namespace}/serviceaccounts".replaceAll("\\{format\\}", "json").replaceAll("\\{" + "namespace" + "\\}",apiInvoker.escape(namespace))

    val contentTypes = List("*/*")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (namespace == null) throw new Exception("Missing required parameter 'namespace' when calling Core_v1Api->listCoreV1NamespacedServiceAccount")

    pretty.map(paramVal => queryParams += "pretty" -> paramVal.toString)
    continue.map(paramVal => queryParams += "continue" -> paramVal.toString)
    fieldSelector.map(paramVal => queryParams += "fieldSelector" -> paramVal.toString)
    includeUninitialized.map(paramVal => queryParams += "includeUninitialized" -> paramVal.toString)
    labelSelector.map(paramVal => queryParams += "labelSelector" -> paramVal.toString)
    limit.map(paramVal => queryParams += "limit" -> paramVal.toString)
    resourceVersion.map(paramVal => queryParams += "resourceVersion" -> paramVal.toString)
    timeoutSeconds.map(paramVal => queryParams += "timeoutSeconds" -> paramVal.toString)
    watch.map(paramVal => queryParams += "watch" -> paramVal.toString)
    

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "GET", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "", classOf[IoK8sApiCoreV1ServiceAccountList]).asInstanceOf[IoK8sApiCoreV1ServiceAccountList])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * 
   * list or watch objects of kind Node
   * @param pretty If &#39;true&#39;, then the output is pretty printed. (optional)
   * @param continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. (optional)
   * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
   * @param includeUninitialized If true, partially initialized resources are included in the response. (optional)
   * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
   * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. (optional)
   * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
   * @param timeoutSeconds Timeout for the list/watch call. (optional)
   * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
   * @return IoK8sApiCoreV1NodeList
   */
  def listCoreV1Node(pretty: Option[String] = None, continue: Option[String] = None, fieldSelector: Option[String] = None, includeUninitialized: Option[Boolean] = None, labelSelector: Option[String] = None, limit: Option[Integer] = None, resourceVersion: Option[String] = None, timeoutSeconds: Option[Integer] = None, watch: Option[Boolean] = None): Option[IoK8sApiCoreV1NodeList] = {
    // create path and map variables
    val path = "/api/v1/nodes".replaceAll("\\{format\\}", "json")

    val contentTypes = List("*/*")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    pretty.map(paramVal => queryParams += "pretty" -> paramVal.toString)
    continue.map(paramVal => queryParams += "continue" -> paramVal.toString)
    fieldSelector.map(paramVal => queryParams += "fieldSelector" -> paramVal.toString)
    includeUninitialized.map(paramVal => queryParams += "includeUninitialized" -> paramVal.toString)
    labelSelector.map(paramVal => queryParams += "labelSelector" -> paramVal.toString)
    limit.map(paramVal => queryParams += "limit" -> paramVal.toString)
    resourceVersion.map(paramVal => queryParams += "resourceVersion" -> paramVal.toString)
    timeoutSeconds.map(paramVal => queryParams += "timeoutSeconds" -> paramVal.toString)
    watch.map(paramVal => queryParams += "watch" -> paramVal.toString)
    

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "GET", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "", classOf[IoK8sApiCoreV1NodeList]).asInstanceOf[IoK8sApiCoreV1NodeList])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * 
   * list or watch objects of kind PersistentVolume
   * @param pretty If &#39;true&#39;, then the output is pretty printed. (optional)
   * @param continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. (optional)
   * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
   * @param includeUninitialized If true, partially initialized resources are included in the response. (optional)
   * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
   * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. (optional)
   * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
   * @param timeoutSeconds Timeout for the list/watch call. (optional)
   * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
   * @return IoK8sApiCoreV1PersistentVolumeList
   */
  def listCoreV1PersistentVolume(pretty: Option[String] = None, continue: Option[String] = None, fieldSelector: Option[String] = None, includeUninitialized: Option[Boolean] = None, labelSelector: Option[String] = None, limit: Option[Integer] = None, resourceVersion: Option[String] = None, timeoutSeconds: Option[Integer] = None, watch: Option[Boolean] = None): Option[IoK8sApiCoreV1PersistentVolumeList] = {
    // create path and map variables
    val path = "/api/v1/persistentvolumes".replaceAll("\\{format\\}", "json")

    val contentTypes = List("*/*")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    pretty.map(paramVal => queryParams += "pretty" -> paramVal.toString)
    continue.map(paramVal => queryParams += "continue" -> paramVal.toString)
    fieldSelector.map(paramVal => queryParams += "fieldSelector" -> paramVal.toString)
    includeUninitialized.map(paramVal => queryParams += "includeUninitialized" -> paramVal.toString)
    labelSelector.map(paramVal => queryParams += "labelSelector" -> paramVal.toString)
    limit.map(paramVal => queryParams += "limit" -> paramVal.toString)
    resourceVersion.map(paramVal => queryParams += "resourceVersion" -> paramVal.toString)
    timeoutSeconds.map(paramVal => queryParams += "timeoutSeconds" -> paramVal.toString)
    watch.map(paramVal => queryParams += "watch" -> paramVal.toString)
    

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "GET", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "", classOf[IoK8sApiCoreV1PersistentVolumeList]).asInstanceOf[IoK8sApiCoreV1PersistentVolumeList])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * 
   * list or watch objects of kind PersistentVolumeClaim
   * @param continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. (optional)
   * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
   * @param includeUninitialized If true, partially initialized resources are included in the response. (optional)
   * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
   * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. (optional)
   * @param pretty If &#39;true&#39;, then the output is pretty printed. (optional)
   * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
   * @param timeoutSeconds Timeout for the list/watch call. (optional)
   * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
   * @return IoK8sApiCoreV1PersistentVolumeClaimList
   */
  def listCoreV1PersistentVolumeClaimForAllNamespaces(continue: Option[String] = None, fieldSelector: Option[String] = None, includeUninitialized: Option[Boolean] = None, labelSelector: Option[String] = None, limit: Option[Integer] = None, pretty: Option[String] = None, resourceVersion: Option[String] = None, timeoutSeconds: Option[Integer] = None, watch: Option[Boolean] = None): Option[IoK8sApiCoreV1PersistentVolumeClaimList] = {
    // create path and map variables
    val path = "/api/v1/persistentvolumeclaims".replaceAll("\\{format\\}", "json")

    val contentTypes = List("*/*")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    continue.map(paramVal => queryParams += "continue" -> paramVal.toString)
    fieldSelector.map(paramVal => queryParams += "fieldSelector" -> paramVal.toString)
    includeUninitialized.map(paramVal => queryParams += "includeUninitialized" -> paramVal.toString)
    labelSelector.map(paramVal => queryParams += "labelSelector" -> paramVal.toString)
    limit.map(paramVal => queryParams += "limit" -> paramVal.toString)
    pretty.map(paramVal => queryParams += "pretty" -> paramVal.toString)
    resourceVersion.map(paramVal => queryParams += "resourceVersion" -> paramVal.toString)
    timeoutSeconds.map(paramVal => queryParams += "timeoutSeconds" -> paramVal.toString)
    watch.map(paramVal => queryParams += "watch" -> paramVal.toString)
    

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "GET", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "", classOf[IoK8sApiCoreV1PersistentVolumeClaimList]).asInstanceOf[IoK8sApiCoreV1PersistentVolumeClaimList])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * 
   * list or watch objects of kind Pod
   * @param continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. (optional)
   * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
   * @param includeUninitialized If true, partially initialized resources are included in the response. (optional)
   * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
   * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. (optional)
   * @param pretty If &#39;true&#39;, then the output is pretty printed. (optional)
   * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
   * @param timeoutSeconds Timeout for the list/watch call. (optional)
   * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
   * @return IoK8sApiCoreV1PodList
   */
  def listCoreV1PodForAllNamespaces(continue: Option[String] = None, fieldSelector: Option[String] = None, includeUninitialized: Option[Boolean] = None, labelSelector: Option[String] = None, limit: Option[Integer] = None, pretty: Option[String] = None, resourceVersion: Option[String] = None, timeoutSeconds: Option[Integer] = None, watch: Option[Boolean] = None): Option[IoK8sApiCoreV1PodList] = {
    // create path and map variables
    val path = "/api/v1/pods".replaceAll("\\{format\\}", "json")

    val contentTypes = List("*/*")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    continue.map(paramVal => queryParams += "continue" -> paramVal.toString)
    fieldSelector.map(paramVal => queryParams += "fieldSelector" -> paramVal.toString)
    includeUninitialized.map(paramVal => queryParams += "includeUninitialized" -> paramVal.toString)
    labelSelector.map(paramVal => queryParams += "labelSelector" -> paramVal.toString)
    limit.map(paramVal => queryParams += "limit" -> paramVal.toString)
    pretty.map(paramVal => queryParams += "pretty" -> paramVal.toString)
    resourceVersion.map(paramVal => queryParams += "resourceVersion" -> paramVal.toString)
    timeoutSeconds.map(paramVal => queryParams += "timeoutSeconds" -> paramVal.toString)
    watch.map(paramVal => queryParams += "watch" -> paramVal.toString)
    

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "GET", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "", classOf[IoK8sApiCoreV1PodList]).asInstanceOf[IoK8sApiCoreV1PodList])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * 
   * list or watch objects of kind PodTemplate
   * @param continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. (optional)
   * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
   * @param includeUninitialized If true, partially initialized resources are included in the response. (optional)
   * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
   * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. (optional)
   * @param pretty If &#39;true&#39;, then the output is pretty printed. (optional)
   * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
   * @param timeoutSeconds Timeout for the list/watch call. (optional)
   * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
   * @return IoK8sApiCoreV1PodTemplateList
   */
  def listCoreV1PodTemplateForAllNamespaces(continue: Option[String] = None, fieldSelector: Option[String] = None, includeUninitialized: Option[Boolean] = None, labelSelector: Option[String] = None, limit: Option[Integer] = None, pretty: Option[String] = None, resourceVersion: Option[String] = None, timeoutSeconds: Option[Integer] = None, watch: Option[Boolean] = None): Option[IoK8sApiCoreV1PodTemplateList] = {
    // create path and map variables
    val path = "/api/v1/podtemplates".replaceAll("\\{format\\}", "json")

    val contentTypes = List("*/*")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    continue.map(paramVal => queryParams += "continue" -> paramVal.toString)
    fieldSelector.map(paramVal => queryParams += "fieldSelector" -> paramVal.toString)
    includeUninitialized.map(paramVal => queryParams += "includeUninitialized" -> paramVal.toString)
    labelSelector.map(paramVal => queryParams += "labelSelector" -> paramVal.toString)
    limit.map(paramVal => queryParams += "limit" -> paramVal.toString)
    pretty.map(paramVal => queryParams += "pretty" -> paramVal.toString)
    resourceVersion.map(paramVal => queryParams += "resourceVersion" -> paramVal.toString)
    timeoutSeconds.map(paramVal => queryParams += "timeoutSeconds" -> paramVal.toString)
    watch.map(paramVal => queryParams += "watch" -> paramVal.toString)
    

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "GET", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "", classOf[IoK8sApiCoreV1PodTemplateList]).asInstanceOf[IoK8sApiCoreV1PodTemplateList])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * 
   * list or watch objects of kind ReplicationController
   * @param continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. (optional)
   * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
   * @param includeUninitialized If true, partially initialized resources are included in the response. (optional)
   * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
   * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. (optional)
   * @param pretty If &#39;true&#39;, then the output is pretty printed. (optional)
   * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
   * @param timeoutSeconds Timeout for the list/watch call. (optional)
   * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
   * @return IoK8sApiCoreV1ReplicationControllerList
   */
  def listCoreV1ReplicationControllerForAllNamespaces(continue: Option[String] = None, fieldSelector: Option[String] = None, includeUninitialized: Option[Boolean] = None, labelSelector: Option[String] = None, limit: Option[Integer] = None, pretty: Option[String] = None, resourceVersion: Option[String] = None, timeoutSeconds: Option[Integer] = None, watch: Option[Boolean] = None): Option[IoK8sApiCoreV1ReplicationControllerList] = {
    // create path and map variables
    val path = "/api/v1/replicationcontrollers".replaceAll("\\{format\\}", "json")

    val contentTypes = List("*/*")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    continue.map(paramVal => queryParams += "continue" -> paramVal.toString)
    fieldSelector.map(paramVal => queryParams += "fieldSelector" -> paramVal.toString)
    includeUninitialized.map(paramVal => queryParams += "includeUninitialized" -> paramVal.toString)
    labelSelector.map(paramVal => queryParams += "labelSelector" -> paramVal.toString)
    limit.map(paramVal => queryParams += "limit" -> paramVal.toString)
    pretty.map(paramVal => queryParams += "pretty" -> paramVal.toString)
    resourceVersion.map(paramVal => queryParams += "resourceVersion" -> paramVal.toString)
    timeoutSeconds.map(paramVal => queryParams += "timeoutSeconds" -> paramVal.toString)
    watch.map(paramVal => queryParams += "watch" -> paramVal.toString)
    

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "GET", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "", classOf[IoK8sApiCoreV1ReplicationControllerList]).asInstanceOf[IoK8sApiCoreV1ReplicationControllerList])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * 
   * list or watch objects of kind ResourceQuota
   * @param continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. (optional)
   * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
   * @param includeUninitialized If true, partially initialized resources are included in the response. (optional)
   * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
   * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. (optional)
   * @param pretty If &#39;true&#39;, then the output is pretty printed. (optional)
   * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
   * @param timeoutSeconds Timeout for the list/watch call. (optional)
   * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
   * @return IoK8sApiCoreV1ResourceQuotaList
   */
  def listCoreV1ResourceQuotaForAllNamespaces(continue: Option[String] = None, fieldSelector: Option[String] = None, includeUninitialized: Option[Boolean] = None, labelSelector: Option[String] = None, limit: Option[Integer] = None, pretty: Option[String] = None, resourceVersion: Option[String] = None, timeoutSeconds: Option[Integer] = None, watch: Option[Boolean] = None): Option[IoK8sApiCoreV1ResourceQuotaList] = {
    // create path and map variables
    val path = "/api/v1/resourcequotas".replaceAll("\\{format\\}", "json")

    val contentTypes = List("*/*")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    continue.map(paramVal => queryParams += "continue" -> paramVal.toString)
    fieldSelector.map(paramVal => queryParams += "fieldSelector" -> paramVal.toString)
    includeUninitialized.map(paramVal => queryParams += "includeUninitialized" -> paramVal.toString)
    labelSelector.map(paramVal => queryParams += "labelSelector" -> paramVal.toString)
    limit.map(paramVal => queryParams += "limit" -> paramVal.toString)
    pretty.map(paramVal => queryParams += "pretty" -> paramVal.toString)
    resourceVersion.map(paramVal => queryParams += "resourceVersion" -> paramVal.toString)
    timeoutSeconds.map(paramVal => queryParams += "timeoutSeconds" -> paramVal.toString)
    watch.map(paramVal => queryParams += "watch" -> paramVal.toString)
    

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "GET", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "", classOf[IoK8sApiCoreV1ResourceQuotaList]).asInstanceOf[IoK8sApiCoreV1ResourceQuotaList])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * 
   * list or watch objects of kind Secret
   * @param continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. (optional)
   * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
   * @param includeUninitialized If true, partially initialized resources are included in the response. (optional)
   * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
   * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. (optional)
   * @param pretty If &#39;true&#39;, then the output is pretty printed. (optional)
   * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
   * @param timeoutSeconds Timeout for the list/watch call. (optional)
   * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
   * @return IoK8sApiCoreV1SecretList
   */
  def listCoreV1SecretForAllNamespaces(continue: Option[String] = None, fieldSelector: Option[String] = None, includeUninitialized: Option[Boolean] = None, labelSelector: Option[String] = None, limit: Option[Integer] = None, pretty: Option[String] = None, resourceVersion: Option[String] = None, timeoutSeconds: Option[Integer] = None, watch: Option[Boolean] = None): Option[IoK8sApiCoreV1SecretList] = {
    // create path and map variables
    val path = "/api/v1/secrets".replaceAll("\\{format\\}", "json")

    val contentTypes = List("*/*")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    continue.map(paramVal => queryParams += "continue" -> paramVal.toString)
    fieldSelector.map(paramVal => queryParams += "fieldSelector" -> paramVal.toString)
    includeUninitialized.map(paramVal => queryParams += "includeUninitialized" -> paramVal.toString)
    labelSelector.map(paramVal => queryParams += "labelSelector" -> paramVal.toString)
    limit.map(paramVal => queryParams += "limit" -> paramVal.toString)
    pretty.map(paramVal => queryParams += "pretty" -> paramVal.toString)
    resourceVersion.map(paramVal => queryParams += "resourceVersion" -> paramVal.toString)
    timeoutSeconds.map(paramVal => queryParams += "timeoutSeconds" -> paramVal.toString)
    watch.map(paramVal => queryParams += "watch" -> paramVal.toString)
    

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "GET", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "", classOf[IoK8sApiCoreV1SecretList]).asInstanceOf[IoK8sApiCoreV1SecretList])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * 
   * list or watch objects of kind ServiceAccount
   * @param continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. (optional)
   * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
   * @param includeUninitialized If true, partially initialized resources are included in the response. (optional)
   * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
   * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. (optional)
   * @param pretty If &#39;true&#39;, then the output is pretty printed. (optional)
   * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
   * @param timeoutSeconds Timeout for the list/watch call. (optional)
   * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
   * @return IoK8sApiCoreV1ServiceAccountList
   */
  def listCoreV1ServiceAccountForAllNamespaces(continue: Option[String] = None, fieldSelector: Option[String] = None, includeUninitialized: Option[Boolean] = None, labelSelector: Option[String] = None, limit: Option[Integer] = None, pretty: Option[String] = None, resourceVersion: Option[String] = None, timeoutSeconds: Option[Integer] = None, watch: Option[Boolean] = None): Option[IoK8sApiCoreV1ServiceAccountList] = {
    // create path and map variables
    val path = "/api/v1/serviceaccounts".replaceAll("\\{format\\}", "json")

    val contentTypes = List("*/*")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    continue.map(paramVal => queryParams += "continue" -> paramVal.toString)
    fieldSelector.map(paramVal => queryParams += "fieldSelector" -> paramVal.toString)
    includeUninitialized.map(paramVal => queryParams += "includeUninitialized" -> paramVal.toString)
    labelSelector.map(paramVal => queryParams += "labelSelector" -> paramVal.toString)
    limit.map(paramVal => queryParams += "limit" -> paramVal.toString)
    pretty.map(paramVal => queryParams += "pretty" -> paramVal.toString)
    resourceVersion.map(paramVal => queryParams += "resourceVersion" -> paramVal.toString)
    timeoutSeconds.map(paramVal => queryParams += "timeoutSeconds" -> paramVal.toString)
    watch.map(paramVal => queryParams += "watch" -> paramVal.toString)
    

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "GET", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "", classOf[IoK8sApiCoreV1ServiceAccountList]).asInstanceOf[IoK8sApiCoreV1ServiceAccountList])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * 
   * list or watch objects of kind Service
   * @param continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. (optional)
   * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
   * @param includeUninitialized If true, partially initialized resources are included in the response. (optional)
   * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
   * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. (optional)
   * @param pretty If &#39;true&#39;, then the output is pretty printed. (optional)
   * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
   * @param timeoutSeconds Timeout for the list/watch call. (optional)
   * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
   * @return IoK8sApiCoreV1ServiceList
   */
  def listCoreV1ServiceForAllNamespaces(continue: Option[String] = None, fieldSelector: Option[String] = None, includeUninitialized: Option[Boolean] = None, labelSelector: Option[String] = None, limit: Option[Integer] = None, pretty: Option[String] = None, resourceVersion: Option[String] = None, timeoutSeconds: Option[Integer] = None, watch: Option[Boolean] = None): Option[IoK8sApiCoreV1ServiceList] = {
    // create path and map variables
    val path = "/api/v1/services".replaceAll("\\{format\\}", "json")

    val contentTypes = List("*/*")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    continue.map(paramVal => queryParams += "continue" -> paramVal.toString)
    fieldSelector.map(paramVal => queryParams += "fieldSelector" -> paramVal.toString)
    includeUninitialized.map(paramVal => queryParams += "includeUninitialized" -> paramVal.toString)
    labelSelector.map(paramVal => queryParams += "labelSelector" -> paramVal.toString)
    limit.map(paramVal => queryParams += "limit" -> paramVal.toString)
    pretty.map(paramVal => queryParams += "pretty" -> paramVal.toString)
    resourceVersion.map(paramVal => queryParams += "resourceVersion" -> paramVal.toString)
    timeoutSeconds.map(paramVal => queryParams += "timeoutSeconds" -> paramVal.toString)
    watch.map(paramVal => queryParams += "watch" -> paramVal.toString)
    

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "GET", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "", classOf[IoK8sApiCoreV1ServiceList]).asInstanceOf[IoK8sApiCoreV1ServiceList])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * 
   * proxy DELETE requests to Pod
   * @param name name of the Pod 
   * @param namespace object name and auth scope, such as for teams and projects 
   * @return String
   */
  def proxyCoreV1DELETENamespacedPod(name: String, namespace: String): Option[String] = {
    // create path and map variables
    val path = "/api/v1/proxy/namespaces/{namespace}/pods/{name}".replaceAll("\\{format\\}", "json").replaceAll("\\{" + "name" + "\\}",apiInvoker.escape(name)).replaceAll("\\{" + "namespace" + "\\}",apiInvoker.escape(namespace))

    val contentTypes = List("*/*")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (name == null) throw new Exception("Missing required parameter 'name' when calling Core_v1Api->proxyCoreV1DELETENamespacedPod")

    if (namespace == null) throw new Exception("Missing required parameter 'namespace' when calling Core_v1Api->proxyCoreV1DELETENamespacedPod")

    

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "DELETE", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "", classOf[String]).asInstanceOf[String])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * 
   * proxy DELETE requests to Pod
   * @param name name of the Pod 
   * @param namespace object name and auth scope, such as for teams and projects 
   * @param _path path to the resource 
   * @return String
   */
  def proxyCoreV1DELETENamespacedPodWithPath(name: String, namespace: String, _path: String): Option[String] = {
    // create path and map variables
    val path = "/api/v1/proxy/namespaces/{namespace}/pods/{name}/{path}".replaceAll("\\{format\\}", "json").replaceAll("\\{" + "name" + "\\}",apiInvoker.escape(name)).replaceAll("\\{" + "namespace" + "\\}",apiInvoker.escape(namespace)).replaceAll("\\{" + "path" + "\\}",apiInvoker.escape(_path))

    val contentTypes = List("*/*")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (name == null) throw new Exception("Missing required parameter 'name' when calling Core_v1Api->proxyCoreV1DELETENamespacedPodWithPath")

    if (namespace == null) throw new Exception("Missing required parameter 'namespace' when calling Core_v1Api->proxyCoreV1DELETENamespacedPodWithPath")

    if (_path == null) throw new Exception("Missing required parameter '_path' when calling Core_v1Api->proxyCoreV1DELETENamespacedPodWithPath")

    

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "DELETE", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "", classOf[String]).asInstanceOf[String])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * 
   * proxy DELETE requests to Service
   * @param name name of the Service 
   * @param namespace object name and auth scope, such as for teams and projects 
   * @return String
   */
  def proxyCoreV1DELETENamespacedService(name: String, namespace: String): Option[String] = {
    // create path and map variables
    val path = "/api/v1/proxy/namespaces/{namespace}/services/{name}".replaceAll("\\{format\\}", "json").replaceAll("\\{" + "name" + "\\}",apiInvoker.escape(name)).replaceAll("\\{" + "namespace" + "\\}",apiInvoker.escape(namespace))

    val contentTypes = List("*/*")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (name == null) throw new Exception("Missing required parameter 'name' when calling Core_v1Api->proxyCoreV1DELETENamespacedService")

    if (namespace == null) throw new Exception("Missing required parameter 'namespace' when calling Core_v1Api->proxyCoreV1DELETENamespacedService")

    

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "DELETE", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "", classOf[String]).asInstanceOf[String])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * 
   * proxy DELETE requests to Service
   * @param name name of the Service 
   * @param namespace object name and auth scope, such as for teams and projects 
   * @param _path path to the resource 
   * @return String
   */
  def proxyCoreV1DELETENamespacedServiceWithPath(name: String, namespace: String, _path: String): Option[String] = {
    // create path and map variables
    val path = "/api/v1/proxy/namespaces/{namespace}/services/{name}/{path}".replaceAll("\\{format\\}", "json").replaceAll("\\{" + "name" + "\\}",apiInvoker.escape(name)).replaceAll("\\{" + "namespace" + "\\}",apiInvoker.escape(namespace)).replaceAll("\\{" + "path" + "\\}",apiInvoker.escape(_path))

    val contentTypes = List("*/*")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (name == null) throw new Exception("Missing required parameter 'name' when calling Core_v1Api->proxyCoreV1DELETENamespacedServiceWithPath")

    if (namespace == null) throw new Exception("Missing required parameter 'namespace' when calling Core_v1Api->proxyCoreV1DELETENamespacedServiceWithPath")

    if (_path == null) throw new Exception("Missing required parameter '_path' when calling Core_v1Api->proxyCoreV1DELETENamespacedServiceWithPath")

    

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "DELETE", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "", classOf[String]).asInstanceOf[String])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * 
   * proxy DELETE requests to Node
   * @param name name of the Node 
   * @return String
   */
  def proxyCoreV1DELETENode(name: String): Option[String] = {
    // create path and map variables
    val path = "/api/v1/proxy/nodes/{name}".replaceAll("\\{format\\}", "json").replaceAll("\\{" + "name" + "\\}",apiInvoker.escape(name))

    val contentTypes = List("*/*")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (name == null) throw new Exception("Missing required parameter 'name' when calling Core_v1Api->proxyCoreV1DELETENode")

    

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "DELETE", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "", classOf[String]).asInstanceOf[String])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * 
   * proxy DELETE requests to Node
   * @param name name of the Node 
   * @param _path path to the resource 
   * @return String
   */
  def proxyCoreV1DELETENodeWithPath(name: String, _path: String): Option[String] = {
    // create path and map variables
    val path = "/api/v1/proxy/nodes/{name}/{path}".replaceAll("\\{format\\}", "json").replaceAll("\\{" + "name" + "\\}",apiInvoker.escape(name)).replaceAll("\\{" + "path" + "\\}",apiInvoker.escape(_path))

    val contentTypes = List("*/*")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (name == null) throw new Exception("Missing required parameter 'name' when calling Core_v1Api->proxyCoreV1DELETENodeWithPath")

    if (_path == null) throw new Exception("Missing required parameter '_path' when calling Core_v1Api->proxyCoreV1DELETENodeWithPath")

    

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "DELETE", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "", classOf[String]).asInstanceOf[String])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * 
   * proxy GET requests to Pod
   * @param name name of the Pod 
   * @param namespace object name and auth scope, such as for teams and projects 
   * @return String
   */
  def proxyCoreV1GETNamespacedPod(name: String, namespace: String): Option[String] = {
    // create path and map variables
    val path = "/api/v1/proxy/namespaces/{namespace}/pods/{name}".replaceAll("\\{format\\}", "json").replaceAll("\\{" + "name" + "\\}",apiInvoker.escape(name)).replaceAll("\\{" + "namespace" + "\\}",apiInvoker.escape(namespace))

    val contentTypes = List("*/*")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (name == null) throw new Exception("Missing required parameter 'name' when calling Core_v1Api->proxyCoreV1GETNamespacedPod")

    if (namespace == null) throw new Exception("Missing required parameter 'namespace' when calling Core_v1Api->proxyCoreV1GETNamespacedPod")

    

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "GET", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "", classOf[String]).asInstanceOf[String])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * 
   * proxy GET requests to Pod
   * @param name name of the Pod 
   * @param namespace object name and auth scope, such as for teams and projects 
   * @param _path path to the resource 
   * @return String
   */
  def proxyCoreV1GETNamespacedPodWithPath(name: String, namespace: String, _path: String): Option[String] = {
    // create path and map variables
    val path = "/api/v1/proxy/namespaces/{namespace}/pods/{name}/{path}".replaceAll("\\{format\\}", "json").replaceAll("\\{" + "name" + "\\}",apiInvoker.escape(name)).replaceAll("\\{" + "namespace" + "\\}",apiInvoker.escape(namespace)).replaceAll("\\{" + "path" + "\\}",apiInvoker.escape(_path))

    val contentTypes = List("*/*")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (name == null) throw new Exception("Missing required parameter 'name' when calling Core_v1Api->proxyCoreV1GETNamespacedPodWithPath")

    if (namespace == null) throw new Exception("Missing required parameter 'namespace' when calling Core_v1Api->proxyCoreV1GETNamespacedPodWithPath")

    if (_path == null) throw new Exception("Missing required parameter '_path' when calling Core_v1Api->proxyCoreV1GETNamespacedPodWithPath")

    

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "GET", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "", classOf[String]).asInstanceOf[String])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * 
   * proxy GET requests to Service
   * @param name name of the Service 
   * @param namespace object name and auth scope, such as for teams and projects 
   * @return String
   */
  def proxyCoreV1GETNamespacedService(name: String, namespace: String): Option[String] = {
    // create path and map variables
    val path = "/api/v1/proxy/namespaces/{namespace}/services/{name}".replaceAll("\\{format\\}", "json").replaceAll("\\{" + "name" + "\\}",apiInvoker.escape(name)).replaceAll("\\{" + "namespace" + "\\}",apiInvoker.escape(namespace))

    val contentTypes = List("*/*")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (name == null) throw new Exception("Missing required parameter 'name' when calling Core_v1Api->proxyCoreV1GETNamespacedService")

    if (namespace == null) throw new Exception("Missing required parameter 'namespace' when calling Core_v1Api->proxyCoreV1GETNamespacedService")

    

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "GET", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "", classOf[String]).asInstanceOf[String])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * 
   * proxy GET requests to Service
   * @param name name of the Service 
   * @param namespace object name and auth scope, such as for teams and projects 
   * @param _path path to the resource 
   * @return String
   */
  def proxyCoreV1GETNamespacedServiceWithPath(name: String, namespace: String, _path: String): Option[String] = {
    // create path and map variables
    val path = "/api/v1/proxy/namespaces/{namespace}/services/{name}/{path}".replaceAll("\\{format\\}", "json").replaceAll("\\{" + "name" + "\\}",apiInvoker.escape(name)).replaceAll("\\{" + "namespace" + "\\}",apiInvoker.escape(namespace)).replaceAll("\\{" + "path" + "\\}",apiInvoker.escape(_path))

    val contentTypes = List("*/*")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (name == null) throw new Exception("Missing required parameter 'name' when calling Core_v1Api->proxyCoreV1GETNamespacedServiceWithPath")

    if (namespace == null) throw new Exception("Missing required parameter 'namespace' when calling Core_v1Api->proxyCoreV1GETNamespacedServiceWithPath")

    if (_path == null) throw new Exception("Missing required parameter '_path' when calling Core_v1Api->proxyCoreV1GETNamespacedServiceWithPath")

    

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "GET", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "", classOf[String]).asInstanceOf[String])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * 
   * proxy GET requests to Node
   * @param name name of the Node 
   * @return String
   */
  def proxyCoreV1GETNode(name: String): Option[String] = {
    // create path and map variables
    val path = "/api/v1/proxy/nodes/{name}".replaceAll("\\{format\\}", "json").replaceAll("\\{" + "name" + "\\}",apiInvoker.escape(name))

    val contentTypes = List("*/*")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (name == null) throw new Exception("Missing required parameter 'name' when calling Core_v1Api->proxyCoreV1GETNode")

    

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "GET", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "", classOf[String]).asInstanceOf[String])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * 
   * proxy GET requests to Node
   * @param name name of the Node 
   * @param _path path to the resource 
   * @return String
   */
  def proxyCoreV1GETNodeWithPath(name: String, _path: String): Option[String] = {
    // create path and map variables
    val path = "/api/v1/proxy/nodes/{name}/{path}".replaceAll("\\{format\\}", "json").replaceAll("\\{" + "name" + "\\}",apiInvoker.escape(name)).replaceAll("\\{" + "path" + "\\}",apiInvoker.escape(_path))

    val contentTypes = List("*/*")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (name == null) throw new Exception("Missing required parameter 'name' when calling Core_v1Api->proxyCoreV1GETNodeWithPath")

    if (_path == null) throw new Exception("Missing required parameter '_path' when calling Core_v1Api->proxyCoreV1GETNodeWithPath")

    

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "GET", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "", classOf[String]).asInstanceOf[String])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * 
   * proxy HEAD requests to Pod
   * @param name name of the Pod 
   * @param namespace object name and auth scope, such as for teams and projects 
   * @return String
   */
  def proxyCoreV1HEADNamespacedPod(name: String, namespace: String): Option[String] = {
    // create path and map variables
    val path = "/api/v1/proxy/namespaces/{namespace}/pods/{name}".replaceAll("\\{format\\}", "json").replaceAll("\\{" + "name" + "\\}",apiInvoker.escape(name)).replaceAll("\\{" + "namespace" + "\\}",apiInvoker.escape(namespace))

    val contentTypes = List("*/*")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (name == null) throw new Exception("Missing required parameter 'name' when calling Core_v1Api->proxyCoreV1HEADNamespacedPod")

    if (namespace == null) throw new Exception("Missing required parameter 'namespace' when calling Core_v1Api->proxyCoreV1HEADNamespacedPod")

    

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "HEAD", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "", classOf[String]).asInstanceOf[String])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * 
   * proxy HEAD requests to Pod
   * @param name name of the Pod 
   * @param namespace object name and auth scope, such as for teams and projects 
   * @param _path path to the resource 
   * @return String
   */
  def proxyCoreV1HEADNamespacedPodWithPath(name: String, namespace: String, _path: String): Option[String] = {
    // create path and map variables
    val path = "/api/v1/proxy/namespaces/{namespace}/pods/{name}/{path}".replaceAll("\\{format\\}", "json").replaceAll("\\{" + "name" + "\\}",apiInvoker.escape(name)).replaceAll("\\{" + "namespace" + "\\}",apiInvoker.escape(namespace)).replaceAll("\\{" + "path" + "\\}",apiInvoker.escape(_path))

    val contentTypes = List("*/*")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (name == null) throw new Exception("Missing required parameter 'name' when calling Core_v1Api->proxyCoreV1HEADNamespacedPodWithPath")

    if (namespace == null) throw new Exception("Missing required parameter 'namespace' when calling Core_v1Api->proxyCoreV1HEADNamespacedPodWithPath")

    if (_path == null) throw new Exception("Missing required parameter '_path' when calling Core_v1Api->proxyCoreV1HEADNamespacedPodWithPath")

    

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "HEAD", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "", classOf[String]).asInstanceOf[String])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * 
   * proxy HEAD requests to Service
   * @param name name of the Service 
   * @param namespace object name and auth scope, such as for teams and projects 
   * @return String
   */
  def proxyCoreV1HEADNamespacedService(name: String, namespace: String): Option[String] = {
    // create path and map variables
    val path = "/api/v1/proxy/namespaces/{namespace}/services/{name}".replaceAll("\\{format\\}", "json").replaceAll("\\{" + "name" + "\\}",apiInvoker.escape(name)).replaceAll("\\{" + "namespace" + "\\}",apiInvoker.escape(namespace))

    val contentTypes = List("*/*")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (name == null) throw new Exception("Missing required parameter 'name' when calling Core_v1Api->proxyCoreV1HEADNamespacedService")

    if (namespace == null) throw new Exception("Missing required parameter 'namespace' when calling Core_v1Api->proxyCoreV1HEADNamespacedService")

    

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "HEAD", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "", classOf[String]).asInstanceOf[String])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * 
   * proxy HEAD requests to Service
   * @param name name of the Service 
   * @param namespace object name and auth scope, such as for teams and projects 
   * @param _path path to the resource 
   * @return String
   */
  def proxyCoreV1HEADNamespacedServiceWithPath(name: String, namespace: String, _path: String): Option[String] = {
    // create path and map variables
    val path = "/api/v1/proxy/namespaces/{namespace}/services/{name}/{path}".replaceAll("\\{format\\}", "json").replaceAll("\\{" + "name" + "\\}",apiInvoker.escape(name)).replaceAll("\\{" + "namespace" + "\\}",apiInvoker.escape(namespace)).replaceAll("\\{" + "path" + "\\}",apiInvoker.escape(_path))

    val contentTypes = List("*/*")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (name == null) throw new Exception("Missing required parameter 'name' when calling Core_v1Api->proxyCoreV1HEADNamespacedServiceWithPath")

    if (namespace == null) throw new Exception("Missing required parameter 'namespace' when calling Core_v1Api->proxyCoreV1HEADNamespacedServiceWithPath")

    if (_path == null) throw new Exception("Missing required parameter '_path' when calling Core_v1Api->proxyCoreV1HEADNamespacedServiceWithPath")

    

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "HEAD", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "", classOf[String]).asInstanceOf[String])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * 
   * proxy HEAD requests to Node
   * @param name name of the Node 
   * @return String
   */
  def proxyCoreV1HEADNode(name: String): Option[String] = {
    // create path and map variables
    val path = "/api/v1/proxy/nodes/{name}".replaceAll("\\{format\\}", "json").replaceAll("\\{" + "name" + "\\}",apiInvoker.escape(name))

    val contentTypes = List("*/*")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (name == null) throw new Exception("Missing required parameter 'name' when calling Core_v1Api->proxyCoreV1HEADNode")

    

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "HEAD", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "", classOf[String]).asInstanceOf[String])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * 
   * proxy HEAD requests to Node
   * @param name name of the Node 
   * @param _path path to the resource 
   * @return String
   */
  def proxyCoreV1HEADNodeWithPath(name: String, _path: String): Option[String] = {
    // create path and map variables
    val path = "/api/v1/proxy/nodes/{name}/{path}".replaceAll("\\{format\\}", "json").replaceAll("\\{" + "name" + "\\}",apiInvoker.escape(name)).replaceAll("\\{" + "path" + "\\}",apiInvoker.escape(_path))

    val contentTypes = List("*/*")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (name == null) throw new Exception("Missing required parameter 'name' when calling Core_v1Api->proxyCoreV1HEADNodeWithPath")

    if (_path == null) throw new Exception("Missing required parameter '_path' when calling Core_v1Api->proxyCoreV1HEADNodeWithPath")

    

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "HEAD", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "", classOf[String]).asInstanceOf[String])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * 
   * proxy OPTIONS requests to Pod
   * @param name name of the Pod 
   * @param namespace object name and auth scope, such as for teams and projects 
   * @return String
   */
  def proxyCoreV1OPTIONSNamespacedPod(name: String, namespace: String): Option[String] = {
    // create path and map variables
    val path = "/api/v1/proxy/namespaces/{namespace}/pods/{name}".replaceAll("\\{format\\}", "json").replaceAll("\\{" + "name" + "\\}",apiInvoker.escape(name)).replaceAll("\\{" + "namespace" + "\\}",apiInvoker.escape(namespace))

    val contentTypes = List("*/*")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (name == null) throw new Exception("Missing required parameter 'name' when calling Core_v1Api->proxyCoreV1OPTIONSNamespacedPod")

    if (namespace == null) throw new Exception("Missing required parameter 'namespace' when calling Core_v1Api->proxyCoreV1OPTIONSNamespacedPod")

    

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "OPTIONS", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "", classOf[String]).asInstanceOf[String])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * 
   * proxy OPTIONS requests to Pod
   * @param name name of the Pod 
   * @param namespace object name and auth scope, such as for teams and projects 
   * @param _path path to the resource 
   * @return String
   */
  def proxyCoreV1OPTIONSNamespacedPodWithPath(name: String, namespace: String, _path: String): Option[String] = {
    // create path and map variables
    val path = "/api/v1/proxy/namespaces/{namespace}/pods/{name}/{path}".replaceAll("\\{format\\}", "json").replaceAll("\\{" + "name" + "\\}",apiInvoker.escape(name)).replaceAll("\\{" + "namespace" + "\\}",apiInvoker.escape(namespace)).replaceAll("\\{" + "path" + "\\}",apiInvoker.escape(_path))

    val contentTypes = List("*/*")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (name == null) throw new Exception("Missing required parameter 'name' when calling Core_v1Api->proxyCoreV1OPTIONSNamespacedPodWithPath")

    if (namespace == null) throw new Exception("Missing required parameter 'namespace' when calling Core_v1Api->proxyCoreV1OPTIONSNamespacedPodWithPath")

    if (_path == null) throw new Exception("Missing required parameter '_path' when calling Core_v1Api->proxyCoreV1OPTIONSNamespacedPodWithPath")

    

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "OPTIONS", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "", classOf[String]).asInstanceOf[String])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * 
   * proxy OPTIONS requests to Service
   * @param name name of the Service 
   * @param namespace object name and auth scope, such as for teams and projects 
   * @return String
   */
  def proxyCoreV1OPTIONSNamespacedService(name: String, namespace: String): Option[String] = {
    // create path and map variables
    val path = "/api/v1/proxy/namespaces/{namespace}/services/{name}".replaceAll("\\{format\\}", "json").replaceAll("\\{" + "name" + "\\}",apiInvoker.escape(name)).replaceAll("\\{" + "namespace" + "\\}",apiInvoker.escape(namespace))

    val contentTypes = List("*/*")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (name == null) throw new Exception("Missing required parameter 'name' when calling Core_v1Api->proxyCoreV1OPTIONSNamespacedService")

    if (namespace == null) throw new Exception("Missing required parameter 'namespace' when calling Core_v1Api->proxyCoreV1OPTIONSNamespacedService")

    

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "OPTIONS", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "", classOf[String]).asInstanceOf[String])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * 
   * proxy OPTIONS requests to Service
   * @param name name of the Service 
   * @param namespace object name and auth scope, such as for teams and projects 
   * @param _path path to the resource 
   * @return String
   */
  def proxyCoreV1OPTIONSNamespacedServiceWithPath(name: String, namespace: String, _path: String): Option[String] = {
    // create path and map variables
    val path = "/api/v1/proxy/namespaces/{namespace}/services/{name}/{path}".replaceAll("\\{format\\}", "json").replaceAll("\\{" + "name" + "\\}",apiInvoker.escape(name)).replaceAll("\\{" + "namespace" + "\\}",apiInvoker.escape(namespace)).replaceAll("\\{" + "path" + "\\}",apiInvoker.escape(_path))

    val contentTypes = List("*/*")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (name == null) throw new Exception("Missing required parameter 'name' when calling Core_v1Api->proxyCoreV1OPTIONSNamespacedServiceWithPath")

    if (namespace == null) throw new Exception("Missing required parameter 'namespace' when calling Core_v1Api->proxyCoreV1OPTIONSNamespacedServiceWithPath")

    if (_path == null) throw new Exception("Missing required parameter '_path' when calling Core_v1Api->proxyCoreV1OPTIONSNamespacedServiceWithPath")

    

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "OPTIONS", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "", classOf[String]).asInstanceOf[String])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * 
   * proxy OPTIONS requests to Node
   * @param name name of the Node 
   * @return String
   */
  def proxyCoreV1OPTIONSNode(name: String): Option[String] = {
    // create path and map variables
    val path = "/api/v1/proxy/nodes/{name}".replaceAll("\\{format\\}", "json").replaceAll("\\{" + "name" + "\\}",apiInvoker.escape(name))

    val contentTypes = List("*/*")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (name == null) throw new Exception("Missing required parameter 'name' when calling Core_v1Api->proxyCoreV1OPTIONSNode")

    

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "OPTIONS", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "", classOf[String]).asInstanceOf[String])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * 
   * proxy OPTIONS requests to Node
   * @param name name of the Node 
   * @param _path path to the resource 
   * @return String
   */
  def proxyCoreV1OPTIONSNodeWithPath(name: String, _path: String): Option[String] = {
    // create path and map variables
    val path = "/api/v1/proxy/nodes/{name}/{path}".replaceAll("\\{format\\}", "json").replaceAll("\\{" + "name" + "\\}",apiInvoker.escape(name)).replaceAll("\\{" + "path" + "\\}",apiInvoker.escape(_path))

    val contentTypes = List("*/*")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (name == null) throw new Exception("Missing required parameter 'name' when calling Core_v1Api->proxyCoreV1OPTIONSNodeWithPath")

    if (_path == null) throw new Exception("Missing required parameter '_path' when calling Core_v1Api->proxyCoreV1OPTIONSNodeWithPath")

    

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "OPTIONS", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "", classOf[String]).asInstanceOf[String])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * 
   * proxy PATCH requests to Pod
   * @param name name of the Pod 
   * @param namespace object name and auth scope, such as for teams and projects 
   * @return String
   */
  def proxyCoreV1PATCHNamespacedPod(name: String, namespace: String): Option[String] = {
    // create path and map variables
    val path = "/api/v1/proxy/namespaces/{namespace}/pods/{name}".replaceAll("\\{format\\}", "json").replaceAll("\\{" + "name" + "\\}",apiInvoker.escape(name)).replaceAll("\\{" + "namespace" + "\\}",apiInvoker.escape(namespace))

    val contentTypes = List("*/*")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (name == null) throw new Exception("Missing required parameter 'name' when calling Core_v1Api->proxyCoreV1PATCHNamespacedPod")

    if (namespace == null) throw new Exception("Missing required parameter 'namespace' when calling Core_v1Api->proxyCoreV1PATCHNamespacedPod")

    

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "PATCH", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "", classOf[String]).asInstanceOf[String])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * 
   * proxy PATCH requests to Pod
   * @param name name of the Pod 
   * @param namespace object name and auth scope, such as for teams and projects 
   * @param _path path to the resource 
   * @return String
   */
  def proxyCoreV1PATCHNamespacedPodWithPath(name: String, namespace: String, _path: String): Option[String] = {
    // create path and map variables
    val path = "/api/v1/proxy/namespaces/{namespace}/pods/{name}/{path}".replaceAll("\\{format\\}", "json").replaceAll("\\{" + "name" + "\\}",apiInvoker.escape(name)).replaceAll("\\{" + "namespace" + "\\}",apiInvoker.escape(namespace)).replaceAll("\\{" + "path" + "\\}",apiInvoker.escape(_path))

    val contentTypes = List("*/*")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (name == null) throw new Exception("Missing required parameter 'name' when calling Core_v1Api->proxyCoreV1PATCHNamespacedPodWithPath")

    if (namespace == null) throw new Exception("Missing required parameter 'namespace' when calling Core_v1Api->proxyCoreV1PATCHNamespacedPodWithPath")

    if (_path == null) throw new Exception("Missing required parameter '_path' when calling Core_v1Api->proxyCoreV1PATCHNamespacedPodWithPath")

    

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "PATCH", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "", classOf[String]).asInstanceOf[String])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * 
   * proxy PATCH requests to Service
   * @param name name of the Service 
   * @param namespace object name and auth scope, such as for teams and projects 
   * @return String
   */
  def proxyCoreV1PATCHNamespacedService(name: String, namespace: String): Option[String] = {
    // create path and map variables
    val path = "/api/v1/proxy/namespaces/{namespace}/services/{name}".replaceAll("\\{format\\}", "json").replaceAll("\\{" + "name" + "\\}",apiInvoker.escape(name)).replaceAll("\\{" + "namespace" + "\\}",apiInvoker.escape(namespace))

    val contentTypes = List("*/*")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (name == null) throw new Exception("Missing required parameter 'name' when calling Core_v1Api->proxyCoreV1PATCHNamespacedService")

    if (namespace == null) throw new Exception("Missing required parameter 'namespace' when calling Core_v1Api->proxyCoreV1PATCHNamespacedService")

    

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "PATCH", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "", classOf[String]).asInstanceOf[String])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * 
   * proxy PATCH requests to Service
   * @param name name of the Service 
   * @param namespace object name and auth scope, such as for teams and projects 
   * @param _path path to the resource 
   * @return String
   */
  def proxyCoreV1PATCHNamespacedServiceWithPath(name: String, namespace: String, _path: String): Option[String] = {
    // create path and map variables
    val path = "/api/v1/proxy/namespaces/{namespace}/services/{name}/{path}".replaceAll("\\{format\\}", "json").replaceAll("\\{" + "name" + "\\}",apiInvoker.escape(name)).replaceAll("\\{" + "namespace" + "\\}",apiInvoker.escape(namespace)).replaceAll("\\{" + "path" + "\\}",apiInvoker.escape(_path))

    val contentTypes = List("*/*")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (name == null) throw new Exception("Missing required parameter 'name' when calling Core_v1Api->proxyCoreV1PATCHNamespacedServiceWithPath")

    if (namespace == null) throw new Exception("Missing required parameter 'namespace' when calling Core_v1Api->proxyCoreV1PATCHNamespacedServiceWithPath")

    if (_path == null) throw new Exception("Missing required parameter '_path' when calling Core_v1Api->proxyCoreV1PATCHNamespacedServiceWithPath")

    

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "PATCH", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "", classOf[String]).asInstanceOf[String])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * 
   * proxy PATCH requests to Node
   * @param name name of the Node 
   * @return String
   */
  def proxyCoreV1PATCHNode(name: String): Option[String] = {
    // create path and map variables
    val path = "/api/v1/proxy/nodes/{name}".replaceAll("\\{format\\}", "json").replaceAll("\\{" + "name" + "\\}",apiInvoker.escape(name))

    val contentTypes = List("*/*")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (name == null) throw new Exception("Missing required parameter 'name' when calling Core_v1Api->proxyCoreV1PATCHNode")

    

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "PATCH", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "", classOf[String]).asInstanceOf[String])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * 
   * proxy PATCH requests to Node
   * @param name name of the Node 
   * @param _path path to the resource 
   * @return String
   */
  def proxyCoreV1PATCHNodeWithPath(name: String, _path: String): Option[String] = {
    // create path and map variables
    val path = "/api/v1/proxy/nodes/{name}/{path}".replaceAll("\\{format\\}", "json").replaceAll("\\{" + "name" + "\\}",apiInvoker.escape(name)).replaceAll("\\{" + "path" + "\\}",apiInvoker.escape(_path))

    val contentTypes = List("*/*")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (name == null) throw new Exception("Missing required parameter 'name' when calling Core_v1Api->proxyCoreV1PATCHNodeWithPath")

    if (_path == null) throw new Exception("Missing required parameter '_path' when calling Core_v1Api->proxyCoreV1PATCHNodeWithPath")

    

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "PATCH", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "", classOf[String]).asInstanceOf[String])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * 
   * proxy POST requests to Pod
   * @param name name of the Pod 
   * @param namespace object name and auth scope, such as for teams and projects 
   * @return String
   */
  def proxyCoreV1POSTNamespacedPod(name: String, namespace: String): Option[String] = {
    // create path and map variables
    val path = "/api/v1/proxy/namespaces/{namespace}/pods/{name}".replaceAll("\\{format\\}", "json").replaceAll("\\{" + "name" + "\\}",apiInvoker.escape(name)).replaceAll("\\{" + "namespace" + "\\}",apiInvoker.escape(namespace))

    val contentTypes = List("*/*")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (name == null) throw new Exception("Missing required parameter 'name' when calling Core_v1Api->proxyCoreV1POSTNamespacedPod")

    if (namespace == null) throw new Exception("Missing required parameter 'namespace' when calling Core_v1Api->proxyCoreV1POSTNamespacedPod")

    

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "POST", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "", classOf[String]).asInstanceOf[String])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * 
   * proxy POST requests to Pod
   * @param name name of the Pod 
   * @param namespace object name and auth scope, such as for teams and projects 
   * @param _path path to the resource 
   * @return String
   */
  def proxyCoreV1POSTNamespacedPodWithPath(name: String, namespace: String, _path: String): Option[String] = {
    // create path and map variables
    val path = "/api/v1/proxy/namespaces/{namespace}/pods/{name}/{path}".replaceAll("\\{format\\}", "json").replaceAll("\\{" + "name" + "\\}",apiInvoker.escape(name)).replaceAll("\\{" + "namespace" + "\\}",apiInvoker.escape(namespace)).replaceAll("\\{" + "path" + "\\}",apiInvoker.escape(_path))

    val contentTypes = List("*/*")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (name == null) throw new Exception("Missing required parameter 'name' when calling Core_v1Api->proxyCoreV1POSTNamespacedPodWithPath")

    if (namespace == null) throw new Exception("Missing required parameter 'namespace' when calling Core_v1Api->proxyCoreV1POSTNamespacedPodWithPath")

    if (_path == null) throw new Exception("Missing required parameter '_path' when calling Core_v1Api->proxyCoreV1POSTNamespacedPodWithPath")

    

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "POST", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "", classOf[String]).asInstanceOf[String])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * 
   * proxy POST requests to Service
   * @param name name of the Service 
   * @param namespace object name and auth scope, such as for teams and projects 
   * @return String
   */
  def proxyCoreV1POSTNamespacedService(name: String, namespace: String): Option[String] = {
    // create path and map variables
    val path = "/api/v1/proxy/namespaces/{namespace}/services/{name}".replaceAll("\\{format\\}", "json").replaceAll("\\{" + "name" + "\\}",apiInvoker.escape(name)).replaceAll("\\{" + "namespace" + "\\}",apiInvoker.escape(namespace))

    val contentTypes = List("*/*")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (name == null) throw new Exception("Missing required parameter 'name' when calling Core_v1Api->proxyCoreV1POSTNamespacedService")

    if (namespace == null) throw new Exception("Missing required parameter 'namespace' when calling Core_v1Api->proxyCoreV1POSTNamespacedService")

    

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "POST", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "", classOf[String]).asInstanceOf[String])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * 
   * proxy POST requests to Service
   * @param name name of the Service 
   * @param namespace object name and auth scope, such as for teams and projects 
   * @param _path path to the resource 
   * @return String
   */
  def proxyCoreV1POSTNamespacedServiceWithPath(name: String, namespace: String, _path: String): Option[String] = {
    // create path and map variables
    val path = "/api/v1/proxy/namespaces/{namespace}/services/{name}/{path}".replaceAll("\\{format\\}", "json").replaceAll("\\{" + "name" + "\\}",apiInvoker.escape(name)).replaceAll("\\{" + "namespace" + "\\}",apiInvoker.escape(namespace)).replaceAll("\\{" + "path" + "\\}",apiInvoker.escape(_path))

    val contentTypes = List("*/*")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (name == null) throw new Exception("Missing required parameter 'name' when calling Core_v1Api->proxyCoreV1POSTNamespacedServiceWithPath")

    if (namespace == null) throw new Exception("Missing required parameter 'namespace' when calling Core_v1Api->proxyCoreV1POSTNamespacedServiceWithPath")

    if (_path == null) throw new Exception("Missing required parameter '_path' when calling Core_v1Api->proxyCoreV1POSTNamespacedServiceWithPath")

    

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "POST", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "", classOf[String]).asInstanceOf[String])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * 
   * proxy POST requests to Node
   * @param name name of the Node 
   * @return String
   */
  def proxyCoreV1POSTNode(name: String): Option[String] = {
    // create path and map variables
    val path = "/api/v1/proxy/nodes/{name}".replaceAll("\\{format\\}", "json").replaceAll("\\{" + "name" + "\\}",apiInvoker.escape(name))

    val contentTypes = List("*/*")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (name == null) throw new Exception("Missing required parameter 'name' when calling Core_v1Api->proxyCoreV1POSTNode")

    

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "POST", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "", classOf[String]).asInstanceOf[String])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * 
   * proxy POST requests to Node
   * @param name name of the Node 
   * @param _path path to the resource 
   * @return String
   */
  def proxyCoreV1POSTNodeWithPath(name: String, _path: String): Option[String] = {
    // create path and map variables
    val path = "/api/v1/proxy/nodes/{name}/{path}".replaceAll("\\{format\\}", "json").replaceAll("\\{" + "name" + "\\}",apiInvoker.escape(name)).replaceAll("\\{" + "path" + "\\}",apiInvoker.escape(_path))

    val contentTypes = List("*/*")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (name == null) throw new Exception("Missing required parameter 'name' when calling Core_v1Api->proxyCoreV1POSTNodeWithPath")

    if (_path == null) throw new Exception("Missing required parameter '_path' when calling Core_v1Api->proxyCoreV1POSTNodeWithPath")

    

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "POST", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "", classOf[String]).asInstanceOf[String])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * 
   * proxy PUT requests to Pod
   * @param name name of the Pod 
   * @param namespace object name and auth scope, such as for teams and projects 
   * @return String
   */
  def proxyCoreV1PUTNamespacedPod(name: String, namespace: String): Option[String] = {
    // create path and map variables
    val path = "/api/v1/proxy/namespaces/{namespace}/pods/{name}".replaceAll("\\{format\\}", "json").replaceAll("\\{" + "name" + "\\}",apiInvoker.escape(name)).replaceAll("\\{" + "namespace" + "\\}",apiInvoker.escape(namespace))

    val contentTypes = List("*/*")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (name == null) throw new Exception("Missing required parameter 'name' when calling Core_v1Api->proxyCoreV1PUTNamespacedPod")

    if (namespace == null) throw new Exception("Missing required parameter 'namespace' when calling Core_v1Api->proxyCoreV1PUTNamespacedPod")

    

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "PUT", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "", classOf[String]).asInstanceOf[String])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * 
   * proxy PUT requests to Pod
   * @param name name of the Pod 
   * @param namespace object name and auth scope, such as for teams and projects 
   * @param _path path to the resource 
   * @return String
   */
  def proxyCoreV1PUTNamespacedPodWithPath(name: String, namespace: String, _path: String): Option[String] = {
    // create path and map variables
    val path = "/api/v1/proxy/namespaces/{namespace}/pods/{name}/{path}".replaceAll("\\{format\\}", "json").replaceAll("\\{" + "name" + "\\}",apiInvoker.escape(name)).replaceAll("\\{" + "namespace" + "\\}",apiInvoker.escape(namespace)).replaceAll("\\{" + "path" + "\\}",apiInvoker.escape(_path))

    val contentTypes = List("*/*")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (name == null) throw new Exception("Missing required parameter 'name' when calling Core_v1Api->proxyCoreV1PUTNamespacedPodWithPath")

    if (namespace == null) throw new Exception("Missing required parameter 'namespace' when calling Core_v1Api->proxyCoreV1PUTNamespacedPodWithPath")

    if (_path == null) throw new Exception("Missing required parameter '_path' when calling Core_v1Api->proxyCoreV1PUTNamespacedPodWithPath")

    

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "PUT", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "", classOf[String]).asInstanceOf[String])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * 
   * proxy PUT requests to Service
   * @param name name of the Service 
   * @param namespace object name and auth scope, such as for teams and projects 
   * @return String
   */
  def proxyCoreV1PUTNamespacedService(name: String, namespace: String): Option[String] = {
    // create path and map variables
    val path = "/api/v1/proxy/namespaces/{namespace}/services/{name}".replaceAll("\\{format\\}", "json").replaceAll("\\{" + "name" + "\\}",apiInvoker.escape(name)).replaceAll("\\{" + "namespace" + "\\}",apiInvoker.escape(namespace))

    val contentTypes = List("*/*")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (name == null) throw new Exception("Missing required parameter 'name' when calling Core_v1Api->proxyCoreV1PUTNamespacedService")

    if (namespace == null) throw new Exception("Missing required parameter 'namespace' when calling Core_v1Api->proxyCoreV1PUTNamespacedService")

    

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "PUT", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "", classOf[String]).asInstanceOf[String])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * 
   * proxy PUT requests to Service
   * @param name name of the Service 
   * @param namespace object name and auth scope, such as for teams and projects 
   * @param _path path to the resource 
   * @return String
   */
  def proxyCoreV1PUTNamespacedServiceWithPath(name: String, namespace: String, _path: String): Option[String] = {
    // create path and map variables
    val path = "/api/v1/proxy/namespaces/{namespace}/services/{name}/{path}".replaceAll("\\{format\\}", "json").replaceAll("\\{" + "name" + "\\}",apiInvoker.escape(name)).replaceAll("\\{" + "namespace" + "\\}",apiInvoker.escape(namespace)).replaceAll("\\{" + "path" + "\\}",apiInvoker.escape(_path))

    val contentTypes = List("*/*")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (name == null) throw new Exception("Missing required parameter 'name' when calling Core_v1Api->proxyCoreV1PUTNamespacedServiceWithPath")

    if (namespace == null) throw new Exception("Missing required parameter 'namespace' when calling Core_v1Api->proxyCoreV1PUTNamespacedServiceWithPath")

    if (_path == null) throw new Exception("Missing required parameter '_path' when calling Core_v1Api->proxyCoreV1PUTNamespacedServiceWithPath")

    

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "PUT", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "", classOf[String]).asInstanceOf[String])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * 
   * proxy PUT requests to Node
   * @param name name of the Node 
   * @return String
   */
  def proxyCoreV1PUTNode(name: String): Option[String] = {
    // create path and map variables
    val path = "/api/v1/proxy/nodes/{name}".replaceAll("\\{format\\}", "json").replaceAll("\\{" + "name" + "\\}",apiInvoker.escape(name))

    val contentTypes = List("*/*")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (name == null) throw new Exception("Missing required parameter 'name' when calling Core_v1Api->proxyCoreV1PUTNode")

    

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "PUT", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "", classOf[String]).asInstanceOf[String])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * 
   * proxy PUT requests to Node
   * @param name name of the Node 
   * @param _path path to the resource 
   * @return String
   */
  def proxyCoreV1PUTNodeWithPath(name: String, _path: String): Option[String] = {
    // create path and map variables
    val path = "/api/v1/proxy/nodes/{name}/{path}".replaceAll("\\{format\\}", "json").replaceAll("\\{" + "name" + "\\}",apiInvoker.escape(name)).replaceAll("\\{" + "path" + "\\}",apiInvoker.escape(_path))

    val contentTypes = List("*/*")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (name == null) throw new Exception("Missing required parameter 'name' when calling Core_v1Api->proxyCoreV1PUTNodeWithPath")

    if (_path == null) throw new Exception("Missing required parameter '_path' when calling Core_v1Api->proxyCoreV1PUTNodeWithPath")

    

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "PUT", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "", classOf[String]).asInstanceOf[String])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * 
   * read the specified ComponentStatus
   * @param name name of the ComponentStatus 
   * @param pretty If &#39;true&#39;, then the output is pretty printed. (optional)
   * @return IoK8sApiCoreV1ComponentStatus
   */
  def readCoreV1ComponentStatus(name: String, pretty: Option[String] = None): Option[IoK8sApiCoreV1ComponentStatus] = {
    // create path and map variables
    val path = "/api/v1/componentstatuses/{name}".replaceAll("\\{format\\}", "json").replaceAll("\\{" + "name" + "\\}",apiInvoker.escape(name))

    val contentTypes = List("*/*")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (name == null) throw new Exception("Missing required parameter 'name' when calling Core_v1Api->readCoreV1ComponentStatus")

    pretty.map(paramVal => queryParams += "pretty" -> paramVal.toString)
    

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "GET", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "", classOf[IoK8sApiCoreV1ComponentStatus]).asInstanceOf[IoK8sApiCoreV1ComponentStatus])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * 
   * read the specified Namespace
   * @param name name of the Namespace 
   * @param pretty If &#39;true&#39;, then the output is pretty printed. (optional)
   * @param exact Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. (optional)
   * @param export Should this value be exported.  Export strips fields that a user can not specify. (optional)
   * @return IoK8sApiCoreV1Namespace
   */
  def readCoreV1Namespace(name: String, pretty: Option[String] = None, exact: Option[Boolean] = None, export: Option[Boolean] = None): Option[IoK8sApiCoreV1Namespace] = {
    // create path and map variables
    val path = "/api/v1/namespaces/{name}".replaceAll("\\{format\\}", "json").replaceAll("\\{" + "name" + "\\}",apiInvoker.escape(name))

    val contentTypes = List("*/*")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (name == null) throw new Exception("Missing required parameter 'name' when calling Core_v1Api->readCoreV1Namespace")

    pretty.map(paramVal => queryParams += "pretty" -> paramVal.toString)
    exact.map(paramVal => queryParams += "exact" -> paramVal.toString)
    export.map(paramVal => queryParams += "export" -> paramVal.toString)
    

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "GET", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "", classOf[IoK8sApiCoreV1Namespace]).asInstanceOf[IoK8sApiCoreV1Namespace])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * 
   * read status of the specified Namespace
   * @param name name of the Namespace 
   * @param pretty If &#39;true&#39;, then the output is pretty printed. (optional)
   * @return IoK8sApiCoreV1Namespace
   */
  def readCoreV1NamespaceStatus(name: String, pretty: Option[String] = None): Option[IoK8sApiCoreV1Namespace] = {
    // create path and map variables
    val path = "/api/v1/namespaces/{name}/status".replaceAll("\\{format\\}", "json").replaceAll("\\{" + "name" + "\\}",apiInvoker.escape(name))

    val contentTypes = List("*/*")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (name == null) throw new Exception("Missing required parameter 'name' when calling Core_v1Api->readCoreV1NamespaceStatus")

    pretty.map(paramVal => queryParams += "pretty" -> paramVal.toString)
    

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "GET", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "", classOf[IoK8sApiCoreV1Namespace]).asInstanceOf[IoK8sApiCoreV1Namespace])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * 
   * read the specified ConfigMap
   * @param name name of the ConfigMap 
   * @param namespace object name and auth scope, such as for teams and projects 
   * @param pretty If &#39;true&#39;, then the output is pretty printed. (optional)
   * @param exact Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. (optional)
   * @param export Should this value be exported.  Export strips fields that a user can not specify. (optional)
   * @return IoK8sApiCoreV1ConfigMap
   */
  def readCoreV1NamespacedConfigMap(name: String, namespace: String, pretty: Option[String] = None, exact: Option[Boolean] = None, export: Option[Boolean] = None): Option[IoK8sApiCoreV1ConfigMap] = {
    // create path and map variables
    val path = "/api/v1/namespaces/{namespace}/configmaps/{name}".replaceAll("\\{format\\}", "json").replaceAll("\\{" + "name" + "\\}",apiInvoker.escape(name)).replaceAll("\\{" + "namespace" + "\\}",apiInvoker.escape(namespace))

    val contentTypes = List("*/*")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (name == null) throw new Exception("Missing required parameter 'name' when calling Core_v1Api->readCoreV1NamespacedConfigMap")

    if (namespace == null) throw new Exception("Missing required parameter 'namespace' when calling Core_v1Api->readCoreV1NamespacedConfigMap")

    pretty.map(paramVal => queryParams += "pretty" -> paramVal.toString)
    exact.map(paramVal => queryParams += "exact" -> paramVal.toString)
    export.map(paramVal => queryParams += "export" -> paramVal.toString)
    

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "GET", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "", classOf[IoK8sApiCoreV1ConfigMap]).asInstanceOf[IoK8sApiCoreV1ConfigMap])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * 
   * read the specified Endpoints
   * @param name name of the Endpoints 
   * @param namespace object name and auth scope, such as for teams and projects 
   * @param pretty If &#39;true&#39;, then the output is pretty printed. (optional)
   * @param exact Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. (optional)
   * @param export Should this value be exported.  Export strips fields that a user can not specify. (optional)
   * @return IoK8sApiCoreV1Endpoints
   */
  def readCoreV1NamespacedEndpoints(name: String, namespace: String, pretty: Option[String] = None, exact: Option[Boolean] = None, export: Option[Boolean] = None): Option[IoK8sApiCoreV1Endpoints] = {
    // create path and map variables
    val path = "/api/v1/namespaces/{namespace}/endpoints/{name}".replaceAll("\\{format\\}", "json").replaceAll("\\{" + "name" + "\\}",apiInvoker.escape(name)).replaceAll("\\{" + "namespace" + "\\}",apiInvoker.escape(namespace))

    val contentTypes = List("*/*")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (name == null) throw new Exception("Missing required parameter 'name' when calling Core_v1Api->readCoreV1NamespacedEndpoints")

    if (namespace == null) throw new Exception("Missing required parameter 'namespace' when calling Core_v1Api->readCoreV1NamespacedEndpoints")

    pretty.map(paramVal => queryParams += "pretty" -> paramVal.toString)
    exact.map(paramVal => queryParams += "exact" -> paramVal.toString)
    export.map(paramVal => queryParams += "export" -> paramVal.toString)
    

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "GET", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "", classOf[IoK8sApiCoreV1Endpoints]).asInstanceOf[IoK8sApiCoreV1Endpoints])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * 
   * read the specified Event
   * @param name name of the Event 
   * @param namespace object name and auth scope, such as for teams and projects 
   * @param pretty If &#39;true&#39;, then the output is pretty printed. (optional)
   * @param exact Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. (optional)
   * @param export Should this value be exported.  Export strips fields that a user can not specify. (optional)
   * @return IoK8sApiCoreV1Event
   */
  def readCoreV1NamespacedEvent(name: String, namespace: String, pretty: Option[String] = None, exact: Option[Boolean] = None, export: Option[Boolean] = None): Option[IoK8sApiCoreV1Event] = {
    // create path and map variables
    val path = "/api/v1/namespaces/{namespace}/events/{name}".replaceAll("\\{format\\}", "json").replaceAll("\\{" + "name" + "\\}",apiInvoker.escape(name)).replaceAll("\\{" + "namespace" + "\\}",apiInvoker.escape(namespace))

    val contentTypes = List("*/*")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (name == null) throw new Exception("Missing required parameter 'name' when calling Core_v1Api->readCoreV1NamespacedEvent")

    if (namespace == null) throw new Exception("Missing required parameter 'namespace' when calling Core_v1Api->readCoreV1NamespacedEvent")

    pretty.map(paramVal => queryParams += "pretty" -> paramVal.toString)
    exact.map(paramVal => queryParams += "exact" -> paramVal.toString)
    export.map(paramVal => queryParams += "export" -> paramVal.toString)
    

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "GET", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "", classOf[IoK8sApiCoreV1Event]).asInstanceOf[IoK8sApiCoreV1Event])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * 
   * read the specified LimitRange
   * @param name name of the LimitRange 
   * @param namespace object name and auth scope, such as for teams and projects 
   * @param pretty If &#39;true&#39;, then the output is pretty printed. (optional)
   * @param exact Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. (optional)
   * @param export Should this value be exported.  Export strips fields that a user can not specify. (optional)
   * @return IoK8sApiCoreV1LimitRange
   */
  def readCoreV1NamespacedLimitRange(name: String, namespace: String, pretty: Option[String] = None, exact: Option[Boolean] = None, export: Option[Boolean] = None): Option[IoK8sApiCoreV1LimitRange] = {
    // create path and map variables
    val path = "/api/v1/namespaces/{namespace}/limitranges/{name}".replaceAll("\\{format\\}", "json").replaceAll("\\{" + "name" + "\\}",apiInvoker.escape(name)).replaceAll("\\{" + "namespace" + "\\}",apiInvoker.escape(namespace))

    val contentTypes = List("*/*")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (name == null) throw new Exception("Missing required parameter 'name' when calling Core_v1Api->readCoreV1NamespacedLimitRange")

    if (namespace == null) throw new Exception("Missing required parameter 'namespace' when calling Core_v1Api->readCoreV1NamespacedLimitRange")

    pretty.map(paramVal => queryParams += "pretty" -> paramVal.toString)
    exact.map(paramVal => queryParams += "exact" -> paramVal.toString)
    export.map(paramVal => queryParams += "export" -> paramVal.toString)
    

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "GET", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "", classOf[IoK8sApiCoreV1LimitRange]).asInstanceOf[IoK8sApiCoreV1LimitRange])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * 
   * read the specified PersistentVolumeClaim
   * @param name name of the PersistentVolumeClaim 
   * @param namespace object name and auth scope, such as for teams and projects 
   * @param pretty If &#39;true&#39;, then the output is pretty printed. (optional)
   * @param exact Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. (optional)
   * @param export Should this value be exported.  Export strips fields that a user can not specify. (optional)
   * @return IoK8sApiCoreV1PersistentVolumeClaim
   */
  def readCoreV1NamespacedPersistentVolumeClaim(name: String, namespace: String, pretty: Option[String] = None, exact: Option[Boolean] = None, export: Option[Boolean] = None): Option[IoK8sApiCoreV1PersistentVolumeClaim] = {
    // create path and map variables
    val path = "/api/v1/namespaces/{namespace}/persistentvolumeclaims/{name}".replaceAll("\\{format\\}", "json").replaceAll("\\{" + "name" + "\\}",apiInvoker.escape(name)).replaceAll("\\{" + "namespace" + "\\}",apiInvoker.escape(namespace))

    val contentTypes = List("*/*")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (name == null) throw new Exception("Missing required parameter 'name' when calling Core_v1Api->readCoreV1NamespacedPersistentVolumeClaim")

    if (namespace == null) throw new Exception("Missing required parameter 'namespace' when calling Core_v1Api->readCoreV1NamespacedPersistentVolumeClaim")

    pretty.map(paramVal => queryParams += "pretty" -> paramVal.toString)
    exact.map(paramVal => queryParams += "exact" -> paramVal.toString)
    export.map(paramVal => queryParams += "export" -> paramVal.toString)
    

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "GET", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "", classOf[IoK8sApiCoreV1PersistentVolumeClaim]).asInstanceOf[IoK8sApiCoreV1PersistentVolumeClaim])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * 
   * read status of the specified PersistentVolumeClaim
   * @param name name of the PersistentVolumeClaim 
   * @param namespace object name and auth scope, such as for teams and projects 
   * @param pretty If &#39;true&#39;, then the output is pretty printed. (optional)
   * @return IoK8sApiCoreV1PersistentVolumeClaim
   */
  def readCoreV1NamespacedPersistentVolumeClaimStatus(name: String, namespace: String, pretty: Option[String] = None): Option[IoK8sApiCoreV1PersistentVolumeClaim] = {
    // create path and map variables
    val path = "/api/v1/namespaces/{namespace}/persistentvolumeclaims/{name}/status".replaceAll("\\{format\\}", "json").replaceAll("\\{" + "name" + "\\}",apiInvoker.escape(name)).replaceAll("\\{" + "namespace" + "\\}",apiInvoker.escape(namespace))

    val contentTypes = List("*/*")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (name == null) throw new Exception("Missing required parameter 'name' when calling Core_v1Api->readCoreV1NamespacedPersistentVolumeClaimStatus")

    if (namespace == null) throw new Exception("Missing required parameter 'namespace' when calling Core_v1Api->readCoreV1NamespacedPersistentVolumeClaimStatus")

    pretty.map(paramVal => queryParams += "pretty" -> paramVal.toString)
    

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "GET", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "", classOf[IoK8sApiCoreV1PersistentVolumeClaim]).asInstanceOf[IoK8sApiCoreV1PersistentVolumeClaim])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * 
   * read the specified Pod
   * @param name name of the Pod 
   * @param namespace object name and auth scope, such as for teams and projects 
   * @param pretty If &#39;true&#39;, then the output is pretty printed. (optional)
   * @param exact Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. (optional)
   * @param export Should this value be exported.  Export strips fields that a user can not specify. (optional)
   * @return IoK8sApiCoreV1Pod
   */
  def readCoreV1NamespacedPod(name: String, namespace: String, pretty: Option[String] = None, exact: Option[Boolean] = None, export: Option[Boolean] = None): Option[IoK8sApiCoreV1Pod] = {
    // create path and map variables
    val path = "/api/v1/namespaces/{namespace}/pods/{name}".replaceAll("\\{format\\}", "json").replaceAll("\\{" + "name" + "\\}",apiInvoker.escape(name)).replaceAll("\\{" + "namespace" + "\\}",apiInvoker.escape(namespace))

    val contentTypes = List("*/*")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (name == null) throw new Exception("Missing required parameter 'name' when calling Core_v1Api->readCoreV1NamespacedPod")

    if (namespace == null) throw new Exception("Missing required parameter 'namespace' when calling Core_v1Api->readCoreV1NamespacedPod")

    pretty.map(paramVal => queryParams += "pretty" -> paramVal.toString)
    exact.map(paramVal => queryParams += "exact" -> paramVal.toString)
    export.map(paramVal => queryParams += "export" -> paramVal.toString)
    

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "GET", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "", classOf[IoK8sApiCoreV1Pod]).asInstanceOf[IoK8sApiCoreV1Pod])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * 
   * read log of the specified Pod
   * @param name name of the Pod 
   * @param namespace object name and auth scope, such as for teams and projects 
   * @param container The container for which to stream logs. Defaults to only container if there is one container in the pod. (optional)
   * @param follow Follow the log stream of the pod. Defaults to false. (optional)
   * @param limitBytes If set, the number of bytes to read from the server before terminating the log output. This may not display a complete final line of logging, and may return slightly more or slightly less than the specified limit. (optional)
   * @param pretty If &#39;true&#39;, then the output is pretty printed. (optional)
   * @param previous Return previous terminated container logs. Defaults to false. (optional)
   * @param sinceSeconds A relative time in seconds before the current time from which to show logs. If this value precedes the time a pod was started, only logs since the pod start will be returned. If this value is in the future, no logs will be returned. Only one of sinceSeconds or sinceTime may be specified. (optional)
   * @param tailLines If set, the number of lines from the end of the logs to show. If not specified, logs are shown from the creation of the container or sinceSeconds or sinceTime (optional)
   * @param timestamps If true, add an RFC3339 or RFC3339Nano timestamp at the beginning of every line of log output. Defaults to false. (optional)
   * @return String
   */
  def readCoreV1NamespacedPodLog(name: String, namespace: String, container: Option[String] = None, follow: Option[Boolean] = None, limitBytes: Option[Integer] = None, pretty: Option[String] = None, previous: Option[Boolean] = None, sinceSeconds: Option[Integer] = None, tailLines: Option[Integer] = None, timestamps: Option[Boolean] = None): Option[String] = {
    // create path and map variables
    val path = "/api/v1/namespaces/{namespace}/pods/{name}/log".replaceAll("\\{format\\}", "json").replaceAll("\\{" + "name" + "\\}",apiInvoker.escape(name)).replaceAll("\\{" + "namespace" + "\\}",apiInvoker.escape(namespace))

    val contentTypes = List("*/*")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (name == null) throw new Exception("Missing required parameter 'name' when calling Core_v1Api->readCoreV1NamespacedPodLog")

    if (namespace == null) throw new Exception("Missing required parameter 'namespace' when calling Core_v1Api->readCoreV1NamespacedPodLog")

    container.map(paramVal => queryParams += "container" -> paramVal.toString)
    follow.map(paramVal => queryParams += "follow" -> paramVal.toString)
    limitBytes.map(paramVal => queryParams += "limitBytes" -> paramVal.toString)
    pretty.map(paramVal => queryParams += "pretty" -> paramVal.toString)
    previous.map(paramVal => queryParams += "previous" -> paramVal.toString)
    sinceSeconds.map(paramVal => queryParams += "sinceSeconds" -> paramVal.toString)
    tailLines.map(paramVal => queryParams += "tailLines" -> paramVal.toString)
    timestamps.map(paramVal => queryParams += "timestamps" -> paramVal.toString)
    

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "GET", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "", classOf[String]).asInstanceOf[String])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * 
   * read status of the specified Pod
   * @param name name of the Pod 
   * @param namespace object name and auth scope, such as for teams and projects 
   * @param pretty If &#39;true&#39;, then the output is pretty printed. (optional)
   * @return IoK8sApiCoreV1Pod
   */
  def readCoreV1NamespacedPodStatus(name: String, namespace: String, pretty: Option[String] = None): Option[IoK8sApiCoreV1Pod] = {
    // create path and map variables
    val path = "/api/v1/namespaces/{namespace}/pods/{name}/status".replaceAll("\\{format\\}", "json").replaceAll("\\{" + "name" + "\\}",apiInvoker.escape(name)).replaceAll("\\{" + "namespace" + "\\}",apiInvoker.escape(namespace))

    val contentTypes = List("*/*")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (name == null) throw new Exception("Missing required parameter 'name' when calling Core_v1Api->readCoreV1NamespacedPodStatus")

    if (namespace == null) throw new Exception("Missing required parameter 'namespace' when calling Core_v1Api->readCoreV1NamespacedPodStatus")

    pretty.map(paramVal => queryParams += "pretty" -> paramVal.toString)
    

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "GET", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "", classOf[IoK8sApiCoreV1Pod]).asInstanceOf[IoK8sApiCoreV1Pod])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * 
   * read the specified PodTemplate
   * @param name name of the PodTemplate 
   * @param namespace object name and auth scope, such as for teams and projects 
   * @param pretty If &#39;true&#39;, then the output is pretty printed. (optional)
   * @param exact Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. (optional)
   * @param export Should this value be exported.  Export strips fields that a user can not specify. (optional)
   * @return IoK8sApiCoreV1PodTemplate
   */
  def readCoreV1NamespacedPodTemplate(name: String, namespace: String, pretty: Option[String] = None, exact: Option[Boolean] = None, export: Option[Boolean] = None): Option[IoK8sApiCoreV1PodTemplate] = {
    // create path and map variables
    val path = "/api/v1/namespaces/{namespace}/podtemplates/{name}".replaceAll("\\{format\\}", "json").replaceAll("\\{" + "name" + "\\}",apiInvoker.escape(name)).replaceAll("\\{" + "namespace" + "\\}",apiInvoker.escape(namespace))

    val contentTypes = List("*/*")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (name == null) throw new Exception("Missing required parameter 'name' when calling Core_v1Api->readCoreV1NamespacedPodTemplate")

    if (namespace == null) throw new Exception("Missing required parameter 'namespace' when calling Core_v1Api->readCoreV1NamespacedPodTemplate")

    pretty.map(paramVal => queryParams += "pretty" -> paramVal.toString)
    exact.map(paramVal => queryParams += "exact" -> paramVal.toString)
    export.map(paramVal => queryParams += "export" -> paramVal.toString)
    

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "GET", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "", classOf[IoK8sApiCoreV1PodTemplate]).asInstanceOf[IoK8sApiCoreV1PodTemplate])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * 
   * read the specified ReplicationController
   * @param name name of the ReplicationController 
   * @param namespace object name and auth scope, such as for teams and projects 
   * @param pretty If &#39;true&#39;, then the output is pretty printed. (optional)
   * @param exact Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. (optional)
   * @param export Should this value be exported.  Export strips fields that a user can not specify. (optional)
   * @return IoK8sApiCoreV1ReplicationController
   */
  def readCoreV1NamespacedReplicationController(name: String, namespace: String, pretty: Option[String] = None, exact: Option[Boolean] = None, export: Option[Boolean] = None): Option[IoK8sApiCoreV1ReplicationController] = {
    // create path and map variables
    val path = "/api/v1/namespaces/{namespace}/replicationcontrollers/{name}".replaceAll("\\{format\\}", "json").replaceAll("\\{" + "name" + "\\}",apiInvoker.escape(name)).replaceAll("\\{" + "namespace" + "\\}",apiInvoker.escape(namespace))

    val contentTypes = List("*/*")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (name == null) throw new Exception("Missing required parameter 'name' when calling Core_v1Api->readCoreV1NamespacedReplicationController")

    if (namespace == null) throw new Exception("Missing required parameter 'namespace' when calling Core_v1Api->readCoreV1NamespacedReplicationController")

    pretty.map(paramVal => queryParams += "pretty" -> paramVal.toString)
    exact.map(paramVal => queryParams += "exact" -> paramVal.toString)
    export.map(paramVal => queryParams += "export" -> paramVal.toString)
    

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "GET", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "", classOf[IoK8sApiCoreV1ReplicationController]).asInstanceOf[IoK8sApiCoreV1ReplicationController])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * 
   * read scale of the specified ReplicationController
   * @param name name of the Scale 
   * @param namespace object name and auth scope, such as for teams and projects 
   * @param pretty If &#39;true&#39;, then the output is pretty printed. (optional)
   * @return IoK8sApiAutoscalingV1Scale
   */
  def readCoreV1NamespacedReplicationControllerScale(name: String, namespace: String, pretty: Option[String] = None): Option[IoK8sApiAutoscalingV1Scale] = {
    // create path and map variables
    val path = "/api/v1/namespaces/{namespace}/replicationcontrollers/{name}/scale".replaceAll("\\{format\\}", "json").replaceAll("\\{" + "name" + "\\}",apiInvoker.escape(name)).replaceAll("\\{" + "namespace" + "\\}",apiInvoker.escape(namespace))

    val contentTypes = List("*/*")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (name == null) throw new Exception("Missing required parameter 'name' when calling Core_v1Api->readCoreV1NamespacedReplicationControllerScale")

    if (namespace == null) throw new Exception("Missing required parameter 'namespace' when calling Core_v1Api->readCoreV1NamespacedReplicationControllerScale")

    pretty.map(paramVal => queryParams += "pretty" -> paramVal.toString)
    

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "GET", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "", classOf[IoK8sApiAutoscalingV1Scale]).asInstanceOf[IoK8sApiAutoscalingV1Scale])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * 
   * read status of the specified ReplicationController
   * @param name name of the ReplicationController 
   * @param namespace object name and auth scope, such as for teams and projects 
   * @param pretty If &#39;true&#39;, then the output is pretty printed. (optional)
   * @return IoK8sApiCoreV1ReplicationController
   */
  def readCoreV1NamespacedReplicationControllerStatus(name: String, namespace: String, pretty: Option[String] = None): Option[IoK8sApiCoreV1ReplicationController] = {
    // create path and map variables
    val path = "/api/v1/namespaces/{namespace}/replicationcontrollers/{name}/status".replaceAll("\\{format\\}", "json").replaceAll("\\{" + "name" + "\\}",apiInvoker.escape(name)).replaceAll("\\{" + "namespace" + "\\}",apiInvoker.escape(namespace))

    val contentTypes = List("*/*")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (name == null) throw new Exception("Missing required parameter 'name' when calling Core_v1Api->readCoreV1NamespacedReplicationControllerStatus")

    if (namespace == null) throw new Exception("Missing required parameter 'namespace' when calling Core_v1Api->readCoreV1NamespacedReplicationControllerStatus")

    pretty.map(paramVal => queryParams += "pretty" -> paramVal.toString)
    

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "GET", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "", classOf[IoK8sApiCoreV1ReplicationController]).asInstanceOf[IoK8sApiCoreV1ReplicationController])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * 
   * read the specified ResourceQuota
   * @param name name of the ResourceQuota 
   * @param namespace object name and auth scope, such as for teams and projects 
   * @param pretty If &#39;true&#39;, then the output is pretty printed. (optional)
   * @param exact Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. (optional)
   * @param export Should this value be exported.  Export strips fields that a user can not specify. (optional)
   * @return IoK8sApiCoreV1ResourceQuota
   */
  def readCoreV1NamespacedResourceQuota(name: String, namespace: String, pretty: Option[String] = None, exact: Option[Boolean] = None, export: Option[Boolean] = None): Option[IoK8sApiCoreV1ResourceQuota] = {
    // create path and map variables
    val path = "/api/v1/namespaces/{namespace}/resourcequotas/{name}".replaceAll("\\{format\\}", "json").replaceAll("\\{" + "name" + "\\}",apiInvoker.escape(name)).replaceAll("\\{" + "namespace" + "\\}",apiInvoker.escape(namespace))

    val contentTypes = List("*/*")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (name == null) throw new Exception("Missing required parameter 'name' when calling Core_v1Api->readCoreV1NamespacedResourceQuota")

    if (namespace == null) throw new Exception("Missing required parameter 'namespace' when calling Core_v1Api->readCoreV1NamespacedResourceQuota")

    pretty.map(paramVal => queryParams += "pretty" -> paramVal.toString)
    exact.map(paramVal => queryParams += "exact" -> paramVal.toString)
    export.map(paramVal => queryParams += "export" -> paramVal.toString)
    

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "GET", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "", classOf[IoK8sApiCoreV1ResourceQuota]).asInstanceOf[IoK8sApiCoreV1ResourceQuota])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * 
   * read status of the specified ResourceQuota
   * @param name name of the ResourceQuota 
   * @param namespace object name and auth scope, such as for teams and projects 
   * @param pretty If &#39;true&#39;, then the output is pretty printed. (optional)
   * @return IoK8sApiCoreV1ResourceQuota
   */
  def readCoreV1NamespacedResourceQuotaStatus(name: String, namespace: String, pretty: Option[String] = None): Option[IoK8sApiCoreV1ResourceQuota] = {
    // create path and map variables
    val path = "/api/v1/namespaces/{namespace}/resourcequotas/{name}/status".replaceAll("\\{format\\}", "json").replaceAll("\\{" + "name" + "\\}",apiInvoker.escape(name)).replaceAll("\\{" + "namespace" + "\\}",apiInvoker.escape(namespace))

    val contentTypes = List("*/*")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (name == null) throw new Exception("Missing required parameter 'name' when calling Core_v1Api->readCoreV1NamespacedResourceQuotaStatus")

    if (namespace == null) throw new Exception("Missing required parameter 'namespace' when calling Core_v1Api->readCoreV1NamespacedResourceQuotaStatus")

    pretty.map(paramVal => queryParams += "pretty" -> paramVal.toString)
    

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "GET", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "", classOf[IoK8sApiCoreV1ResourceQuota]).asInstanceOf[IoK8sApiCoreV1ResourceQuota])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * 
   * read the specified Secret
   * @param name name of the Secret 
   * @param namespace object name and auth scope, such as for teams and projects 
   * @param pretty If &#39;true&#39;, then the output is pretty printed. (optional)
   * @param exact Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. (optional)
   * @param export Should this value be exported.  Export strips fields that a user can not specify. (optional)
   * @return IoK8sApiCoreV1Secret
   */
  def readCoreV1NamespacedSecret(name: String, namespace: String, pretty: Option[String] = None, exact: Option[Boolean] = None, export: Option[Boolean] = None): Option[IoK8sApiCoreV1Secret] = {
    // create path and map variables
    val path = "/api/v1/namespaces/{namespace}/secrets/{name}".replaceAll("\\{format\\}", "json").replaceAll("\\{" + "name" + "\\}",apiInvoker.escape(name)).replaceAll("\\{" + "namespace" + "\\}",apiInvoker.escape(namespace))

    val contentTypes = List("*/*")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (name == null) throw new Exception("Missing required parameter 'name' when calling Core_v1Api->readCoreV1NamespacedSecret")

    if (namespace == null) throw new Exception("Missing required parameter 'namespace' when calling Core_v1Api->readCoreV1NamespacedSecret")

    pretty.map(paramVal => queryParams += "pretty" -> paramVal.toString)
    exact.map(paramVal => queryParams += "exact" -> paramVal.toString)
    export.map(paramVal => queryParams += "export" -> paramVal.toString)
    

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "GET", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "", classOf[IoK8sApiCoreV1Secret]).asInstanceOf[IoK8sApiCoreV1Secret])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * 
   * read the specified Service
   * @param name name of the Service 
   * @param namespace object name and auth scope, such as for teams and projects 
   * @param pretty If &#39;true&#39;, then the output is pretty printed. (optional)
   * @param exact Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. (optional)
   * @param export Should this value be exported.  Export strips fields that a user can not specify. (optional)
   * @return IoK8sApiCoreV1Service
   */
  def readCoreV1NamespacedService(name: String, namespace: String, pretty: Option[String] = None, exact: Option[Boolean] = None, export: Option[Boolean] = None): Option[IoK8sApiCoreV1Service] = {
    // create path and map variables
    val path = "/api/v1/namespaces/{namespace}/services/{name}".replaceAll("\\{format\\}", "json").replaceAll("\\{" + "name" + "\\}",apiInvoker.escape(name)).replaceAll("\\{" + "namespace" + "\\}",apiInvoker.escape(namespace))

    val contentTypes = List("*/*")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (name == null) throw new Exception("Missing required parameter 'name' when calling Core_v1Api->readCoreV1NamespacedService")

    if (namespace == null) throw new Exception("Missing required parameter 'namespace' when calling Core_v1Api->readCoreV1NamespacedService")

    pretty.map(paramVal => queryParams += "pretty" -> paramVal.toString)
    exact.map(paramVal => queryParams += "exact" -> paramVal.toString)
    export.map(paramVal => queryParams += "export" -> paramVal.toString)
    

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "GET", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "", classOf[IoK8sApiCoreV1Service]).asInstanceOf[IoK8sApiCoreV1Service])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * 
   * read the specified ServiceAccount
   * @param name name of the ServiceAccount 
   * @param namespace object name and auth scope, such as for teams and projects 
   * @param pretty If &#39;true&#39;, then the output is pretty printed. (optional)
   * @param exact Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. (optional)
   * @param export Should this value be exported.  Export strips fields that a user can not specify. (optional)
   * @return IoK8sApiCoreV1ServiceAccount
   */
  def readCoreV1NamespacedServiceAccount(name: String, namespace: String, pretty: Option[String] = None, exact: Option[Boolean] = None, export: Option[Boolean] = None): Option[IoK8sApiCoreV1ServiceAccount] = {
    // create path and map variables
    val path = "/api/v1/namespaces/{namespace}/serviceaccounts/{name}".replaceAll("\\{format\\}", "json").replaceAll("\\{" + "name" + "\\}",apiInvoker.escape(name)).replaceAll("\\{" + "namespace" + "\\}",apiInvoker.escape(namespace))

    val contentTypes = List("*/*")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (name == null) throw new Exception("Missing required parameter 'name' when calling Core_v1Api->readCoreV1NamespacedServiceAccount")

    if (namespace == null) throw new Exception("Missing required parameter 'namespace' when calling Core_v1Api->readCoreV1NamespacedServiceAccount")

    pretty.map(paramVal => queryParams += "pretty" -> paramVal.toString)
    exact.map(paramVal => queryParams += "exact" -> paramVal.toString)
    export.map(paramVal => queryParams += "export" -> paramVal.toString)
    

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "GET", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "", classOf[IoK8sApiCoreV1ServiceAccount]).asInstanceOf[IoK8sApiCoreV1ServiceAccount])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * 
   * read status of the specified Service
   * @param name name of the Service 
   * @param namespace object name and auth scope, such as for teams and projects 
   * @param pretty If &#39;true&#39;, then the output is pretty printed. (optional)
   * @return IoK8sApiCoreV1Service
   */
  def readCoreV1NamespacedServiceStatus(name: String, namespace: String, pretty: Option[String] = None): Option[IoK8sApiCoreV1Service] = {
    // create path and map variables
    val path = "/api/v1/namespaces/{namespace}/services/{name}/status".replaceAll("\\{format\\}", "json").replaceAll("\\{" + "name" + "\\}",apiInvoker.escape(name)).replaceAll("\\{" + "namespace" + "\\}",apiInvoker.escape(namespace))

    val contentTypes = List("*/*")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (name == null) throw new Exception("Missing required parameter 'name' when calling Core_v1Api->readCoreV1NamespacedServiceStatus")

    if (namespace == null) throw new Exception("Missing required parameter 'namespace' when calling Core_v1Api->readCoreV1NamespacedServiceStatus")

    pretty.map(paramVal => queryParams += "pretty" -> paramVal.toString)
    

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "GET", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "", classOf[IoK8sApiCoreV1Service]).asInstanceOf[IoK8sApiCoreV1Service])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * 
   * read the specified Node
   * @param name name of the Node 
   * @param pretty If &#39;true&#39;, then the output is pretty printed. (optional)
   * @param exact Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. (optional)
   * @param export Should this value be exported.  Export strips fields that a user can not specify. (optional)
   * @return IoK8sApiCoreV1Node
   */
  def readCoreV1Node(name: String, pretty: Option[String] = None, exact: Option[Boolean] = None, export: Option[Boolean] = None): Option[IoK8sApiCoreV1Node] = {
    // create path and map variables
    val path = "/api/v1/nodes/{name}".replaceAll("\\{format\\}", "json").replaceAll("\\{" + "name" + "\\}",apiInvoker.escape(name))

    val contentTypes = List("*/*")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (name == null) throw new Exception("Missing required parameter 'name' when calling Core_v1Api->readCoreV1Node")

    pretty.map(paramVal => queryParams += "pretty" -> paramVal.toString)
    exact.map(paramVal => queryParams += "exact" -> paramVal.toString)
    export.map(paramVal => queryParams += "export" -> paramVal.toString)
    

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "GET", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "", classOf[IoK8sApiCoreV1Node]).asInstanceOf[IoK8sApiCoreV1Node])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * 
   * read status of the specified Node
   * @param name name of the Node 
   * @param pretty If &#39;true&#39;, then the output is pretty printed. (optional)
   * @return IoK8sApiCoreV1Node
   */
  def readCoreV1NodeStatus(name: String, pretty: Option[String] = None): Option[IoK8sApiCoreV1Node] = {
    // create path and map variables
    val path = "/api/v1/nodes/{name}/status".replaceAll("\\{format\\}", "json").replaceAll("\\{" + "name" + "\\}",apiInvoker.escape(name))

    val contentTypes = List("*/*")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (name == null) throw new Exception("Missing required parameter 'name' when calling Core_v1Api->readCoreV1NodeStatus")

    pretty.map(paramVal => queryParams += "pretty" -> paramVal.toString)
    

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "GET", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "", classOf[IoK8sApiCoreV1Node]).asInstanceOf[IoK8sApiCoreV1Node])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * 
   * read the specified PersistentVolume
   * @param name name of the PersistentVolume 
   * @param pretty If &#39;true&#39;, then the output is pretty printed. (optional)
   * @param exact Should the export be exact.  Exact export maintains cluster-specific fields like &#39;Namespace&#39;. (optional)
   * @param export Should this value be exported.  Export strips fields that a user can not specify. (optional)
   * @return IoK8sApiCoreV1PersistentVolume
   */
  def readCoreV1PersistentVolume(name: String, pretty: Option[String] = None, exact: Option[Boolean] = None, export: Option[Boolean] = None): Option[IoK8sApiCoreV1PersistentVolume] = {
    // create path and map variables
    val path = "/api/v1/persistentvolumes/{name}".replaceAll("\\{format\\}", "json").replaceAll("\\{" + "name" + "\\}",apiInvoker.escape(name))

    val contentTypes = List("*/*")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (name == null) throw new Exception("Missing required parameter 'name' when calling Core_v1Api->readCoreV1PersistentVolume")

    pretty.map(paramVal => queryParams += "pretty" -> paramVal.toString)
    exact.map(paramVal => queryParams += "exact" -> paramVal.toString)
    export.map(paramVal => queryParams += "export" -> paramVal.toString)
    

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "GET", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "", classOf[IoK8sApiCoreV1PersistentVolume]).asInstanceOf[IoK8sApiCoreV1PersistentVolume])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * 
   * read status of the specified PersistentVolume
   * @param name name of the PersistentVolume 
   * @param pretty If &#39;true&#39;, then the output is pretty printed. (optional)
   * @return IoK8sApiCoreV1PersistentVolume
   */
  def readCoreV1PersistentVolumeStatus(name: String, pretty: Option[String] = None): Option[IoK8sApiCoreV1PersistentVolume] = {
    // create path and map variables
    val path = "/api/v1/persistentvolumes/{name}/status".replaceAll("\\{format\\}", "json").replaceAll("\\{" + "name" + "\\}",apiInvoker.escape(name))

    val contentTypes = List("*/*")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (name == null) throw new Exception("Missing required parameter 'name' when calling Core_v1Api->readCoreV1PersistentVolumeStatus")

    pretty.map(paramVal => queryParams += "pretty" -> paramVal.toString)
    

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "GET", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "", classOf[IoK8sApiCoreV1PersistentVolume]).asInstanceOf[IoK8sApiCoreV1PersistentVolume])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * 
   * replace the specified Namespace
   * @param name name of the Namespace 
   * @param body  
   * @param pretty If &#39;true&#39;, then the output is pretty printed. (optional)
   * @return IoK8sApiCoreV1Namespace
   */
  def replaceCoreV1Namespace(name: String, body: IoK8sApiCoreV1Namespace, pretty: Option[String] = None): Option[IoK8sApiCoreV1Namespace] = {
    // create path and map variables
    val path = "/api/v1/namespaces/{name}".replaceAll("\\{format\\}", "json").replaceAll("\\{" + "name" + "\\}",apiInvoker.escape(name))

    val contentTypes = List("*/*")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (name == null) throw new Exception("Missing required parameter 'name' when calling Core_v1Api->replaceCoreV1Namespace")

    if (body == null) throw new Exception("Missing required parameter 'body' when calling Core_v1Api->replaceCoreV1Namespace")

    pretty.map(paramVal => queryParams += "pretty" -> paramVal.toString)
    

    var postBody: AnyRef = body

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "PUT", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "", classOf[IoK8sApiCoreV1Namespace]).asInstanceOf[IoK8sApiCoreV1Namespace])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * 
   * replace finalize of the specified Namespace
   * @param name name of the Namespace 
   * @param body  
   * @param pretty If &#39;true&#39;, then the output is pretty printed. (optional)
   * @return IoK8sApiCoreV1Namespace
   */
  def replaceCoreV1NamespaceFinalize(name: String, body: IoK8sApiCoreV1Namespace, pretty: Option[String] = None): Option[IoK8sApiCoreV1Namespace] = {
    // create path and map variables
    val path = "/api/v1/namespaces/{name}/finalize".replaceAll("\\{format\\}", "json").replaceAll("\\{" + "name" + "\\}",apiInvoker.escape(name))

    val contentTypes = List("*/*")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (name == null) throw new Exception("Missing required parameter 'name' when calling Core_v1Api->replaceCoreV1NamespaceFinalize")

    if (body == null) throw new Exception("Missing required parameter 'body' when calling Core_v1Api->replaceCoreV1NamespaceFinalize")

    pretty.map(paramVal => queryParams += "pretty" -> paramVal.toString)
    

    var postBody: AnyRef = body

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "PUT", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "", classOf[IoK8sApiCoreV1Namespace]).asInstanceOf[IoK8sApiCoreV1Namespace])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * 
   * replace status of the specified Namespace
   * @param name name of the Namespace 
   * @param body  
   * @param pretty If &#39;true&#39;, then the output is pretty printed. (optional)
   * @return IoK8sApiCoreV1Namespace
   */
  def replaceCoreV1NamespaceStatus(name: String, body: IoK8sApiCoreV1Namespace, pretty: Option[String] = None): Option[IoK8sApiCoreV1Namespace] = {
    // create path and map variables
    val path = "/api/v1/namespaces/{name}/status".replaceAll("\\{format\\}", "json").replaceAll("\\{" + "name" + "\\}",apiInvoker.escape(name))

    val contentTypes = List("*/*")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (name == null) throw new Exception("Missing required parameter 'name' when calling Core_v1Api->replaceCoreV1NamespaceStatus")

    if (body == null) throw new Exception("Missing required parameter 'body' when calling Core_v1Api->replaceCoreV1NamespaceStatus")

    pretty.map(paramVal => queryParams += "pretty" -> paramVal.toString)
    

    var postBody: AnyRef = body

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "PUT", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "", classOf[IoK8sApiCoreV1Namespace]).asInstanceOf[IoK8sApiCoreV1Namespace])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * 
   * replace the specified ConfigMap
   * @param name name of the ConfigMap 
   * @param namespace object name and auth scope, such as for teams and projects 
   * @param body  
   * @param pretty If &#39;true&#39;, then the output is pretty printed. (optional)
   * @return IoK8sApiCoreV1ConfigMap
   */
  def replaceCoreV1NamespacedConfigMap(name: String, namespace: String, body: IoK8sApiCoreV1ConfigMap, pretty: Option[String] = None): Option[IoK8sApiCoreV1ConfigMap] = {
    // create path and map variables
    val path = "/api/v1/namespaces/{namespace}/configmaps/{name}".replaceAll("\\{format\\}", "json").replaceAll("\\{" + "name" + "\\}",apiInvoker.escape(name)).replaceAll("\\{" + "namespace" + "\\}",apiInvoker.escape(namespace))

    val contentTypes = List("*/*")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (name == null) throw new Exception("Missing required parameter 'name' when calling Core_v1Api->replaceCoreV1NamespacedConfigMap")

    if (namespace == null) throw new Exception("Missing required parameter 'namespace' when calling Core_v1Api->replaceCoreV1NamespacedConfigMap")

    if (body == null) throw new Exception("Missing required parameter 'body' when calling Core_v1Api->replaceCoreV1NamespacedConfigMap")

    pretty.map(paramVal => queryParams += "pretty" -> paramVal.toString)
    

    var postBody: AnyRef = body

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "PUT", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "", classOf[IoK8sApiCoreV1ConfigMap]).asInstanceOf[IoK8sApiCoreV1ConfigMap])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * 
   * replace the specified Endpoints
   * @param name name of the Endpoints 
   * @param namespace object name and auth scope, such as for teams and projects 
   * @param body  
   * @param pretty If &#39;true&#39;, then the output is pretty printed. (optional)
   * @return IoK8sApiCoreV1Endpoints
   */
  def replaceCoreV1NamespacedEndpoints(name: String, namespace: String, body: IoK8sApiCoreV1Endpoints, pretty: Option[String] = None): Option[IoK8sApiCoreV1Endpoints] = {
    // create path and map variables
    val path = "/api/v1/namespaces/{namespace}/endpoints/{name}".replaceAll("\\{format\\}", "json").replaceAll("\\{" + "name" + "\\}",apiInvoker.escape(name)).replaceAll("\\{" + "namespace" + "\\}",apiInvoker.escape(namespace))

    val contentTypes = List("*/*")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (name == null) throw new Exception("Missing required parameter 'name' when calling Core_v1Api->replaceCoreV1NamespacedEndpoints")

    if (namespace == null) throw new Exception("Missing required parameter 'namespace' when calling Core_v1Api->replaceCoreV1NamespacedEndpoints")

    if (body == null) throw new Exception("Missing required parameter 'body' when calling Core_v1Api->replaceCoreV1NamespacedEndpoints")

    pretty.map(paramVal => queryParams += "pretty" -> paramVal.toString)
    

    var postBody: AnyRef = body

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "PUT", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "", classOf[IoK8sApiCoreV1Endpoints]).asInstanceOf[IoK8sApiCoreV1Endpoints])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * 
   * replace the specified Event
   * @param name name of the Event 
   * @param namespace object name and auth scope, such as for teams and projects 
   * @param body  
   * @param pretty If &#39;true&#39;, then the output is pretty printed. (optional)
   * @return IoK8sApiCoreV1Event
   */
  def replaceCoreV1NamespacedEvent(name: String, namespace: String, body: IoK8sApiCoreV1Event, pretty: Option[String] = None): Option[IoK8sApiCoreV1Event] = {
    // create path and map variables
    val path = "/api/v1/namespaces/{namespace}/events/{name}".replaceAll("\\{format\\}", "json").replaceAll("\\{" + "name" + "\\}",apiInvoker.escape(name)).replaceAll("\\{" + "namespace" + "\\}",apiInvoker.escape(namespace))

    val contentTypes = List("*/*")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (name == null) throw new Exception("Missing required parameter 'name' when calling Core_v1Api->replaceCoreV1NamespacedEvent")

    if (namespace == null) throw new Exception("Missing required parameter 'namespace' when calling Core_v1Api->replaceCoreV1NamespacedEvent")

    if (body == null) throw new Exception("Missing required parameter 'body' when calling Core_v1Api->replaceCoreV1NamespacedEvent")

    pretty.map(paramVal => queryParams += "pretty" -> paramVal.toString)
    

    var postBody: AnyRef = body

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "PUT", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "", classOf[IoK8sApiCoreV1Event]).asInstanceOf[IoK8sApiCoreV1Event])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * 
   * replace the specified LimitRange
   * @param name name of the LimitRange 
   * @param namespace object name and auth scope, such as for teams and projects 
   * @param body  
   * @param pretty If &#39;true&#39;, then the output is pretty printed. (optional)
   * @return IoK8sApiCoreV1LimitRange
   */
  def replaceCoreV1NamespacedLimitRange(name: String, namespace: String, body: IoK8sApiCoreV1LimitRange, pretty: Option[String] = None): Option[IoK8sApiCoreV1LimitRange] = {
    // create path and map variables
    val path = "/api/v1/namespaces/{namespace}/limitranges/{name}".replaceAll("\\{format\\}", "json").replaceAll("\\{" + "name" + "\\}",apiInvoker.escape(name)).replaceAll("\\{" + "namespace" + "\\}",apiInvoker.escape(namespace))

    val contentTypes = List("*/*")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (name == null) throw new Exception("Missing required parameter 'name' when calling Core_v1Api->replaceCoreV1NamespacedLimitRange")

    if (namespace == null) throw new Exception("Missing required parameter 'namespace' when calling Core_v1Api->replaceCoreV1NamespacedLimitRange")

    if (body == null) throw new Exception("Missing required parameter 'body' when calling Core_v1Api->replaceCoreV1NamespacedLimitRange")

    pretty.map(paramVal => queryParams += "pretty" -> paramVal.toString)
    

    var postBody: AnyRef = body

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "PUT", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "", classOf[IoK8sApiCoreV1LimitRange]).asInstanceOf[IoK8sApiCoreV1LimitRange])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * 
   * replace the specified PersistentVolumeClaim
   * @param name name of the PersistentVolumeClaim 
   * @param namespace object name and auth scope, such as for teams and projects 
   * @param body  
   * @param pretty If &#39;true&#39;, then the output is pretty printed. (optional)
   * @return IoK8sApiCoreV1PersistentVolumeClaim
   */
  def replaceCoreV1NamespacedPersistentVolumeClaim(name: String, namespace: String, body: IoK8sApiCoreV1PersistentVolumeClaim, pretty: Option[String] = None): Option[IoK8sApiCoreV1PersistentVolumeClaim] = {
    // create path and map variables
    val path = "/api/v1/namespaces/{namespace}/persistentvolumeclaims/{name}".replaceAll("\\{format\\}", "json").replaceAll("\\{" + "name" + "\\}",apiInvoker.escape(name)).replaceAll("\\{" + "namespace" + "\\}",apiInvoker.escape(namespace))

    val contentTypes = List("*/*")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (name == null) throw new Exception("Missing required parameter 'name' when calling Core_v1Api->replaceCoreV1NamespacedPersistentVolumeClaim")

    if (namespace == null) throw new Exception("Missing required parameter 'namespace' when calling Core_v1Api->replaceCoreV1NamespacedPersistentVolumeClaim")

    if (body == null) throw new Exception("Missing required parameter 'body' when calling Core_v1Api->replaceCoreV1NamespacedPersistentVolumeClaim")

    pretty.map(paramVal => queryParams += "pretty" -> paramVal.toString)
    

    var postBody: AnyRef = body

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "PUT", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "", classOf[IoK8sApiCoreV1PersistentVolumeClaim]).asInstanceOf[IoK8sApiCoreV1PersistentVolumeClaim])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * 
   * replace status of the specified PersistentVolumeClaim
   * @param name name of the PersistentVolumeClaim 
   * @param namespace object name and auth scope, such as for teams and projects 
   * @param body  
   * @param pretty If &#39;true&#39;, then the output is pretty printed. (optional)
   * @return IoK8sApiCoreV1PersistentVolumeClaim
   */
  def replaceCoreV1NamespacedPersistentVolumeClaimStatus(name: String, namespace: String, body: IoK8sApiCoreV1PersistentVolumeClaim, pretty: Option[String] = None): Option[IoK8sApiCoreV1PersistentVolumeClaim] = {
    // create path and map variables
    val path = "/api/v1/namespaces/{namespace}/persistentvolumeclaims/{name}/status".replaceAll("\\{format\\}", "json").replaceAll("\\{" + "name" + "\\}",apiInvoker.escape(name)).replaceAll("\\{" + "namespace" + "\\}",apiInvoker.escape(namespace))

    val contentTypes = List("*/*")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (name == null) throw new Exception("Missing required parameter 'name' when calling Core_v1Api->replaceCoreV1NamespacedPersistentVolumeClaimStatus")

    if (namespace == null) throw new Exception("Missing required parameter 'namespace' when calling Core_v1Api->replaceCoreV1NamespacedPersistentVolumeClaimStatus")

    if (body == null) throw new Exception("Missing required parameter 'body' when calling Core_v1Api->replaceCoreV1NamespacedPersistentVolumeClaimStatus")

    pretty.map(paramVal => queryParams += "pretty" -> paramVal.toString)
    

    var postBody: AnyRef = body

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "PUT", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "", classOf[IoK8sApiCoreV1PersistentVolumeClaim]).asInstanceOf[IoK8sApiCoreV1PersistentVolumeClaim])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * 
   * replace the specified Pod
   * @param name name of the Pod 
   * @param namespace object name and auth scope, such as for teams and projects 
   * @param body  
   * @param pretty If &#39;true&#39;, then the output is pretty printed. (optional)
   * @return IoK8sApiCoreV1Pod
   */
  def replaceCoreV1NamespacedPod(name: String, namespace: String, body: IoK8sApiCoreV1Pod, pretty: Option[String] = None): Option[IoK8sApiCoreV1Pod] = {
    // create path and map variables
    val path = "/api/v1/namespaces/{namespace}/pods/{name}".replaceAll("\\{format\\}", "json").replaceAll("\\{" + "name" + "\\}",apiInvoker.escape(name)).replaceAll("\\{" + "namespace" + "\\}",apiInvoker.escape(namespace))

    val contentTypes = List("*/*")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (name == null) throw new Exception("Missing required parameter 'name' when calling Core_v1Api->replaceCoreV1NamespacedPod")

    if (namespace == null) throw new Exception("Missing required parameter 'namespace' when calling Core_v1Api->replaceCoreV1NamespacedPod")

    if (body == null) throw new Exception("Missing required parameter 'body' when calling Core_v1Api->replaceCoreV1NamespacedPod")

    pretty.map(paramVal => queryParams += "pretty" -> paramVal.toString)
    

    var postBody: AnyRef = body

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "PUT", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "", classOf[IoK8sApiCoreV1Pod]).asInstanceOf[IoK8sApiCoreV1Pod])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * 
   * replace status of the specified Pod
   * @param name name of the Pod 
   * @param namespace object name and auth scope, such as for teams and projects 
   * @param body  
   * @param pretty If &#39;true&#39;, then the output is pretty printed. (optional)
   * @return IoK8sApiCoreV1Pod
   */
  def replaceCoreV1NamespacedPodStatus(name: String, namespace: String, body: IoK8sApiCoreV1Pod, pretty: Option[String] = None): Option[IoK8sApiCoreV1Pod] = {
    // create path and map variables
    val path = "/api/v1/namespaces/{namespace}/pods/{name}/status".replaceAll("\\{format\\}", "json").replaceAll("\\{" + "name" + "\\}",apiInvoker.escape(name)).replaceAll("\\{" + "namespace" + "\\}",apiInvoker.escape(namespace))

    val contentTypes = List("*/*")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (name == null) throw new Exception("Missing required parameter 'name' when calling Core_v1Api->replaceCoreV1NamespacedPodStatus")

    if (namespace == null) throw new Exception("Missing required parameter 'namespace' when calling Core_v1Api->replaceCoreV1NamespacedPodStatus")

    if (body == null) throw new Exception("Missing required parameter 'body' when calling Core_v1Api->replaceCoreV1NamespacedPodStatus")

    pretty.map(paramVal => queryParams += "pretty" -> paramVal.toString)
    

    var postBody: AnyRef = body

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "PUT", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "", classOf[IoK8sApiCoreV1Pod]).asInstanceOf[IoK8sApiCoreV1Pod])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * 
   * replace the specified PodTemplate
   * @param name name of the PodTemplate 
   * @param namespace object name and auth scope, such as for teams and projects 
   * @param body  
   * @param pretty If &#39;true&#39;, then the output is pretty printed. (optional)
   * @return IoK8sApiCoreV1PodTemplate
   */
  def replaceCoreV1NamespacedPodTemplate(name: String, namespace: String, body: IoK8sApiCoreV1PodTemplate, pretty: Option[String] = None): Option[IoK8sApiCoreV1PodTemplate] = {
    // create path and map variables
    val path = "/api/v1/namespaces/{namespace}/podtemplates/{name}".replaceAll("\\{format\\}", "json").replaceAll("\\{" + "name" + "\\}",apiInvoker.escape(name)).replaceAll("\\{" + "namespace" + "\\}",apiInvoker.escape(namespace))

    val contentTypes = List("*/*")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (name == null) throw new Exception("Missing required parameter 'name' when calling Core_v1Api->replaceCoreV1NamespacedPodTemplate")

    if (namespace == null) throw new Exception("Missing required parameter 'namespace' when calling Core_v1Api->replaceCoreV1NamespacedPodTemplate")

    if (body == null) throw new Exception("Missing required parameter 'body' when calling Core_v1Api->replaceCoreV1NamespacedPodTemplate")

    pretty.map(paramVal => queryParams += "pretty" -> paramVal.toString)
    

    var postBody: AnyRef = body

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "PUT", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "", classOf[IoK8sApiCoreV1PodTemplate]).asInstanceOf[IoK8sApiCoreV1PodTemplate])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * 
   * replace the specified ReplicationController
   * @param name name of the ReplicationController 
   * @param namespace object name and auth scope, such as for teams and projects 
   * @param body  
   * @param pretty If &#39;true&#39;, then the output is pretty printed. (optional)
   * @return IoK8sApiCoreV1ReplicationController
   */
  def replaceCoreV1NamespacedReplicationController(name: String, namespace: String, body: IoK8sApiCoreV1ReplicationController, pretty: Option[String] = None): Option[IoK8sApiCoreV1ReplicationController] = {
    // create path and map variables
    val path = "/api/v1/namespaces/{namespace}/replicationcontrollers/{name}".replaceAll("\\{format\\}", "json").replaceAll("\\{" + "name" + "\\}",apiInvoker.escape(name)).replaceAll("\\{" + "namespace" + "\\}",apiInvoker.escape(namespace))

    val contentTypes = List("*/*")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (name == null) throw new Exception("Missing required parameter 'name' when calling Core_v1Api->replaceCoreV1NamespacedReplicationController")

    if (namespace == null) throw new Exception("Missing required parameter 'namespace' when calling Core_v1Api->replaceCoreV1NamespacedReplicationController")

    if (body == null) throw new Exception("Missing required parameter 'body' when calling Core_v1Api->replaceCoreV1NamespacedReplicationController")

    pretty.map(paramVal => queryParams += "pretty" -> paramVal.toString)
    

    var postBody: AnyRef = body

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "PUT", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "", classOf[IoK8sApiCoreV1ReplicationController]).asInstanceOf[IoK8sApiCoreV1ReplicationController])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * 
   * replace scale of the specified ReplicationController
   * @param name name of the Scale 
   * @param namespace object name and auth scope, such as for teams and projects 
   * @param body  
   * @param pretty If &#39;true&#39;, then the output is pretty printed. (optional)
   * @return IoK8sApiAutoscalingV1Scale
   */
  def replaceCoreV1NamespacedReplicationControllerScale(name: String, namespace: String, body: IoK8sApiAutoscalingV1Scale, pretty: Option[String] = None): Option[IoK8sApiAutoscalingV1Scale] = {
    // create path and map variables
    val path = "/api/v1/namespaces/{namespace}/replicationcontrollers/{name}/scale".replaceAll("\\{format\\}", "json").replaceAll("\\{" + "name" + "\\}",apiInvoker.escape(name)).replaceAll("\\{" + "namespace" + "\\}",apiInvoker.escape(namespace))

    val contentTypes = List("*/*")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (name == null) throw new Exception("Missing required parameter 'name' when calling Core_v1Api->replaceCoreV1NamespacedReplicationControllerScale")

    if (namespace == null) throw new Exception("Missing required parameter 'namespace' when calling Core_v1Api->replaceCoreV1NamespacedReplicationControllerScale")

    if (body == null) throw new Exception("Missing required parameter 'body' when calling Core_v1Api->replaceCoreV1NamespacedReplicationControllerScale")

    pretty.map(paramVal => queryParams += "pretty" -> paramVal.toString)
    

    var postBody: AnyRef = body

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "PUT", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "", classOf[IoK8sApiAutoscalingV1Scale]).asInstanceOf[IoK8sApiAutoscalingV1Scale])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * 
   * replace status of the specified ReplicationController
   * @param name name of the ReplicationController 
   * @param namespace object name and auth scope, such as for teams and projects 
   * @param body  
   * @param pretty If &#39;true&#39;, then the output is pretty printed. (optional)
   * @return IoK8sApiCoreV1ReplicationController
   */
  def replaceCoreV1NamespacedReplicationControllerStatus(name: String, namespace: String, body: IoK8sApiCoreV1ReplicationController, pretty: Option[String] = None): Option[IoK8sApiCoreV1ReplicationController] = {
    // create path and map variables
    val path = "/api/v1/namespaces/{namespace}/replicationcontrollers/{name}/status".replaceAll("\\{format\\}", "json").replaceAll("\\{" + "name" + "\\}",apiInvoker.escape(name)).replaceAll("\\{" + "namespace" + "\\}",apiInvoker.escape(namespace))

    val contentTypes = List("*/*")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (name == null) throw new Exception("Missing required parameter 'name' when calling Core_v1Api->replaceCoreV1NamespacedReplicationControllerStatus")

    if (namespace == null) throw new Exception("Missing required parameter 'namespace' when calling Core_v1Api->replaceCoreV1NamespacedReplicationControllerStatus")

    if (body == null) throw new Exception("Missing required parameter 'body' when calling Core_v1Api->replaceCoreV1NamespacedReplicationControllerStatus")

    pretty.map(paramVal => queryParams += "pretty" -> paramVal.toString)
    

    var postBody: AnyRef = body

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "PUT", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "", classOf[IoK8sApiCoreV1ReplicationController]).asInstanceOf[IoK8sApiCoreV1ReplicationController])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * 
   * replace the specified ResourceQuota
   * @param name name of the ResourceQuota 
   * @param namespace object name and auth scope, such as for teams and projects 
   * @param body  
   * @param pretty If &#39;true&#39;, then the output is pretty printed. (optional)
   * @return IoK8sApiCoreV1ResourceQuota
   */
  def replaceCoreV1NamespacedResourceQuota(name: String, namespace: String, body: IoK8sApiCoreV1ResourceQuota, pretty: Option[String] = None): Option[IoK8sApiCoreV1ResourceQuota] = {
    // create path and map variables
    val path = "/api/v1/namespaces/{namespace}/resourcequotas/{name}".replaceAll("\\{format\\}", "json").replaceAll("\\{" + "name" + "\\}",apiInvoker.escape(name)).replaceAll("\\{" + "namespace" + "\\}",apiInvoker.escape(namespace))

    val contentTypes = List("*/*")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (name == null) throw new Exception("Missing required parameter 'name' when calling Core_v1Api->replaceCoreV1NamespacedResourceQuota")

    if (namespace == null) throw new Exception("Missing required parameter 'namespace' when calling Core_v1Api->replaceCoreV1NamespacedResourceQuota")

    if (body == null) throw new Exception("Missing required parameter 'body' when calling Core_v1Api->replaceCoreV1NamespacedResourceQuota")

    pretty.map(paramVal => queryParams += "pretty" -> paramVal.toString)
    

    var postBody: AnyRef = body

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "PUT", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "", classOf[IoK8sApiCoreV1ResourceQuota]).asInstanceOf[IoK8sApiCoreV1ResourceQuota])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * 
   * replace status of the specified ResourceQuota
   * @param name name of the ResourceQuota 
   * @param namespace object name and auth scope, such as for teams and projects 
   * @param body  
   * @param pretty If &#39;true&#39;, then the output is pretty printed. (optional)
   * @return IoK8sApiCoreV1ResourceQuota
   */
  def replaceCoreV1NamespacedResourceQuotaStatus(name: String, namespace: String, body: IoK8sApiCoreV1ResourceQuota, pretty: Option[String] = None): Option[IoK8sApiCoreV1ResourceQuota] = {
    // create path and map variables
    val path = "/api/v1/namespaces/{namespace}/resourcequotas/{name}/status".replaceAll("\\{format\\}", "json").replaceAll("\\{" + "name" + "\\}",apiInvoker.escape(name)).replaceAll("\\{" + "namespace" + "\\}",apiInvoker.escape(namespace))

    val contentTypes = List("*/*")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (name == null) throw new Exception("Missing required parameter 'name' when calling Core_v1Api->replaceCoreV1NamespacedResourceQuotaStatus")

    if (namespace == null) throw new Exception("Missing required parameter 'namespace' when calling Core_v1Api->replaceCoreV1NamespacedResourceQuotaStatus")

    if (body == null) throw new Exception("Missing required parameter 'body' when calling Core_v1Api->replaceCoreV1NamespacedResourceQuotaStatus")

    pretty.map(paramVal => queryParams += "pretty" -> paramVal.toString)
    

    var postBody: AnyRef = body

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "PUT", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "", classOf[IoK8sApiCoreV1ResourceQuota]).asInstanceOf[IoK8sApiCoreV1ResourceQuota])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * 
   * replace the specified Secret
   * @param name name of the Secret 
   * @param namespace object name and auth scope, such as for teams and projects 
   * @param body  
   * @param pretty If &#39;true&#39;, then the output is pretty printed. (optional)
   * @return IoK8sApiCoreV1Secret
   */
  def replaceCoreV1NamespacedSecret(name: String, namespace: String, body: IoK8sApiCoreV1Secret, pretty: Option[String] = None): Option[IoK8sApiCoreV1Secret] = {
    // create path and map variables
    val path = "/api/v1/namespaces/{namespace}/secrets/{name}".replaceAll("\\{format\\}", "json").replaceAll("\\{" + "name" + "\\}",apiInvoker.escape(name)).replaceAll("\\{" + "namespace" + "\\}",apiInvoker.escape(namespace))

    val contentTypes = List("*/*")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (name == null) throw new Exception("Missing required parameter 'name' when calling Core_v1Api->replaceCoreV1NamespacedSecret")

    if (namespace == null) throw new Exception("Missing required parameter 'namespace' when calling Core_v1Api->replaceCoreV1NamespacedSecret")

    if (body == null) throw new Exception("Missing required parameter 'body' when calling Core_v1Api->replaceCoreV1NamespacedSecret")

    pretty.map(paramVal => queryParams += "pretty" -> paramVal.toString)
    

    var postBody: AnyRef = body

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "PUT", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "", classOf[IoK8sApiCoreV1Secret]).asInstanceOf[IoK8sApiCoreV1Secret])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * 
   * replace the specified Service
   * @param name name of the Service 
   * @param namespace object name and auth scope, such as for teams and projects 
   * @param body  
   * @param pretty If &#39;true&#39;, then the output is pretty printed. (optional)
   * @return IoK8sApiCoreV1Service
   */
  def replaceCoreV1NamespacedService(name: String, namespace: String, body: IoK8sApiCoreV1Service, pretty: Option[String] = None): Option[IoK8sApiCoreV1Service] = {
    // create path and map variables
    val path = "/api/v1/namespaces/{namespace}/services/{name}".replaceAll("\\{format\\}", "json").replaceAll("\\{" + "name" + "\\}",apiInvoker.escape(name)).replaceAll("\\{" + "namespace" + "\\}",apiInvoker.escape(namespace))

    val contentTypes = List("*/*")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (name == null) throw new Exception("Missing required parameter 'name' when calling Core_v1Api->replaceCoreV1NamespacedService")

    if (namespace == null) throw new Exception("Missing required parameter 'namespace' when calling Core_v1Api->replaceCoreV1NamespacedService")

    if (body == null) throw new Exception("Missing required parameter 'body' when calling Core_v1Api->replaceCoreV1NamespacedService")

    pretty.map(paramVal => queryParams += "pretty" -> paramVal.toString)
    

    var postBody: AnyRef = body

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "PUT", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "", classOf[IoK8sApiCoreV1Service]).asInstanceOf[IoK8sApiCoreV1Service])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * 
   * replace the specified ServiceAccount
   * @param name name of the ServiceAccount 
   * @param namespace object name and auth scope, such as for teams and projects 
   * @param body  
   * @param pretty If &#39;true&#39;, then the output is pretty printed. (optional)
   * @return IoK8sApiCoreV1ServiceAccount
   */
  def replaceCoreV1NamespacedServiceAccount(name: String, namespace: String, body: IoK8sApiCoreV1ServiceAccount, pretty: Option[String] = None): Option[IoK8sApiCoreV1ServiceAccount] = {
    // create path and map variables
    val path = "/api/v1/namespaces/{namespace}/serviceaccounts/{name}".replaceAll("\\{format\\}", "json").replaceAll("\\{" + "name" + "\\}",apiInvoker.escape(name)).replaceAll("\\{" + "namespace" + "\\}",apiInvoker.escape(namespace))

    val contentTypes = List("*/*")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (name == null) throw new Exception("Missing required parameter 'name' when calling Core_v1Api->replaceCoreV1NamespacedServiceAccount")

    if (namespace == null) throw new Exception("Missing required parameter 'namespace' when calling Core_v1Api->replaceCoreV1NamespacedServiceAccount")

    if (body == null) throw new Exception("Missing required parameter 'body' when calling Core_v1Api->replaceCoreV1NamespacedServiceAccount")

    pretty.map(paramVal => queryParams += "pretty" -> paramVal.toString)
    

    var postBody: AnyRef = body

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "PUT", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "", classOf[IoK8sApiCoreV1ServiceAccount]).asInstanceOf[IoK8sApiCoreV1ServiceAccount])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * 
   * replace status of the specified Service
   * @param name name of the Service 
   * @param namespace object name and auth scope, such as for teams and projects 
   * @param body  
   * @param pretty If &#39;true&#39;, then the output is pretty printed. (optional)
   * @return IoK8sApiCoreV1Service
   */
  def replaceCoreV1NamespacedServiceStatus(name: String, namespace: String, body: IoK8sApiCoreV1Service, pretty: Option[String] = None): Option[IoK8sApiCoreV1Service] = {
    // create path and map variables
    val path = "/api/v1/namespaces/{namespace}/services/{name}/status".replaceAll("\\{format\\}", "json").replaceAll("\\{" + "name" + "\\}",apiInvoker.escape(name)).replaceAll("\\{" + "namespace" + "\\}",apiInvoker.escape(namespace))

    val contentTypes = List("*/*")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (name == null) throw new Exception("Missing required parameter 'name' when calling Core_v1Api->replaceCoreV1NamespacedServiceStatus")

    if (namespace == null) throw new Exception("Missing required parameter 'namespace' when calling Core_v1Api->replaceCoreV1NamespacedServiceStatus")

    if (body == null) throw new Exception("Missing required parameter 'body' when calling Core_v1Api->replaceCoreV1NamespacedServiceStatus")

    pretty.map(paramVal => queryParams += "pretty" -> paramVal.toString)
    

    var postBody: AnyRef = body

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "PUT", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "", classOf[IoK8sApiCoreV1Service]).asInstanceOf[IoK8sApiCoreV1Service])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * 
   * replace the specified Node
   * @param name name of the Node 
   * @param body  
   * @param pretty If &#39;true&#39;, then the output is pretty printed. (optional)
   * @return IoK8sApiCoreV1Node
   */
  def replaceCoreV1Node(name: String, body: IoK8sApiCoreV1Node, pretty: Option[String] = None): Option[IoK8sApiCoreV1Node] = {
    // create path and map variables
    val path = "/api/v1/nodes/{name}".replaceAll("\\{format\\}", "json").replaceAll("\\{" + "name" + "\\}",apiInvoker.escape(name))

    val contentTypes = List("*/*")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (name == null) throw new Exception("Missing required parameter 'name' when calling Core_v1Api->replaceCoreV1Node")

    if (body == null) throw new Exception("Missing required parameter 'body' when calling Core_v1Api->replaceCoreV1Node")

    pretty.map(paramVal => queryParams += "pretty" -> paramVal.toString)
    

    var postBody: AnyRef = body

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "PUT", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "", classOf[IoK8sApiCoreV1Node]).asInstanceOf[IoK8sApiCoreV1Node])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * 
   * replace status of the specified Node
   * @param name name of the Node 
   * @param body  
   * @param pretty If &#39;true&#39;, then the output is pretty printed. (optional)
   * @return IoK8sApiCoreV1Node
   */
  def replaceCoreV1NodeStatus(name: String, body: IoK8sApiCoreV1Node, pretty: Option[String] = None): Option[IoK8sApiCoreV1Node] = {
    // create path and map variables
    val path = "/api/v1/nodes/{name}/status".replaceAll("\\{format\\}", "json").replaceAll("\\{" + "name" + "\\}",apiInvoker.escape(name))

    val contentTypes = List("*/*")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (name == null) throw new Exception("Missing required parameter 'name' when calling Core_v1Api->replaceCoreV1NodeStatus")

    if (body == null) throw new Exception("Missing required parameter 'body' when calling Core_v1Api->replaceCoreV1NodeStatus")

    pretty.map(paramVal => queryParams += "pretty" -> paramVal.toString)
    

    var postBody: AnyRef = body

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "PUT", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "", classOf[IoK8sApiCoreV1Node]).asInstanceOf[IoK8sApiCoreV1Node])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * 
   * replace the specified PersistentVolume
   * @param name name of the PersistentVolume 
   * @param body  
   * @param pretty If &#39;true&#39;, then the output is pretty printed. (optional)
   * @return IoK8sApiCoreV1PersistentVolume
   */
  def replaceCoreV1PersistentVolume(name: String, body: IoK8sApiCoreV1PersistentVolume, pretty: Option[String] = None): Option[IoK8sApiCoreV1PersistentVolume] = {
    // create path and map variables
    val path = "/api/v1/persistentvolumes/{name}".replaceAll("\\{format\\}", "json").replaceAll("\\{" + "name" + "\\}",apiInvoker.escape(name))

    val contentTypes = List("*/*")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (name == null) throw new Exception("Missing required parameter 'name' when calling Core_v1Api->replaceCoreV1PersistentVolume")

    if (body == null) throw new Exception("Missing required parameter 'body' when calling Core_v1Api->replaceCoreV1PersistentVolume")

    pretty.map(paramVal => queryParams += "pretty" -> paramVal.toString)
    

    var postBody: AnyRef = body

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "PUT", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "", classOf[IoK8sApiCoreV1PersistentVolume]).asInstanceOf[IoK8sApiCoreV1PersistentVolume])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * 
   * replace status of the specified PersistentVolume
   * @param name name of the PersistentVolume 
   * @param body  
   * @param pretty If &#39;true&#39;, then the output is pretty printed. (optional)
   * @return IoK8sApiCoreV1PersistentVolume
   */
  def replaceCoreV1PersistentVolumeStatus(name: String, body: IoK8sApiCoreV1PersistentVolume, pretty: Option[String] = None): Option[IoK8sApiCoreV1PersistentVolume] = {
    // create path and map variables
    val path = "/api/v1/persistentvolumes/{name}/status".replaceAll("\\{format\\}", "json").replaceAll("\\{" + "name" + "\\}",apiInvoker.escape(name))

    val contentTypes = List("*/*")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (name == null) throw new Exception("Missing required parameter 'name' when calling Core_v1Api->replaceCoreV1PersistentVolumeStatus")

    if (body == null) throw new Exception("Missing required parameter 'body' when calling Core_v1Api->replaceCoreV1PersistentVolumeStatus")

    pretty.map(paramVal => queryParams += "pretty" -> paramVal.toString)
    

    var postBody: AnyRef = body

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "PUT", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "", classOf[IoK8sApiCoreV1PersistentVolume]).asInstanceOf[IoK8sApiCoreV1PersistentVolume])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * 
   * watch individual changes to a list of ConfigMap
   * @param continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. (optional)
   * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
   * @param includeUninitialized If true, partially initialized resources are included in the response. (optional)
   * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
   * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. (optional)
   * @param pretty If &#39;true&#39;, then the output is pretty printed. (optional)
   * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
   * @param timeoutSeconds Timeout for the list/watch call. (optional)
   * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
   * @return IoK8sApimachineryPkgApisMetaV1WatchEvent
   */
  def watchCoreV1ConfigMapListForAllNamespaces(continue: Option[String] = None, fieldSelector: Option[String] = None, includeUninitialized: Option[Boolean] = None, labelSelector: Option[String] = None, limit: Option[Integer] = None, pretty: Option[String] = None, resourceVersion: Option[String] = None, timeoutSeconds: Option[Integer] = None, watch: Option[Boolean] = None): Option[IoK8sApimachineryPkgApisMetaV1WatchEvent] = {
    // create path and map variables
    val path = "/api/v1/watch/configmaps".replaceAll("\\{format\\}", "json")

    val contentTypes = List("*/*")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    continue.map(paramVal => queryParams += "continue" -> paramVal.toString)
    fieldSelector.map(paramVal => queryParams += "fieldSelector" -> paramVal.toString)
    includeUninitialized.map(paramVal => queryParams += "includeUninitialized" -> paramVal.toString)
    labelSelector.map(paramVal => queryParams += "labelSelector" -> paramVal.toString)
    limit.map(paramVal => queryParams += "limit" -> paramVal.toString)
    pretty.map(paramVal => queryParams += "pretty" -> paramVal.toString)
    resourceVersion.map(paramVal => queryParams += "resourceVersion" -> paramVal.toString)
    timeoutSeconds.map(paramVal => queryParams += "timeoutSeconds" -> paramVal.toString)
    watch.map(paramVal => queryParams += "watch" -> paramVal.toString)
    

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "GET", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "", classOf[IoK8sApimachineryPkgApisMetaV1WatchEvent]).asInstanceOf[IoK8sApimachineryPkgApisMetaV1WatchEvent])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * 
   * watch individual changes to a list of Endpoints
   * @param continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. (optional)
   * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
   * @param includeUninitialized If true, partially initialized resources are included in the response. (optional)
   * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
   * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. (optional)
   * @param pretty If &#39;true&#39;, then the output is pretty printed. (optional)
   * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
   * @param timeoutSeconds Timeout for the list/watch call. (optional)
   * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
   * @return IoK8sApimachineryPkgApisMetaV1WatchEvent
   */
  def watchCoreV1EndpointsListForAllNamespaces(continue: Option[String] = None, fieldSelector: Option[String] = None, includeUninitialized: Option[Boolean] = None, labelSelector: Option[String] = None, limit: Option[Integer] = None, pretty: Option[String] = None, resourceVersion: Option[String] = None, timeoutSeconds: Option[Integer] = None, watch: Option[Boolean] = None): Option[IoK8sApimachineryPkgApisMetaV1WatchEvent] = {
    // create path and map variables
    val path = "/api/v1/watch/endpoints".replaceAll("\\{format\\}", "json")

    val contentTypes = List("*/*")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    continue.map(paramVal => queryParams += "continue" -> paramVal.toString)
    fieldSelector.map(paramVal => queryParams += "fieldSelector" -> paramVal.toString)
    includeUninitialized.map(paramVal => queryParams += "includeUninitialized" -> paramVal.toString)
    labelSelector.map(paramVal => queryParams += "labelSelector" -> paramVal.toString)
    limit.map(paramVal => queryParams += "limit" -> paramVal.toString)
    pretty.map(paramVal => queryParams += "pretty" -> paramVal.toString)
    resourceVersion.map(paramVal => queryParams += "resourceVersion" -> paramVal.toString)
    timeoutSeconds.map(paramVal => queryParams += "timeoutSeconds" -> paramVal.toString)
    watch.map(paramVal => queryParams += "watch" -> paramVal.toString)
    

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "GET", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "", classOf[IoK8sApimachineryPkgApisMetaV1WatchEvent]).asInstanceOf[IoK8sApimachineryPkgApisMetaV1WatchEvent])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * 
   * watch individual changes to a list of Event
   * @param continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. (optional)
   * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
   * @param includeUninitialized If true, partially initialized resources are included in the response. (optional)
   * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
   * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. (optional)
   * @param pretty If &#39;true&#39;, then the output is pretty printed. (optional)
   * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
   * @param timeoutSeconds Timeout for the list/watch call. (optional)
   * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
   * @return IoK8sApimachineryPkgApisMetaV1WatchEvent
   */
  def watchCoreV1EventListForAllNamespaces(continue: Option[String] = None, fieldSelector: Option[String] = None, includeUninitialized: Option[Boolean] = None, labelSelector: Option[String] = None, limit: Option[Integer] = None, pretty: Option[String] = None, resourceVersion: Option[String] = None, timeoutSeconds: Option[Integer] = None, watch: Option[Boolean] = None): Option[IoK8sApimachineryPkgApisMetaV1WatchEvent] = {
    // create path and map variables
    val path = "/api/v1/watch/events".replaceAll("\\{format\\}", "json")

    val contentTypes = List("*/*")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    continue.map(paramVal => queryParams += "continue" -> paramVal.toString)
    fieldSelector.map(paramVal => queryParams += "fieldSelector" -> paramVal.toString)
    includeUninitialized.map(paramVal => queryParams += "includeUninitialized" -> paramVal.toString)
    labelSelector.map(paramVal => queryParams += "labelSelector" -> paramVal.toString)
    limit.map(paramVal => queryParams += "limit" -> paramVal.toString)
    pretty.map(paramVal => queryParams += "pretty" -> paramVal.toString)
    resourceVersion.map(paramVal => queryParams += "resourceVersion" -> paramVal.toString)
    timeoutSeconds.map(paramVal => queryParams += "timeoutSeconds" -> paramVal.toString)
    watch.map(paramVal => queryParams += "watch" -> paramVal.toString)
    

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "GET", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "", classOf[IoK8sApimachineryPkgApisMetaV1WatchEvent]).asInstanceOf[IoK8sApimachineryPkgApisMetaV1WatchEvent])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * 
   * watch individual changes to a list of LimitRange
   * @param continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. (optional)
   * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
   * @param includeUninitialized If true, partially initialized resources are included in the response. (optional)
   * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
   * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. (optional)
   * @param pretty If &#39;true&#39;, then the output is pretty printed. (optional)
   * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
   * @param timeoutSeconds Timeout for the list/watch call. (optional)
   * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
   * @return IoK8sApimachineryPkgApisMetaV1WatchEvent
   */
  def watchCoreV1LimitRangeListForAllNamespaces(continue: Option[String] = None, fieldSelector: Option[String] = None, includeUninitialized: Option[Boolean] = None, labelSelector: Option[String] = None, limit: Option[Integer] = None, pretty: Option[String] = None, resourceVersion: Option[String] = None, timeoutSeconds: Option[Integer] = None, watch: Option[Boolean] = None): Option[IoK8sApimachineryPkgApisMetaV1WatchEvent] = {
    // create path and map variables
    val path = "/api/v1/watch/limitranges".replaceAll("\\{format\\}", "json")

    val contentTypes = List("*/*")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    continue.map(paramVal => queryParams += "continue" -> paramVal.toString)
    fieldSelector.map(paramVal => queryParams += "fieldSelector" -> paramVal.toString)
    includeUninitialized.map(paramVal => queryParams += "includeUninitialized" -> paramVal.toString)
    labelSelector.map(paramVal => queryParams += "labelSelector" -> paramVal.toString)
    limit.map(paramVal => queryParams += "limit" -> paramVal.toString)
    pretty.map(paramVal => queryParams += "pretty" -> paramVal.toString)
    resourceVersion.map(paramVal => queryParams += "resourceVersion" -> paramVal.toString)
    timeoutSeconds.map(paramVal => queryParams += "timeoutSeconds" -> paramVal.toString)
    watch.map(paramVal => queryParams += "watch" -> paramVal.toString)
    

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "GET", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "", classOf[IoK8sApimachineryPkgApisMetaV1WatchEvent]).asInstanceOf[IoK8sApimachineryPkgApisMetaV1WatchEvent])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * 
   * watch changes to an object of kind Namespace
   * @param name name of the Namespace 
   * @param continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. (optional)
   * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
   * @param includeUninitialized If true, partially initialized resources are included in the response. (optional)
   * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
   * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. (optional)
   * @param pretty If &#39;true&#39;, then the output is pretty printed. (optional)
   * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
   * @param timeoutSeconds Timeout for the list/watch call. (optional)
   * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
   * @return IoK8sApimachineryPkgApisMetaV1WatchEvent
   */
  def watchCoreV1Namespace(name: String, continue: Option[String] = None, fieldSelector: Option[String] = None, includeUninitialized: Option[Boolean] = None, labelSelector: Option[String] = None, limit: Option[Integer] = None, pretty: Option[String] = None, resourceVersion: Option[String] = None, timeoutSeconds: Option[Integer] = None, watch: Option[Boolean] = None): Option[IoK8sApimachineryPkgApisMetaV1WatchEvent] = {
    // create path and map variables
    val path = "/api/v1/watch/namespaces/{name}".replaceAll("\\{format\\}", "json").replaceAll("\\{" + "name" + "\\}",apiInvoker.escape(name))

    val contentTypes = List("*/*")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (name == null) throw new Exception("Missing required parameter 'name' when calling Core_v1Api->watchCoreV1Namespace")

    continue.map(paramVal => queryParams += "continue" -> paramVal.toString)
    fieldSelector.map(paramVal => queryParams += "fieldSelector" -> paramVal.toString)
    includeUninitialized.map(paramVal => queryParams += "includeUninitialized" -> paramVal.toString)
    labelSelector.map(paramVal => queryParams += "labelSelector" -> paramVal.toString)
    limit.map(paramVal => queryParams += "limit" -> paramVal.toString)
    pretty.map(paramVal => queryParams += "pretty" -> paramVal.toString)
    resourceVersion.map(paramVal => queryParams += "resourceVersion" -> paramVal.toString)
    timeoutSeconds.map(paramVal => queryParams += "timeoutSeconds" -> paramVal.toString)
    watch.map(paramVal => queryParams += "watch" -> paramVal.toString)
    

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "GET", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "", classOf[IoK8sApimachineryPkgApisMetaV1WatchEvent]).asInstanceOf[IoK8sApimachineryPkgApisMetaV1WatchEvent])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * 
   * watch individual changes to a list of Namespace
   * @param continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. (optional)
   * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
   * @param includeUninitialized If true, partially initialized resources are included in the response. (optional)
   * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
   * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. (optional)
   * @param pretty If &#39;true&#39;, then the output is pretty printed. (optional)
   * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
   * @param timeoutSeconds Timeout for the list/watch call. (optional)
   * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
   * @return IoK8sApimachineryPkgApisMetaV1WatchEvent
   */
  def watchCoreV1NamespaceList(continue: Option[String] = None, fieldSelector: Option[String] = None, includeUninitialized: Option[Boolean] = None, labelSelector: Option[String] = None, limit: Option[Integer] = None, pretty: Option[String] = None, resourceVersion: Option[String] = None, timeoutSeconds: Option[Integer] = None, watch: Option[Boolean] = None): Option[IoK8sApimachineryPkgApisMetaV1WatchEvent] = {
    // create path and map variables
    val path = "/api/v1/watch/namespaces".replaceAll("\\{format\\}", "json")

    val contentTypes = List("*/*")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    continue.map(paramVal => queryParams += "continue" -> paramVal.toString)
    fieldSelector.map(paramVal => queryParams += "fieldSelector" -> paramVal.toString)
    includeUninitialized.map(paramVal => queryParams += "includeUninitialized" -> paramVal.toString)
    labelSelector.map(paramVal => queryParams += "labelSelector" -> paramVal.toString)
    limit.map(paramVal => queryParams += "limit" -> paramVal.toString)
    pretty.map(paramVal => queryParams += "pretty" -> paramVal.toString)
    resourceVersion.map(paramVal => queryParams += "resourceVersion" -> paramVal.toString)
    timeoutSeconds.map(paramVal => queryParams += "timeoutSeconds" -> paramVal.toString)
    watch.map(paramVal => queryParams += "watch" -> paramVal.toString)
    

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "GET", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "", classOf[IoK8sApimachineryPkgApisMetaV1WatchEvent]).asInstanceOf[IoK8sApimachineryPkgApisMetaV1WatchEvent])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * 
   * watch changes to an object of kind ConfigMap
   * @param name name of the ConfigMap 
   * @param namespace object name and auth scope, such as for teams and projects 
   * @param continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. (optional)
   * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
   * @param includeUninitialized If true, partially initialized resources are included in the response. (optional)
   * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
   * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. (optional)
   * @param pretty If &#39;true&#39;, then the output is pretty printed. (optional)
   * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
   * @param timeoutSeconds Timeout for the list/watch call. (optional)
   * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
   * @return IoK8sApimachineryPkgApisMetaV1WatchEvent
   */
  def watchCoreV1NamespacedConfigMap(name: String, namespace: String, continue: Option[String] = None, fieldSelector: Option[String] = None, includeUninitialized: Option[Boolean] = None, labelSelector: Option[String] = None, limit: Option[Integer] = None, pretty: Option[String] = None, resourceVersion: Option[String] = None, timeoutSeconds: Option[Integer] = None, watch: Option[Boolean] = None): Option[IoK8sApimachineryPkgApisMetaV1WatchEvent] = {
    // create path and map variables
    val path = "/api/v1/watch/namespaces/{namespace}/configmaps/{name}".replaceAll("\\{format\\}", "json").replaceAll("\\{" + "name" + "\\}",apiInvoker.escape(name)).replaceAll("\\{" + "namespace" + "\\}",apiInvoker.escape(namespace))

    val contentTypes = List("*/*")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (name == null) throw new Exception("Missing required parameter 'name' when calling Core_v1Api->watchCoreV1NamespacedConfigMap")

    if (namespace == null) throw new Exception("Missing required parameter 'namespace' when calling Core_v1Api->watchCoreV1NamespacedConfigMap")

    continue.map(paramVal => queryParams += "continue" -> paramVal.toString)
    fieldSelector.map(paramVal => queryParams += "fieldSelector" -> paramVal.toString)
    includeUninitialized.map(paramVal => queryParams += "includeUninitialized" -> paramVal.toString)
    labelSelector.map(paramVal => queryParams += "labelSelector" -> paramVal.toString)
    limit.map(paramVal => queryParams += "limit" -> paramVal.toString)
    pretty.map(paramVal => queryParams += "pretty" -> paramVal.toString)
    resourceVersion.map(paramVal => queryParams += "resourceVersion" -> paramVal.toString)
    timeoutSeconds.map(paramVal => queryParams += "timeoutSeconds" -> paramVal.toString)
    watch.map(paramVal => queryParams += "watch" -> paramVal.toString)
    

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "GET", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "", classOf[IoK8sApimachineryPkgApisMetaV1WatchEvent]).asInstanceOf[IoK8sApimachineryPkgApisMetaV1WatchEvent])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * 
   * watch individual changes to a list of ConfigMap
   * @param namespace object name and auth scope, such as for teams and projects 
   * @param continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. (optional)
   * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
   * @param includeUninitialized If true, partially initialized resources are included in the response. (optional)
   * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
   * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. (optional)
   * @param pretty If &#39;true&#39;, then the output is pretty printed. (optional)
   * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
   * @param timeoutSeconds Timeout for the list/watch call. (optional)
   * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
   * @return IoK8sApimachineryPkgApisMetaV1WatchEvent
   */
  def watchCoreV1NamespacedConfigMapList(namespace: String, continue: Option[String] = None, fieldSelector: Option[String] = None, includeUninitialized: Option[Boolean] = None, labelSelector: Option[String] = None, limit: Option[Integer] = None, pretty: Option[String] = None, resourceVersion: Option[String] = None, timeoutSeconds: Option[Integer] = None, watch: Option[Boolean] = None): Option[IoK8sApimachineryPkgApisMetaV1WatchEvent] = {
    // create path and map variables
    val path = "/api/v1/watch/namespaces/{namespace}/configmaps".replaceAll("\\{format\\}", "json").replaceAll("\\{" + "namespace" + "\\}",apiInvoker.escape(namespace))

    val contentTypes = List("*/*")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (namespace == null) throw new Exception("Missing required parameter 'namespace' when calling Core_v1Api->watchCoreV1NamespacedConfigMapList")

    continue.map(paramVal => queryParams += "continue" -> paramVal.toString)
    fieldSelector.map(paramVal => queryParams += "fieldSelector" -> paramVal.toString)
    includeUninitialized.map(paramVal => queryParams += "includeUninitialized" -> paramVal.toString)
    labelSelector.map(paramVal => queryParams += "labelSelector" -> paramVal.toString)
    limit.map(paramVal => queryParams += "limit" -> paramVal.toString)
    pretty.map(paramVal => queryParams += "pretty" -> paramVal.toString)
    resourceVersion.map(paramVal => queryParams += "resourceVersion" -> paramVal.toString)
    timeoutSeconds.map(paramVal => queryParams += "timeoutSeconds" -> paramVal.toString)
    watch.map(paramVal => queryParams += "watch" -> paramVal.toString)
    

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "GET", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "", classOf[IoK8sApimachineryPkgApisMetaV1WatchEvent]).asInstanceOf[IoK8sApimachineryPkgApisMetaV1WatchEvent])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * 
   * watch changes to an object of kind Endpoints
   * @param name name of the Endpoints 
   * @param namespace object name and auth scope, such as for teams and projects 
   * @param continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. (optional)
   * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
   * @param includeUninitialized If true, partially initialized resources are included in the response. (optional)
   * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
   * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. (optional)
   * @param pretty If &#39;true&#39;, then the output is pretty printed. (optional)
   * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
   * @param timeoutSeconds Timeout for the list/watch call. (optional)
   * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
   * @return IoK8sApimachineryPkgApisMetaV1WatchEvent
   */
  def watchCoreV1NamespacedEndpoints(name: String, namespace: String, continue: Option[String] = None, fieldSelector: Option[String] = None, includeUninitialized: Option[Boolean] = None, labelSelector: Option[String] = None, limit: Option[Integer] = None, pretty: Option[String] = None, resourceVersion: Option[String] = None, timeoutSeconds: Option[Integer] = None, watch: Option[Boolean] = None): Option[IoK8sApimachineryPkgApisMetaV1WatchEvent] = {
    // create path and map variables
    val path = "/api/v1/watch/namespaces/{namespace}/endpoints/{name}".replaceAll("\\{format\\}", "json").replaceAll("\\{" + "name" + "\\}",apiInvoker.escape(name)).replaceAll("\\{" + "namespace" + "\\}",apiInvoker.escape(namespace))

    val contentTypes = List("*/*")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (name == null) throw new Exception("Missing required parameter 'name' when calling Core_v1Api->watchCoreV1NamespacedEndpoints")

    if (namespace == null) throw new Exception("Missing required parameter 'namespace' when calling Core_v1Api->watchCoreV1NamespacedEndpoints")

    continue.map(paramVal => queryParams += "continue" -> paramVal.toString)
    fieldSelector.map(paramVal => queryParams += "fieldSelector" -> paramVal.toString)
    includeUninitialized.map(paramVal => queryParams += "includeUninitialized" -> paramVal.toString)
    labelSelector.map(paramVal => queryParams += "labelSelector" -> paramVal.toString)
    limit.map(paramVal => queryParams += "limit" -> paramVal.toString)
    pretty.map(paramVal => queryParams += "pretty" -> paramVal.toString)
    resourceVersion.map(paramVal => queryParams += "resourceVersion" -> paramVal.toString)
    timeoutSeconds.map(paramVal => queryParams += "timeoutSeconds" -> paramVal.toString)
    watch.map(paramVal => queryParams += "watch" -> paramVal.toString)
    

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "GET", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "", classOf[IoK8sApimachineryPkgApisMetaV1WatchEvent]).asInstanceOf[IoK8sApimachineryPkgApisMetaV1WatchEvent])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * 
   * watch individual changes to a list of Endpoints
   * @param namespace object name and auth scope, such as for teams and projects 
   * @param continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. (optional)
   * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
   * @param includeUninitialized If true, partially initialized resources are included in the response. (optional)
   * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
   * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. (optional)
   * @param pretty If &#39;true&#39;, then the output is pretty printed. (optional)
   * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
   * @param timeoutSeconds Timeout for the list/watch call. (optional)
   * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
   * @return IoK8sApimachineryPkgApisMetaV1WatchEvent
   */
  def watchCoreV1NamespacedEndpointsList(namespace: String, continue: Option[String] = None, fieldSelector: Option[String] = None, includeUninitialized: Option[Boolean] = None, labelSelector: Option[String] = None, limit: Option[Integer] = None, pretty: Option[String] = None, resourceVersion: Option[String] = None, timeoutSeconds: Option[Integer] = None, watch: Option[Boolean] = None): Option[IoK8sApimachineryPkgApisMetaV1WatchEvent] = {
    // create path and map variables
    val path = "/api/v1/watch/namespaces/{namespace}/endpoints".replaceAll("\\{format\\}", "json").replaceAll("\\{" + "namespace" + "\\}",apiInvoker.escape(namespace))

    val contentTypes = List("*/*")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (namespace == null) throw new Exception("Missing required parameter 'namespace' when calling Core_v1Api->watchCoreV1NamespacedEndpointsList")

    continue.map(paramVal => queryParams += "continue" -> paramVal.toString)
    fieldSelector.map(paramVal => queryParams += "fieldSelector" -> paramVal.toString)
    includeUninitialized.map(paramVal => queryParams += "includeUninitialized" -> paramVal.toString)
    labelSelector.map(paramVal => queryParams += "labelSelector" -> paramVal.toString)
    limit.map(paramVal => queryParams += "limit" -> paramVal.toString)
    pretty.map(paramVal => queryParams += "pretty" -> paramVal.toString)
    resourceVersion.map(paramVal => queryParams += "resourceVersion" -> paramVal.toString)
    timeoutSeconds.map(paramVal => queryParams += "timeoutSeconds" -> paramVal.toString)
    watch.map(paramVal => queryParams += "watch" -> paramVal.toString)
    

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "GET", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "", classOf[IoK8sApimachineryPkgApisMetaV1WatchEvent]).asInstanceOf[IoK8sApimachineryPkgApisMetaV1WatchEvent])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * 
   * watch changes to an object of kind Event
   * @param name name of the Event 
   * @param namespace object name and auth scope, such as for teams and projects 
   * @param continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. (optional)
   * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
   * @param includeUninitialized If true, partially initialized resources are included in the response. (optional)
   * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
   * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. (optional)
   * @param pretty If &#39;true&#39;, then the output is pretty printed. (optional)
   * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
   * @param timeoutSeconds Timeout for the list/watch call. (optional)
   * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
   * @return IoK8sApimachineryPkgApisMetaV1WatchEvent
   */
  def watchCoreV1NamespacedEvent(name: String, namespace: String, continue: Option[String] = None, fieldSelector: Option[String] = None, includeUninitialized: Option[Boolean] = None, labelSelector: Option[String] = None, limit: Option[Integer] = None, pretty: Option[String] = None, resourceVersion: Option[String] = None, timeoutSeconds: Option[Integer] = None, watch: Option[Boolean] = None): Option[IoK8sApimachineryPkgApisMetaV1WatchEvent] = {
    // create path and map variables
    val path = "/api/v1/watch/namespaces/{namespace}/events/{name}".replaceAll("\\{format\\}", "json").replaceAll("\\{" + "name" + "\\}",apiInvoker.escape(name)).replaceAll("\\{" + "namespace" + "\\}",apiInvoker.escape(namespace))

    val contentTypes = List("*/*")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (name == null) throw new Exception("Missing required parameter 'name' when calling Core_v1Api->watchCoreV1NamespacedEvent")

    if (namespace == null) throw new Exception("Missing required parameter 'namespace' when calling Core_v1Api->watchCoreV1NamespacedEvent")

    continue.map(paramVal => queryParams += "continue" -> paramVal.toString)
    fieldSelector.map(paramVal => queryParams += "fieldSelector" -> paramVal.toString)
    includeUninitialized.map(paramVal => queryParams += "includeUninitialized" -> paramVal.toString)
    labelSelector.map(paramVal => queryParams += "labelSelector" -> paramVal.toString)
    limit.map(paramVal => queryParams += "limit" -> paramVal.toString)
    pretty.map(paramVal => queryParams += "pretty" -> paramVal.toString)
    resourceVersion.map(paramVal => queryParams += "resourceVersion" -> paramVal.toString)
    timeoutSeconds.map(paramVal => queryParams += "timeoutSeconds" -> paramVal.toString)
    watch.map(paramVal => queryParams += "watch" -> paramVal.toString)
    

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "GET", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "", classOf[IoK8sApimachineryPkgApisMetaV1WatchEvent]).asInstanceOf[IoK8sApimachineryPkgApisMetaV1WatchEvent])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * 
   * watch individual changes to a list of Event
   * @param namespace object name and auth scope, such as for teams and projects 
   * @param continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. (optional)
   * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
   * @param includeUninitialized If true, partially initialized resources are included in the response. (optional)
   * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
   * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. (optional)
   * @param pretty If &#39;true&#39;, then the output is pretty printed. (optional)
   * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
   * @param timeoutSeconds Timeout for the list/watch call. (optional)
   * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
   * @return IoK8sApimachineryPkgApisMetaV1WatchEvent
   */
  def watchCoreV1NamespacedEventList(namespace: String, continue: Option[String] = None, fieldSelector: Option[String] = None, includeUninitialized: Option[Boolean] = None, labelSelector: Option[String] = None, limit: Option[Integer] = None, pretty: Option[String] = None, resourceVersion: Option[String] = None, timeoutSeconds: Option[Integer] = None, watch: Option[Boolean] = None): Option[IoK8sApimachineryPkgApisMetaV1WatchEvent] = {
    // create path and map variables
    val path = "/api/v1/watch/namespaces/{namespace}/events".replaceAll("\\{format\\}", "json").replaceAll("\\{" + "namespace" + "\\}",apiInvoker.escape(namespace))

    val contentTypes = List("*/*")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (namespace == null) throw new Exception("Missing required parameter 'namespace' when calling Core_v1Api->watchCoreV1NamespacedEventList")

    continue.map(paramVal => queryParams += "continue" -> paramVal.toString)
    fieldSelector.map(paramVal => queryParams += "fieldSelector" -> paramVal.toString)
    includeUninitialized.map(paramVal => queryParams += "includeUninitialized" -> paramVal.toString)
    labelSelector.map(paramVal => queryParams += "labelSelector" -> paramVal.toString)
    limit.map(paramVal => queryParams += "limit" -> paramVal.toString)
    pretty.map(paramVal => queryParams += "pretty" -> paramVal.toString)
    resourceVersion.map(paramVal => queryParams += "resourceVersion" -> paramVal.toString)
    timeoutSeconds.map(paramVal => queryParams += "timeoutSeconds" -> paramVal.toString)
    watch.map(paramVal => queryParams += "watch" -> paramVal.toString)
    

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "GET", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "", classOf[IoK8sApimachineryPkgApisMetaV1WatchEvent]).asInstanceOf[IoK8sApimachineryPkgApisMetaV1WatchEvent])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * 
   * watch changes to an object of kind LimitRange
   * @param name name of the LimitRange 
   * @param namespace object name and auth scope, such as for teams and projects 
   * @param continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. (optional)
   * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
   * @param includeUninitialized If true, partially initialized resources are included in the response. (optional)
   * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
   * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. (optional)
   * @param pretty If &#39;true&#39;, then the output is pretty printed. (optional)
   * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
   * @param timeoutSeconds Timeout for the list/watch call. (optional)
   * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
   * @return IoK8sApimachineryPkgApisMetaV1WatchEvent
   */
  def watchCoreV1NamespacedLimitRange(name: String, namespace: String, continue: Option[String] = None, fieldSelector: Option[String] = None, includeUninitialized: Option[Boolean] = None, labelSelector: Option[String] = None, limit: Option[Integer] = None, pretty: Option[String] = None, resourceVersion: Option[String] = None, timeoutSeconds: Option[Integer] = None, watch: Option[Boolean] = None): Option[IoK8sApimachineryPkgApisMetaV1WatchEvent] = {
    // create path and map variables
    val path = "/api/v1/watch/namespaces/{namespace}/limitranges/{name}".replaceAll("\\{format\\}", "json").replaceAll("\\{" + "name" + "\\}",apiInvoker.escape(name)).replaceAll("\\{" + "namespace" + "\\}",apiInvoker.escape(namespace))

    val contentTypes = List("*/*")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (name == null) throw new Exception("Missing required parameter 'name' when calling Core_v1Api->watchCoreV1NamespacedLimitRange")

    if (namespace == null) throw new Exception("Missing required parameter 'namespace' when calling Core_v1Api->watchCoreV1NamespacedLimitRange")

    continue.map(paramVal => queryParams += "continue" -> paramVal.toString)
    fieldSelector.map(paramVal => queryParams += "fieldSelector" -> paramVal.toString)
    includeUninitialized.map(paramVal => queryParams += "includeUninitialized" -> paramVal.toString)
    labelSelector.map(paramVal => queryParams += "labelSelector" -> paramVal.toString)
    limit.map(paramVal => queryParams += "limit" -> paramVal.toString)
    pretty.map(paramVal => queryParams += "pretty" -> paramVal.toString)
    resourceVersion.map(paramVal => queryParams += "resourceVersion" -> paramVal.toString)
    timeoutSeconds.map(paramVal => queryParams += "timeoutSeconds" -> paramVal.toString)
    watch.map(paramVal => queryParams += "watch" -> paramVal.toString)
    

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "GET", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "", classOf[IoK8sApimachineryPkgApisMetaV1WatchEvent]).asInstanceOf[IoK8sApimachineryPkgApisMetaV1WatchEvent])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * 
   * watch individual changes to a list of LimitRange
   * @param namespace object name and auth scope, such as for teams and projects 
   * @param continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. (optional)
   * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
   * @param includeUninitialized If true, partially initialized resources are included in the response. (optional)
   * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
   * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. (optional)
   * @param pretty If &#39;true&#39;, then the output is pretty printed. (optional)
   * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
   * @param timeoutSeconds Timeout for the list/watch call. (optional)
   * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
   * @return IoK8sApimachineryPkgApisMetaV1WatchEvent
   */
  def watchCoreV1NamespacedLimitRangeList(namespace: String, continue: Option[String] = None, fieldSelector: Option[String] = None, includeUninitialized: Option[Boolean] = None, labelSelector: Option[String] = None, limit: Option[Integer] = None, pretty: Option[String] = None, resourceVersion: Option[String] = None, timeoutSeconds: Option[Integer] = None, watch: Option[Boolean] = None): Option[IoK8sApimachineryPkgApisMetaV1WatchEvent] = {
    // create path and map variables
    val path = "/api/v1/watch/namespaces/{namespace}/limitranges".replaceAll("\\{format\\}", "json").replaceAll("\\{" + "namespace" + "\\}",apiInvoker.escape(namespace))

    val contentTypes = List("*/*")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (namespace == null) throw new Exception("Missing required parameter 'namespace' when calling Core_v1Api->watchCoreV1NamespacedLimitRangeList")

    continue.map(paramVal => queryParams += "continue" -> paramVal.toString)
    fieldSelector.map(paramVal => queryParams += "fieldSelector" -> paramVal.toString)
    includeUninitialized.map(paramVal => queryParams += "includeUninitialized" -> paramVal.toString)
    labelSelector.map(paramVal => queryParams += "labelSelector" -> paramVal.toString)
    limit.map(paramVal => queryParams += "limit" -> paramVal.toString)
    pretty.map(paramVal => queryParams += "pretty" -> paramVal.toString)
    resourceVersion.map(paramVal => queryParams += "resourceVersion" -> paramVal.toString)
    timeoutSeconds.map(paramVal => queryParams += "timeoutSeconds" -> paramVal.toString)
    watch.map(paramVal => queryParams += "watch" -> paramVal.toString)
    

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "GET", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "", classOf[IoK8sApimachineryPkgApisMetaV1WatchEvent]).asInstanceOf[IoK8sApimachineryPkgApisMetaV1WatchEvent])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * 
   * watch changes to an object of kind PersistentVolumeClaim
   * @param name name of the PersistentVolumeClaim 
   * @param namespace object name and auth scope, such as for teams and projects 
   * @param continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. (optional)
   * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
   * @param includeUninitialized If true, partially initialized resources are included in the response. (optional)
   * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
   * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. (optional)
   * @param pretty If &#39;true&#39;, then the output is pretty printed. (optional)
   * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
   * @param timeoutSeconds Timeout for the list/watch call. (optional)
   * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
   * @return IoK8sApimachineryPkgApisMetaV1WatchEvent
   */
  def watchCoreV1NamespacedPersistentVolumeClaim(name: String, namespace: String, continue: Option[String] = None, fieldSelector: Option[String] = None, includeUninitialized: Option[Boolean] = None, labelSelector: Option[String] = None, limit: Option[Integer] = None, pretty: Option[String] = None, resourceVersion: Option[String] = None, timeoutSeconds: Option[Integer] = None, watch: Option[Boolean] = None): Option[IoK8sApimachineryPkgApisMetaV1WatchEvent] = {
    // create path and map variables
    val path = "/api/v1/watch/namespaces/{namespace}/persistentvolumeclaims/{name}".replaceAll("\\{format\\}", "json").replaceAll("\\{" + "name" + "\\}",apiInvoker.escape(name)).replaceAll("\\{" + "namespace" + "\\}",apiInvoker.escape(namespace))

    val contentTypes = List("*/*")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (name == null) throw new Exception("Missing required parameter 'name' when calling Core_v1Api->watchCoreV1NamespacedPersistentVolumeClaim")

    if (namespace == null) throw new Exception("Missing required parameter 'namespace' when calling Core_v1Api->watchCoreV1NamespacedPersistentVolumeClaim")

    continue.map(paramVal => queryParams += "continue" -> paramVal.toString)
    fieldSelector.map(paramVal => queryParams += "fieldSelector" -> paramVal.toString)
    includeUninitialized.map(paramVal => queryParams += "includeUninitialized" -> paramVal.toString)
    labelSelector.map(paramVal => queryParams += "labelSelector" -> paramVal.toString)
    limit.map(paramVal => queryParams += "limit" -> paramVal.toString)
    pretty.map(paramVal => queryParams += "pretty" -> paramVal.toString)
    resourceVersion.map(paramVal => queryParams += "resourceVersion" -> paramVal.toString)
    timeoutSeconds.map(paramVal => queryParams += "timeoutSeconds" -> paramVal.toString)
    watch.map(paramVal => queryParams += "watch" -> paramVal.toString)
    

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "GET", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "", classOf[IoK8sApimachineryPkgApisMetaV1WatchEvent]).asInstanceOf[IoK8sApimachineryPkgApisMetaV1WatchEvent])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * 
   * watch individual changes to a list of PersistentVolumeClaim
   * @param namespace object name and auth scope, such as for teams and projects 
   * @param continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. (optional)
   * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
   * @param includeUninitialized If true, partially initialized resources are included in the response. (optional)
   * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
   * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. (optional)
   * @param pretty If &#39;true&#39;, then the output is pretty printed. (optional)
   * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
   * @param timeoutSeconds Timeout for the list/watch call. (optional)
   * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
   * @return IoK8sApimachineryPkgApisMetaV1WatchEvent
   */
  def watchCoreV1NamespacedPersistentVolumeClaimList(namespace: String, continue: Option[String] = None, fieldSelector: Option[String] = None, includeUninitialized: Option[Boolean] = None, labelSelector: Option[String] = None, limit: Option[Integer] = None, pretty: Option[String] = None, resourceVersion: Option[String] = None, timeoutSeconds: Option[Integer] = None, watch: Option[Boolean] = None): Option[IoK8sApimachineryPkgApisMetaV1WatchEvent] = {
    // create path and map variables
    val path = "/api/v1/watch/namespaces/{namespace}/persistentvolumeclaims".replaceAll("\\{format\\}", "json").replaceAll("\\{" + "namespace" + "\\}",apiInvoker.escape(namespace))

    val contentTypes = List("*/*")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (namespace == null) throw new Exception("Missing required parameter 'namespace' when calling Core_v1Api->watchCoreV1NamespacedPersistentVolumeClaimList")

    continue.map(paramVal => queryParams += "continue" -> paramVal.toString)
    fieldSelector.map(paramVal => queryParams += "fieldSelector" -> paramVal.toString)
    includeUninitialized.map(paramVal => queryParams += "includeUninitialized" -> paramVal.toString)
    labelSelector.map(paramVal => queryParams += "labelSelector" -> paramVal.toString)
    limit.map(paramVal => queryParams += "limit" -> paramVal.toString)
    pretty.map(paramVal => queryParams += "pretty" -> paramVal.toString)
    resourceVersion.map(paramVal => queryParams += "resourceVersion" -> paramVal.toString)
    timeoutSeconds.map(paramVal => queryParams += "timeoutSeconds" -> paramVal.toString)
    watch.map(paramVal => queryParams += "watch" -> paramVal.toString)
    

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "GET", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "", classOf[IoK8sApimachineryPkgApisMetaV1WatchEvent]).asInstanceOf[IoK8sApimachineryPkgApisMetaV1WatchEvent])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * 
   * watch changes to an object of kind Pod
   * @param name name of the Pod 
   * @param namespace object name and auth scope, such as for teams and projects 
   * @param continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. (optional)
   * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
   * @param includeUninitialized If true, partially initialized resources are included in the response. (optional)
   * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
   * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. (optional)
   * @param pretty If &#39;true&#39;, then the output is pretty printed. (optional)
   * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
   * @param timeoutSeconds Timeout for the list/watch call. (optional)
   * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
   * @return IoK8sApimachineryPkgApisMetaV1WatchEvent
   */
  def watchCoreV1NamespacedPod(name: String, namespace: String, continue: Option[String] = None, fieldSelector: Option[String] = None, includeUninitialized: Option[Boolean] = None, labelSelector: Option[String] = None, limit: Option[Integer] = None, pretty: Option[String] = None, resourceVersion: Option[String] = None, timeoutSeconds: Option[Integer] = None, watch: Option[Boolean] = None): Option[IoK8sApimachineryPkgApisMetaV1WatchEvent] = {
    // create path and map variables
    val path = "/api/v1/watch/namespaces/{namespace}/pods/{name}".replaceAll("\\{format\\}", "json").replaceAll("\\{" + "name" + "\\}",apiInvoker.escape(name)).replaceAll("\\{" + "namespace" + "\\}",apiInvoker.escape(namespace))

    val contentTypes = List("*/*")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (name == null) throw new Exception("Missing required parameter 'name' when calling Core_v1Api->watchCoreV1NamespacedPod")

    if (namespace == null) throw new Exception("Missing required parameter 'namespace' when calling Core_v1Api->watchCoreV1NamespacedPod")

    continue.map(paramVal => queryParams += "continue" -> paramVal.toString)
    fieldSelector.map(paramVal => queryParams += "fieldSelector" -> paramVal.toString)
    includeUninitialized.map(paramVal => queryParams += "includeUninitialized" -> paramVal.toString)
    labelSelector.map(paramVal => queryParams += "labelSelector" -> paramVal.toString)
    limit.map(paramVal => queryParams += "limit" -> paramVal.toString)
    pretty.map(paramVal => queryParams += "pretty" -> paramVal.toString)
    resourceVersion.map(paramVal => queryParams += "resourceVersion" -> paramVal.toString)
    timeoutSeconds.map(paramVal => queryParams += "timeoutSeconds" -> paramVal.toString)
    watch.map(paramVal => queryParams += "watch" -> paramVal.toString)
    

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "GET", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "", classOf[IoK8sApimachineryPkgApisMetaV1WatchEvent]).asInstanceOf[IoK8sApimachineryPkgApisMetaV1WatchEvent])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * 
   * watch individual changes to a list of Pod
   * @param namespace object name and auth scope, such as for teams and projects 
   * @param continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. (optional)
   * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
   * @param includeUninitialized If true, partially initialized resources are included in the response. (optional)
   * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
   * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. (optional)
   * @param pretty If &#39;true&#39;, then the output is pretty printed. (optional)
   * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
   * @param timeoutSeconds Timeout for the list/watch call. (optional)
   * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
   * @return IoK8sApimachineryPkgApisMetaV1WatchEvent
   */
  def watchCoreV1NamespacedPodList(namespace: String, continue: Option[String] = None, fieldSelector: Option[String] = None, includeUninitialized: Option[Boolean] = None, labelSelector: Option[String] = None, limit: Option[Integer] = None, pretty: Option[String] = None, resourceVersion: Option[String] = None, timeoutSeconds: Option[Integer] = None, watch: Option[Boolean] = None): Option[IoK8sApimachineryPkgApisMetaV1WatchEvent] = {
    // create path and map variables
    val path = "/api/v1/watch/namespaces/{namespace}/pods".replaceAll("\\{format\\}", "json").replaceAll("\\{" + "namespace" + "\\}",apiInvoker.escape(namespace))

    val contentTypes = List("*/*")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (namespace == null) throw new Exception("Missing required parameter 'namespace' when calling Core_v1Api->watchCoreV1NamespacedPodList")

    continue.map(paramVal => queryParams += "continue" -> paramVal.toString)
    fieldSelector.map(paramVal => queryParams += "fieldSelector" -> paramVal.toString)
    includeUninitialized.map(paramVal => queryParams += "includeUninitialized" -> paramVal.toString)
    labelSelector.map(paramVal => queryParams += "labelSelector" -> paramVal.toString)
    limit.map(paramVal => queryParams += "limit" -> paramVal.toString)
    pretty.map(paramVal => queryParams += "pretty" -> paramVal.toString)
    resourceVersion.map(paramVal => queryParams += "resourceVersion" -> paramVal.toString)
    timeoutSeconds.map(paramVal => queryParams += "timeoutSeconds" -> paramVal.toString)
    watch.map(paramVal => queryParams += "watch" -> paramVal.toString)
    

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "GET", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "", classOf[IoK8sApimachineryPkgApisMetaV1WatchEvent]).asInstanceOf[IoK8sApimachineryPkgApisMetaV1WatchEvent])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * 
   * watch changes to an object of kind PodTemplate
   * @param name name of the PodTemplate 
   * @param namespace object name and auth scope, such as for teams and projects 
   * @param continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. (optional)
   * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
   * @param includeUninitialized If true, partially initialized resources are included in the response. (optional)
   * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
   * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. (optional)
   * @param pretty If &#39;true&#39;, then the output is pretty printed. (optional)
   * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
   * @param timeoutSeconds Timeout for the list/watch call. (optional)
   * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
   * @return IoK8sApimachineryPkgApisMetaV1WatchEvent
   */
  def watchCoreV1NamespacedPodTemplate(name: String, namespace: String, continue: Option[String] = None, fieldSelector: Option[String] = None, includeUninitialized: Option[Boolean] = None, labelSelector: Option[String] = None, limit: Option[Integer] = None, pretty: Option[String] = None, resourceVersion: Option[String] = None, timeoutSeconds: Option[Integer] = None, watch: Option[Boolean] = None): Option[IoK8sApimachineryPkgApisMetaV1WatchEvent] = {
    // create path and map variables
    val path = "/api/v1/watch/namespaces/{namespace}/podtemplates/{name}".replaceAll("\\{format\\}", "json").replaceAll("\\{" + "name" + "\\}",apiInvoker.escape(name)).replaceAll("\\{" + "namespace" + "\\}",apiInvoker.escape(namespace))

    val contentTypes = List("*/*")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (name == null) throw new Exception("Missing required parameter 'name' when calling Core_v1Api->watchCoreV1NamespacedPodTemplate")

    if (namespace == null) throw new Exception("Missing required parameter 'namespace' when calling Core_v1Api->watchCoreV1NamespacedPodTemplate")

    continue.map(paramVal => queryParams += "continue" -> paramVal.toString)
    fieldSelector.map(paramVal => queryParams += "fieldSelector" -> paramVal.toString)
    includeUninitialized.map(paramVal => queryParams += "includeUninitialized" -> paramVal.toString)
    labelSelector.map(paramVal => queryParams += "labelSelector" -> paramVal.toString)
    limit.map(paramVal => queryParams += "limit" -> paramVal.toString)
    pretty.map(paramVal => queryParams += "pretty" -> paramVal.toString)
    resourceVersion.map(paramVal => queryParams += "resourceVersion" -> paramVal.toString)
    timeoutSeconds.map(paramVal => queryParams += "timeoutSeconds" -> paramVal.toString)
    watch.map(paramVal => queryParams += "watch" -> paramVal.toString)
    

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "GET", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "", classOf[IoK8sApimachineryPkgApisMetaV1WatchEvent]).asInstanceOf[IoK8sApimachineryPkgApisMetaV1WatchEvent])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * 
   * watch individual changes to a list of PodTemplate
   * @param namespace object name and auth scope, such as for teams and projects 
   * @param continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. (optional)
   * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
   * @param includeUninitialized If true, partially initialized resources are included in the response. (optional)
   * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
   * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. (optional)
   * @param pretty If &#39;true&#39;, then the output is pretty printed. (optional)
   * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
   * @param timeoutSeconds Timeout for the list/watch call. (optional)
   * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
   * @return IoK8sApimachineryPkgApisMetaV1WatchEvent
   */
  def watchCoreV1NamespacedPodTemplateList(namespace: String, continue: Option[String] = None, fieldSelector: Option[String] = None, includeUninitialized: Option[Boolean] = None, labelSelector: Option[String] = None, limit: Option[Integer] = None, pretty: Option[String] = None, resourceVersion: Option[String] = None, timeoutSeconds: Option[Integer] = None, watch: Option[Boolean] = None): Option[IoK8sApimachineryPkgApisMetaV1WatchEvent] = {
    // create path and map variables
    val path = "/api/v1/watch/namespaces/{namespace}/podtemplates".replaceAll("\\{format\\}", "json").replaceAll("\\{" + "namespace" + "\\}",apiInvoker.escape(namespace))

    val contentTypes = List("*/*")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (namespace == null) throw new Exception("Missing required parameter 'namespace' when calling Core_v1Api->watchCoreV1NamespacedPodTemplateList")

    continue.map(paramVal => queryParams += "continue" -> paramVal.toString)
    fieldSelector.map(paramVal => queryParams += "fieldSelector" -> paramVal.toString)
    includeUninitialized.map(paramVal => queryParams += "includeUninitialized" -> paramVal.toString)
    labelSelector.map(paramVal => queryParams += "labelSelector" -> paramVal.toString)
    limit.map(paramVal => queryParams += "limit" -> paramVal.toString)
    pretty.map(paramVal => queryParams += "pretty" -> paramVal.toString)
    resourceVersion.map(paramVal => queryParams += "resourceVersion" -> paramVal.toString)
    timeoutSeconds.map(paramVal => queryParams += "timeoutSeconds" -> paramVal.toString)
    watch.map(paramVal => queryParams += "watch" -> paramVal.toString)
    

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "GET", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "", classOf[IoK8sApimachineryPkgApisMetaV1WatchEvent]).asInstanceOf[IoK8sApimachineryPkgApisMetaV1WatchEvent])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * 
   * watch changes to an object of kind ReplicationController
   * @param name name of the ReplicationController 
   * @param namespace object name and auth scope, such as for teams and projects 
   * @param continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. (optional)
   * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
   * @param includeUninitialized If true, partially initialized resources are included in the response. (optional)
   * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
   * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. (optional)
   * @param pretty If &#39;true&#39;, then the output is pretty printed. (optional)
   * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
   * @param timeoutSeconds Timeout for the list/watch call. (optional)
   * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
   * @return IoK8sApimachineryPkgApisMetaV1WatchEvent
   */
  def watchCoreV1NamespacedReplicationController(name: String, namespace: String, continue: Option[String] = None, fieldSelector: Option[String] = None, includeUninitialized: Option[Boolean] = None, labelSelector: Option[String] = None, limit: Option[Integer] = None, pretty: Option[String] = None, resourceVersion: Option[String] = None, timeoutSeconds: Option[Integer] = None, watch: Option[Boolean] = None): Option[IoK8sApimachineryPkgApisMetaV1WatchEvent] = {
    // create path and map variables
    val path = "/api/v1/watch/namespaces/{namespace}/replicationcontrollers/{name}".replaceAll("\\{format\\}", "json").replaceAll("\\{" + "name" + "\\}",apiInvoker.escape(name)).replaceAll("\\{" + "namespace" + "\\}",apiInvoker.escape(namespace))

    val contentTypes = List("*/*")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (name == null) throw new Exception("Missing required parameter 'name' when calling Core_v1Api->watchCoreV1NamespacedReplicationController")

    if (namespace == null) throw new Exception("Missing required parameter 'namespace' when calling Core_v1Api->watchCoreV1NamespacedReplicationController")

    continue.map(paramVal => queryParams += "continue" -> paramVal.toString)
    fieldSelector.map(paramVal => queryParams += "fieldSelector" -> paramVal.toString)
    includeUninitialized.map(paramVal => queryParams += "includeUninitialized" -> paramVal.toString)
    labelSelector.map(paramVal => queryParams += "labelSelector" -> paramVal.toString)
    limit.map(paramVal => queryParams += "limit" -> paramVal.toString)
    pretty.map(paramVal => queryParams += "pretty" -> paramVal.toString)
    resourceVersion.map(paramVal => queryParams += "resourceVersion" -> paramVal.toString)
    timeoutSeconds.map(paramVal => queryParams += "timeoutSeconds" -> paramVal.toString)
    watch.map(paramVal => queryParams += "watch" -> paramVal.toString)
    

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "GET", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "", classOf[IoK8sApimachineryPkgApisMetaV1WatchEvent]).asInstanceOf[IoK8sApimachineryPkgApisMetaV1WatchEvent])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * 
   * watch individual changes to a list of ReplicationController
   * @param namespace object name and auth scope, such as for teams and projects 
   * @param continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. (optional)
   * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
   * @param includeUninitialized If true, partially initialized resources are included in the response. (optional)
   * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
   * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. (optional)
   * @param pretty If &#39;true&#39;, then the output is pretty printed. (optional)
   * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
   * @param timeoutSeconds Timeout for the list/watch call. (optional)
   * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
   * @return IoK8sApimachineryPkgApisMetaV1WatchEvent
   */
  def watchCoreV1NamespacedReplicationControllerList(namespace: String, continue: Option[String] = None, fieldSelector: Option[String] = None, includeUninitialized: Option[Boolean] = None, labelSelector: Option[String] = None, limit: Option[Integer] = None, pretty: Option[String] = None, resourceVersion: Option[String] = None, timeoutSeconds: Option[Integer] = None, watch: Option[Boolean] = None): Option[IoK8sApimachineryPkgApisMetaV1WatchEvent] = {
    // create path and map variables
    val path = "/api/v1/watch/namespaces/{namespace}/replicationcontrollers".replaceAll("\\{format\\}", "json").replaceAll("\\{" + "namespace" + "\\}",apiInvoker.escape(namespace))

    val contentTypes = List("*/*")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (namespace == null) throw new Exception("Missing required parameter 'namespace' when calling Core_v1Api->watchCoreV1NamespacedReplicationControllerList")

    continue.map(paramVal => queryParams += "continue" -> paramVal.toString)
    fieldSelector.map(paramVal => queryParams += "fieldSelector" -> paramVal.toString)
    includeUninitialized.map(paramVal => queryParams += "includeUninitialized" -> paramVal.toString)
    labelSelector.map(paramVal => queryParams += "labelSelector" -> paramVal.toString)
    limit.map(paramVal => queryParams += "limit" -> paramVal.toString)
    pretty.map(paramVal => queryParams += "pretty" -> paramVal.toString)
    resourceVersion.map(paramVal => queryParams += "resourceVersion" -> paramVal.toString)
    timeoutSeconds.map(paramVal => queryParams += "timeoutSeconds" -> paramVal.toString)
    watch.map(paramVal => queryParams += "watch" -> paramVal.toString)
    

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "GET", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "", classOf[IoK8sApimachineryPkgApisMetaV1WatchEvent]).asInstanceOf[IoK8sApimachineryPkgApisMetaV1WatchEvent])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * 
   * watch changes to an object of kind ResourceQuota
   * @param name name of the ResourceQuota 
   * @param namespace object name and auth scope, such as for teams and projects 
   * @param continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. (optional)
   * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
   * @param includeUninitialized If true, partially initialized resources are included in the response. (optional)
   * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
   * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. (optional)
   * @param pretty If &#39;true&#39;, then the output is pretty printed. (optional)
   * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
   * @param timeoutSeconds Timeout for the list/watch call. (optional)
   * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
   * @return IoK8sApimachineryPkgApisMetaV1WatchEvent
   */
  def watchCoreV1NamespacedResourceQuota(name: String, namespace: String, continue: Option[String] = None, fieldSelector: Option[String] = None, includeUninitialized: Option[Boolean] = None, labelSelector: Option[String] = None, limit: Option[Integer] = None, pretty: Option[String] = None, resourceVersion: Option[String] = None, timeoutSeconds: Option[Integer] = None, watch: Option[Boolean] = None): Option[IoK8sApimachineryPkgApisMetaV1WatchEvent] = {
    // create path and map variables
    val path = "/api/v1/watch/namespaces/{namespace}/resourcequotas/{name}".replaceAll("\\{format\\}", "json").replaceAll("\\{" + "name" + "\\}",apiInvoker.escape(name)).replaceAll("\\{" + "namespace" + "\\}",apiInvoker.escape(namespace))

    val contentTypes = List("*/*")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (name == null) throw new Exception("Missing required parameter 'name' when calling Core_v1Api->watchCoreV1NamespacedResourceQuota")

    if (namespace == null) throw new Exception("Missing required parameter 'namespace' when calling Core_v1Api->watchCoreV1NamespacedResourceQuota")

    continue.map(paramVal => queryParams += "continue" -> paramVal.toString)
    fieldSelector.map(paramVal => queryParams += "fieldSelector" -> paramVal.toString)
    includeUninitialized.map(paramVal => queryParams += "includeUninitialized" -> paramVal.toString)
    labelSelector.map(paramVal => queryParams += "labelSelector" -> paramVal.toString)
    limit.map(paramVal => queryParams += "limit" -> paramVal.toString)
    pretty.map(paramVal => queryParams += "pretty" -> paramVal.toString)
    resourceVersion.map(paramVal => queryParams += "resourceVersion" -> paramVal.toString)
    timeoutSeconds.map(paramVal => queryParams += "timeoutSeconds" -> paramVal.toString)
    watch.map(paramVal => queryParams += "watch" -> paramVal.toString)
    

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "GET", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "", classOf[IoK8sApimachineryPkgApisMetaV1WatchEvent]).asInstanceOf[IoK8sApimachineryPkgApisMetaV1WatchEvent])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * 
   * watch individual changes to a list of ResourceQuota
   * @param namespace object name and auth scope, such as for teams and projects 
   * @param continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. (optional)
   * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
   * @param includeUninitialized If true, partially initialized resources are included in the response. (optional)
   * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
   * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. (optional)
   * @param pretty If &#39;true&#39;, then the output is pretty printed. (optional)
   * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
   * @param timeoutSeconds Timeout for the list/watch call. (optional)
   * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
   * @return IoK8sApimachineryPkgApisMetaV1WatchEvent
   */
  def watchCoreV1NamespacedResourceQuotaList(namespace: String, continue: Option[String] = None, fieldSelector: Option[String] = None, includeUninitialized: Option[Boolean] = None, labelSelector: Option[String] = None, limit: Option[Integer] = None, pretty: Option[String] = None, resourceVersion: Option[String] = None, timeoutSeconds: Option[Integer] = None, watch: Option[Boolean] = None): Option[IoK8sApimachineryPkgApisMetaV1WatchEvent] = {
    // create path and map variables
    val path = "/api/v1/watch/namespaces/{namespace}/resourcequotas".replaceAll("\\{format\\}", "json").replaceAll("\\{" + "namespace" + "\\}",apiInvoker.escape(namespace))

    val contentTypes = List("*/*")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (namespace == null) throw new Exception("Missing required parameter 'namespace' when calling Core_v1Api->watchCoreV1NamespacedResourceQuotaList")

    continue.map(paramVal => queryParams += "continue" -> paramVal.toString)
    fieldSelector.map(paramVal => queryParams += "fieldSelector" -> paramVal.toString)
    includeUninitialized.map(paramVal => queryParams += "includeUninitialized" -> paramVal.toString)
    labelSelector.map(paramVal => queryParams += "labelSelector" -> paramVal.toString)
    limit.map(paramVal => queryParams += "limit" -> paramVal.toString)
    pretty.map(paramVal => queryParams += "pretty" -> paramVal.toString)
    resourceVersion.map(paramVal => queryParams += "resourceVersion" -> paramVal.toString)
    timeoutSeconds.map(paramVal => queryParams += "timeoutSeconds" -> paramVal.toString)
    watch.map(paramVal => queryParams += "watch" -> paramVal.toString)
    

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "GET", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "", classOf[IoK8sApimachineryPkgApisMetaV1WatchEvent]).asInstanceOf[IoK8sApimachineryPkgApisMetaV1WatchEvent])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * 
   * watch changes to an object of kind Secret
   * @param name name of the Secret 
   * @param namespace object name and auth scope, such as for teams and projects 
   * @param continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. (optional)
   * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
   * @param includeUninitialized If true, partially initialized resources are included in the response. (optional)
   * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
   * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. (optional)
   * @param pretty If &#39;true&#39;, then the output is pretty printed. (optional)
   * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
   * @param timeoutSeconds Timeout for the list/watch call. (optional)
   * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
   * @return IoK8sApimachineryPkgApisMetaV1WatchEvent
   */
  def watchCoreV1NamespacedSecret(name: String, namespace: String, continue: Option[String] = None, fieldSelector: Option[String] = None, includeUninitialized: Option[Boolean] = None, labelSelector: Option[String] = None, limit: Option[Integer] = None, pretty: Option[String] = None, resourceVersion: Option[String] = None, timeoutSeconds: Option[Integer] = None, watch: Option[Boolean] = None): Option[IoK8sApimachineryPkgApisMetaV1WatchEvent] = {
    // create path and map variables
    val path = "/api/v1/watch/namespaces/{namespace}/secrets/{name}".replaceAll("\\{format\\}", "json").replaceAll("\\{" + "name" + "\\}",apiInvoker.escape(name)).replaceAll("\\{" + "namespace" + "\\}",apiInvoker.escape(namespace))

    val contentTypes = List("*/*")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (name == null) throw new Exception("Missing required parameter 'name' when calling Core_v1Api->watchCoreV1NamespacedSecret")

    if (namespace == null) throw new Exception("Missing required parameter 'namespace' when calling Core_v1Api->watchCoreV1NamespacedSecret")

    continue.map(paramVal => queryParams += "continue" -> paramVal.toString)
    fieldSelector.map(paramVal => queryParams += "fieldSelector" -> paramVal.toString)
    includeUninitialized.map(paramVal => queryParams += "includeUninitialized" -> paramVal.toString)
    labelSelector.map(paramVal => queryParams += "labelSelector" -> paramVal.toString)
    limit.map(paramVal => queryParams += "limit" -> paramVal.toString)
    pretty.map(paramVal => queryParams += "pretty" -> paramVal.toString)
    resourceVersion.map(paramVal => queryParams += "resourceVersion" -> paramVal.toString)
    timeoutSeconds.map(paramVal => queryParams += "timeoutSeconds" -> paramVal.toString)
    watch.map(paramVal => queryParams += "watch" -> paramVal.toString)
    

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "GET", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "", classOf[IoK8sApimachineryPkgApisMetaV1WatchEvent]).asInstanceOf[IoK8sApimachineryPkgApisMetaV1WatchEvent])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * 
   * watch individual changes to a list of Secret
   * @param namespace object name and auth scope, such as for teams and projects 
   * @param continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. (optional)
   * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
   * @param includeUninitialized If true, partially initialized resources are included in the response. (optional)
   * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
   * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. (optional)
   * @param pretty If &#39;true&#39;, then the output is pretty printed. (optional)
   * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
   * @param timeoutSeconds Timeout for the list/watch call. (optional)
   * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
   * @return IoK8sApimachineryPkgApisMetaV1WatchEvent
   */
  def watchCoreV1NamespacedSecretList(namespace: String, continue: Option[String] = None, fieldSelector: Option[String] = None, includeUninitialized: Option[Boolean] = None, labelSelector: Option[String] = None, limit: Option[Integer] = None, pretty: Option[String] = None, resourceVersion: Option[String] = None, timeoutSeconds: Option[Integer] = None, watch: Option[Boolean] = None): Option[IoK8sApimachineryPkgApisMetaV1WatchEvent] = {
    // create path and map variables
    val path = "/api/v1/watch/namespaces/{namespace}/secrets".replaceAll("\\{format\\}", "json").replaceAll("\\{" + "namespace" + "\\}",apiInvoker.escape(namespace))

    val contentTypes = List("*/*")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (namespace == null) throw new Exception("Missing required parameter 'namespace' when calling Core_v1Api->watchCoreV1NamespacedSecretList")

    continue.map(paramVal => queryParams += "continue" -> paramVal.toString)
    fieldSelector.map(paramVal => queryParams += "fieldSelector" -> paramVal.toString)
    includeUninitialized.map(paramVal => queryParams += "includeUninitialized" -> paramVal.toString)
    labelSelector.map(paramVal => queryParams += "labelSelector" -> paramVal.toString)
    limit.map(paramVal => queryParams += "limit" -> paramVal.toString)
    pretty.map(paramVal => queryParams += "pretty" -> paramVal.toString)
    resourceVersion.map(paramVal => queryParams += "resourceVersion" -> paramVal.toString)
    timeoutSeconds.map(paramVal => queryParams += "timeoutSeconds" -> paramVal.toString)
    watch.map(paramVal => queryParams += "watch" -> paramVal.toString)
    

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "GET", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "", classOf[IoK8sApimachineryPkgApisMetaV1WatchEvent]).asInstanceOf[IoK8sApimachineryPkgApisMetaV1WatchEvent])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * 
   * watch changes to an object of kind Service
   * @param name name of the Service 
   * @param namespace object name and auth scope, such as for teams and projects 
   * @param continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. (optional)
   * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
   * @param includeUninitialized If true, partially initialized resources are included in the response. (optional)
   * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
   * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. (optional)
   * @param pretty If &#39;true&#39;, then the output is pretty printed. (optional)
   * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
   * @param timeoutSeconds Timeout for the list/watch call. (optional)
   * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
   * @return IoK8sApimachineryPkgApisMetaV1WatchEvent
   */
  def watchCoreV1NamespacedService(name: String, namespace: String, continue: Option[String] = None, fieldSelector: Option[String] = None, includeUninitialized: Option[Boolean] = None, labelSelector: Option[String] = None, limit: Option[Integer] = None, pretty: Option[String] = None, resourceVersion: Option[String] = None, timeoutSeconds: Option[Integer] = None, watch: Option[Boolean] = None): Option[IoK8sApimachineryPkgApisMetaV1WatchEvent] = {
    // create path and map variables
    val path = "/api/v1/watch/namespaces/{namespace}/services/{name}".replaceAll("\\{format\\}", "json").replaceAll("\\{" + "name" + "\\}",apiInvoker.escape(name)).replaceAll("\\{" + "namespace" + "\\}",apiInvoker.escape(namespace))

    val contentTypes = List("*/*")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (name == null) throw new Exception("Missing required parameter 'name' when calling Core_v1Api->watchCoreV1NamespacedService")

    if (namespace == null) throw new Exception("Missing required parameter 'namespace' when calling Core_v1Api->watchCoreV1NamespacedService")

    continue.map(paramVal => queryParams += "continue" -> paramVal.toString)
    fieldSelector.map(paramVal => queryParams += "fieldSelector" -> paramVal.toString)
    includeUninitialized.map(paramVal => queryParams += "includeUninitialized" -> paramVal.toString)
    labelSelector.map(paramVal => queryParams += "labelSelector" -> paramVal.toString)
    limit.map(paramVal => queryParams += "limit" -> paramVal.toString)
    pretty.map(paramVal => queryParams += "pretty" -> paramVal.toString)
    resourceVersion.map(paramVal => queryParams += "resourceVersion" -> paramVal.toString)
    timeoutSeconds.map(paramVal => queryParams += "timeoutSeconds" -> paramVal.toString)
    watch.map(paramVal => queryParams += "watch" -> paramVal.toString)
    

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "GET", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "", classOf[IoK8sApimachineryPkgApisMetaV1WatchEvent]).asInstanceOf[IoK8sApimachineryPkgApisMetaV1WatchEvent])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * 
   * watch changes to an object of kind ServiceAccount
   * @param name name of the ServiceAccount 
   * @param namespace object name and auth scope, such as for teams and projects 
   * @param continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. (optional)
   * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
   * @param includeUninitialized If true, partially initialized resources are included in the response. (optional)
   * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
   * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. (optional)
   * @param pretty If &#39;true&#39;, then the output is pretty printed. (optional)
   * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
   * @param timeoutSeconds Timeout for the list/watch call. (optional)
   * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
   * @return IoK8sApimachineryPkgApisMetaV1WatchEvent
   */
  def watchCoreV1NamespacedServiceAccount(name: String, namespace: String, continue: Option[String] = None, fieldSelector: Option[String] = None, includeUninitialized: Option[Boolean] = None, labelSelector: Option[String] = None, limit: Option[Integer] = None, pretty: Option[String] = None, resourceVersion: Option[String] = None, timeoutSeconds: Option[Integer] = None, watch: Option[Boolean] = None): Option[IoK8sApimachineryPkgApisMetaV1WatchEvent] = {
    // create path and map variables
    val path = "/api/v1/watch/namespaces/{namespace}/serviceaccounts/{name}".replaceAll("\\{format\\}", "json").replaceAll("\\{" + "name" + "\\}",apiInvoker.escape(name)).replaceAll("\\{" + "namespace" + "\\}",apiInvoker.escape(namespace))

    val contentTypes = List("*/*")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (name == null) throw new Exception("Missing required parameter 'name' when calling Core_v1Api->watchCoreV1NamespacedServiceAccount")

    if (namespace == null) throw new Exception("Missing required parameter 'namespace' when calling Core_v1Api->watchCoreV1NamespacedServiceAccount")

    continue.map(paramVal => queryParams += "continue" -> paramVal.toString)
    fieldSelector.map(paramVal => queryParams += "fieldSelector" -> paramVal.toString)
    includeUninitialized.map(paramVal => queryParams += "includeUninitialized" -> paramVal.toString)
    labelSelector.map(paramVal => queryParams += "labelSelector" -> paramVal.toString)
    limit.map(paramVal => queryParams += "limit" -> paramVal.toString)
    pretty.map(paramVal => queryParams += "pretty" -> paramVal.toString)
    resourceVersion.map(paramVal => queryParams += "resourceVersion" -> paramVal.toString)
    timeoutSeconds.map(paramVal => queryParams += "timeoutSeconds" -> paramVal.toString)
    watch.map(paramVal => queryParams += "watch" -> paramVal.toString)
    

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "GET", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "", classOf[IoK8sApimachineryPkgApisMetaV1WatchEvent]).asInstanceOf[IoK8sApimachineryPkgApisMetaV1WatchEvent])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * 
   * watch individual changes to a list of ServiceAccount
   * @param namespace object name and auth scope, such as for teams and projects 
   * @param continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. (optional)
   * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
   * @param includeUninitialized If true, partially initialized resources are included in the response. (optional)
   * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
   * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. (optional)
   * @param pretty If &#39;true&#39;, then the output is pretty printed. (optional)
   * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
   * @param timeoutSeconds Timeout for the list/watch call. (optional)
   * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
   * @return IoK8sApimachineryPkgApisMetaV1WatchEvent
   */
  def watchCoreV1NamespacedServiceAccountList(namespace: String, continue: Option[String] = None, fieldSelector: Option[String] = None, includeUninitialized: Option[Boolean] = None, labelSelector: Option[String] = None, limit: Option[Integer] = None, pretty: Option[String] = None, resourceVersion: Option[String] = None, timeoutSeconds: Option[Integer] = None, watch: Option[Boolean] = None): Option[IoK8sApimachineryPkgApisMetaV1WatchEvent] = {
    // create path and map variables
    val path = "/api/v1/watch/namespaces/{namespace}/serviceaccounts".replaceAll("\\{format\\}", "json").replaceAll("\\{" + "namespace" + "\\}",apiInvoker.escape(namespace))

    val contentTypes = List("*/*")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (namespace == null) throw new Exception("Missing required parameter 'namespace' when calling Core_v1Api->watchCoreV1NamespacedServiceAccountList")

    continue.map(paramVal => queryParams += "continue" -> paramVal.toString)
    fieldSelector.map(paramVal => queryParams += "fieldSelector" -> paramVal.toString)
    includeUninitialized.map(paramVal => queryParams += "includeUninitialized" -> paramVal.toString)
    labelSelector.map(paramVal => queryParams += "labelSelector" -> paramVal.toString)
    limit.map(paramVal => queryParams += "limit" -> paramVal.toString)
    pretty.map(paramVal => queryParams += "pretty" -> paramVal.toString)
    resourceVersion.map(paramVal => queryParams += "resourceVersion" -> paramVal.toString)
    timeoutSeconds.map(paramVal => queryParams += "timeoutSeconds" -> paramVal.toString)
    watch.map(paramVal => queryParams += "watch" -> paramVal.toString)
    

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "GET", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "", classOf[IoK8sApimachineryPkgApisMetaV1WatchEvent]).asInstanceOf[IoK8sApimachineryPkgApisMetaV1WatchEvent])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * 
   * watch individual changes to a list of Service
   * @param namespace object name and auth scope, such as for teams and projects 
   * @param continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. (optional)
   * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
   * @param includeUninitialized If true, partially initialized resources are included in the response. (optional)
   * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
   * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. (optional)
   * @param pretty If &#39;true&#39;, then the output is pretty printed. (optional)
   * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
   * @param timeoutSeconds Timeout for the list/watch call. (optional)
   * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
   * @return IoK8sApimachineryPkgApisMetaV1WatchEvent
   */
  def watchCoreV1NamespacedServiceList(namespace: String, continue: Option[String] = None, fieldSelector: Option[String] = None, includeUninitialized: Option[Boolean] = None, labelSelector: Option[String] = None, limit: Option[Integer] = None, pretty: Option[String] = None, resourceVersion: Option[String] = None, timeoutSeconds: Option[Integer] = None, watch: Option[Boolean] = None): Option[IoK8sApimachineryPkgApisMetaV1WatchEvent] = {
    // create path and map variables
    val path = "/api/v1/watch/namespaces/{namespace}/services".replaceAll("\\{format\\}", "json").replaceAll("\\{" + "namespace" + "\\}",apiInvoker.escape(namespace))

    val contentTypes = List("*/*")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (namespace == null) throw new Exception("Missing required parameter 'namespace' when calling Core_v1Api->watchCoreV1NamespacedServiceList")

    continue.map(paramVal => queryParams += "continue" -> paramVal.toString)
    fieldSelector.map(paramVal => queryParams += "fieldSelector" -> paramVal.toString)
    includeUninitialized.map(paramVal => queryParams += "includeUninitialized" -> paramVal.toString)
    labelSelector.map(paramVal => queryParams += "labelSelector" -> paramVal.toString)
    limit.map(paramVal => queryParams += "limit" -> paramVal.toString)
    pretty.map(paramVal => queryParams += "pretty" -> paramVal.toString)
    resourceVersion.map(paramVal => queryParams += "resourceVersion" -> paramVal.toString)
    timeoutSeconds.map(paramVal => queryParams += "timeoutSeconds" -> paramVal.toString)
    watch.map(paramVal => queryParams += "watch" -> paramVal.toString)
    

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "GET", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "", classOf[IoK8sApimachineryPkgApisMetaV1WatchEvent]).asInstanceOf[IoK8sApimachineryPkgApisMetaV1WatchEvent])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * 
   * watch changes to an object of kind Node
   * @param name name of the Node 
   * @param continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. (optional)
   * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
   * @param includeUninitialized If true, partially initialized resources are included in the response. (optional)
   * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
   * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. (optional)
   * @param pretty If &#39;true&#39;, then the output is pretty printed. (optional)
   * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
   * @param timeoutSeconds Timeout for the list/watch call. (optional)
   * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
   * @return IoK8sApimachineryPkgApisMetaV1WatchEvent
   */
  def watchCoreV1Node(name: String, continue: Option[String] = None, fieldSelector: Option[String] = None, includeUninitialized: Option[Boolean] = None, labelSelector: Option[String] = None, limit: Option[Integer] = None, pretty: Option[String] = None, resourceVersion: Option[String] = None, timeoutSeconds: Option[Integer] = None, watch: Option[Boolean] = None): Option[IoK8sApimachineryPkgApisMetaV1WatchEvent] = {
    // create path and map variables
    val path = "/api/v1/watch/nodes/{name}".replaceAll("\\{format\\}", "json").replaceAll("\\{" + "name" + "\\}",apiInvoker.escape(name))

    val contentTypes = List("*/*")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (name == null) throw new Exception("Missing required parameter 'name' when calling Core_v1Api->watchCoreV1Node")

    continue.map(paramVal => queryParams += "continue" -> paramVal.toString)
    fieldSelector.map(paramVal => queryParams += "fieldSelector" -> paramVal.toString)
    includeUninitialized.map(paramVal => queryParams += "includeUninitialized" -> paramVal.toString)
    labelSelector.map(paramVal => queryParams += "labelSelector" -> paramVal.toString)
    limit.map(paramVal => queryParams += "limit" -> paramVal.toString)
    pretty.map(paramVal => queryParams += "pretty" -> paramVal.toString)
    resourceVersion.map(paramVal => queryParams += "resourceVersion" -> paramVal.toString)
    timeoutSeconds.map(paramVal => queryParams += "timeoutSeconds" -> paramVal.toString)
    watch.map(paramVal => queryParams += "watch" -> paramVal.toString)
    

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "GET", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "", classOf[IoK8sApimachineryPkgApisMetaV1WatchEvent]).asInstanceOf[IoK8sApimachineryPkgApisMetaV1WatchEvent])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * 
   * watch individual changes to a list of Node
   * @param continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. (optional)
   * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
   * @param includeUninitialized If true, partially initialized resources are included in the response. (optional)
   * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
   * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. (optional)
   * @param pretty If &#39;true&#39;, then the output is pretty printed. (optional)
   * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
   * @param timeoutSeconds Timeout for the list/watch call. (optional)
   * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
   * @return IoK8sApimachineryPkgApisMetaV1WatchEvent
   */
  def watchCoreV1NodeList(continue: Option[String] = None, fieldSelector: Option[String] = None, includeUninitialized: Option[Boolean] = None, labelSelector: Option[String] = None, limit: Option[Integer] = None, pretty: Option[String] = None, resourceVersion: Option[String] = None, timeoutSeconds: Option[Integer] = None, watch: Option[Boolean] = None): Option[IoK8sApimachineryPkgApisMetaV1WatchEvent] = {
    // create path and map variables
    val path = "/api/v1/watch/nodes".replaceAll("\\{format\\}", "json")

    val contentTypes = List("*/*")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    continue.map(paramVal => queryParams += "continue" -> paramVal.toString)
    fieldSelector.map(paramVal => queryParams += "fieldSelector" -> paramVal.toString)
    includeUninitialized.map(paramVal => queryParams += "includeUninitialized" -> paramVal.toString)
    labelSelector.map(paramVal => queryParams += "labelSelector" -> paramVal.toString)
    limit.map(paramVal => queryParams += "limit" -> paramVal.toString)
    pretty.map(paramVal => queryParams += "pretty" -> paramVal.toString)
    resourceVersion.map(paramVal => queryParams += "resourceVersion" -> paramVal.toString)
    timeoutSeconds.map(paramVal => queryParams += "timeoutSeconds" -> paramVal.toString)
    watch.map(paramVal => queryParams += "watch" -> paramVal.toString)
    

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "GET", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "", classOf[IoK8sApimachineryPkgApisMetaV1WatchEvent]).asInstanceOf[IoK8sApimachineryPkgApisMetaV1WatchEvent])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * 
   * watch changes to an object of kind PersistentVolume
   * @param name name of the PersistentVolume 
   * @param continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. (optional)
   * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
   * @param includeUninitialized If true, partially initialized resources are included in the response. (optional)
   * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
   * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. (optional)
   * @param pretty If &#39;true&#39;, then the output is pretty printed. (optional)
   * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
   * @param timeoutSeconds Timeout for the list/watch call. (optional)
   * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
   * @return IoK8sApimachineryPkgApisMetaV1WatchEvent
   */
  def watchCoreV1PersistentVolume(name: String, continue: Option[String] = None, fieldSelector: Option[String] = None, includeUninitialized: Option[Boolean] = None, labelSelector: Option[String] = None, limit: Option[Integer] = None, pretty: Option[String] = None, resourceVersion: Option[String] = None, timeoutSeconds: Option[Integer] = None, watch: Option[Boolean] = None): Option[IoK8sApimachineryPkgApisMetaV1WatchEvent] = {
    // create path and map variables
    val path = "/api/v1/watch/persistentvolumes/{name}".replaceAll("\\{format\\}", "json").replaceAll("\\{" + "name" + "\\}",apiInvoker.escape(name))

    val contentTypes = List("*/*")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (name == null) throw new Exception("Missing required parameter 'name' when calling Core_v1Api->watchCoreV1PersistentVolume")

    continue.map(paramVal => queryParams += "continue" -> paramVal.toString)
    fieldSelector.map(paramVal => queryParams += "fieldSelector" -> paramVal.toString)
    includeUninitialized.map(paramVal => queryParams += "includeUninitialized" -> paramVal.toString)
    labelSelector.map(paramVal => queryParams += "labelSelector" -> paramVal.toString)
    limit.map(paramVal => queryParams += "limit" -> paramVal.toString)
    pretty.map(paramVal => queryParams += "pretty" -> paramVal.toString)
    resourceVersion.map(paramVal => queryParams += "resourceVersion" -> paramVal.toString)
    timeoutSeconds.map(paramVal => queryParams += "timeoutSeconds" -> paramVal.toString)
    watch.map(paramVal => queryParams += "watch" -> paramVal.toString)
    

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "GET", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "", classOf[IoK8sApimachineryPkgApisMetaV1WatchEvent]).asInstanceOf[IoK8sApimachineryPkgApisMetaV1WatchEvent])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * 
   * watch individual changes to a list of PersistentVolumeClaim
   * @param continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. (optional)
   * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
   * @param includeUninitialized If true, partially initialized resources are included in the response. (optional)
   * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
   * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. (optional)
   * @param pretty If &#39;true&#39;, then the output is pretty printed. (optional)
   * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
   * @param timeoutSeconds Timeout for the list/watch call. (optional)
   * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
   * @return IoK8sApimachineryPkgApisMetaV1WatchEvent
   */
  def watchCoreV1PersistentVolumeClaimListForAllNamespaces(continue: Option[String] = None, fieldSelector: Option[String] = None, includeUninitialized: Option[Boolean] = None, labelSelector: Option[String] = None, limit: Option[Integer] = None, pretty: Option[String] = None, resourceVersion: Option[String] = None, timeoutSeconds: Option[Integer] = None, watch: Option[Boolean] = None): Option[IoK8sApimachineryPkgApisMetaV1WatchEvent] = {
    // create path and map variables
    val path = "/api/v1/watch/persistentvolumeclaims".replaceAll("\\{format\\}", "json")

    val contentTypes = List("*/*")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    continue.map(paramVal => queryParams += "continue" -> paramVal.toString)
    fieldSelector.map(paramVal => queryParams += "fieldSelector" -> paramVal.toString)
    includeUninitialized.map(paramVal => queryParams += "includeUninitialized" -> paramVal.toString)
    labelSelector.map(paramVal => queryParams += "labelSelector" -> paramVal.toString)
    limit.map(paramVal => queryParams += "limit" -> paramVal.toString)
    pretty.map(paramVal => queryParams += "pretty" -> paramVal.toString)
    resourceVersion.map(paramVal => queryParams += "resourceVersion" -> paramVal.toString)
    timeoutSeconds.map(paramVal => queryParams += "timeoutSeconds" -> paramVal.toString)
    watch.map(paramVal => queryParams += "watch" -> paramVal.toString)
    

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "GET", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "", classOf[IoK8sApimachineryPkgApisMetaV1WatchEvent]).asInstanceOf[IoK8sApimachineryPkgApisMetaV1WatchEvent])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * 
   * watch individual changes to a list of PersistentVolume
   * @param continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. (optional)
   * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
   * @param includeUninitialized If true, partially initialized resources are included in the response. (optional)
   * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
   * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. (optional)
   * @param pretty If &#39;true&#39;, then the output is pretty printed. (optional)
   * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
   * @param timeoutSeconds Timeout for the list/watch call. (optional)
   * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
   * @return IoK8sApimachineryPkgApisMetaV1WatchEvent
   */
  def watchCoreV1PersistentVolumeList(continue: Option[String] = None, fieldSelector: Option[String] = None, includeUninitialized: Option[Boolean] = None, labelSelector: Option[String] = None, limit: Option[Integer] = None, pretty: Option[String] = None, resourceVersion: Option[String] = None, timeoutSeconds: Option[Integer] = None, watch: Option[Boolean] = None): Option[IoK8sApimachineryPkgApisMetaV1WatchEvent] = {
    // create path and map variables
    val path = "/api/v1/watch/persistentvolumes".replaceAll("\\{format\\}", "json")

    val contentTypes = List("*/*")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    continue.map(paramVal => queryParams += "continue" -> paramVal.toString)
    fieldSelector.map(paramVal => queryParams += "fieldSelector" -> paramVal.toString)
    includeUninitialized.map(paramVal => queryParams += "includeUninitialized" -> paramVal.toString)
    labelSelector.map(paramVal => queryParams += "labelSelector" -> paramVal.toString)
    limit.map(paramVal => queryParams += "limit" -> paramVal.toString)
    pretty.map(paramVal => queryParams += "pretty" -> paramVal.toString)
    resourceVersion.map(paramVal => queryParams += "resourceVersion" -> paramVal.toString)
    timeoutSeconds.map(paramVal => queryParams += "timeoutSeconds" -> paramVal.toString)
    watch.map(paramVal => queryParams += "watch" -> paramVal.toString)
    

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "GET", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "", classOf[IoK8sApimachineryPkgApisMetaV1WatchEvent]).asInstanceOf[IoK8sApimachineryPkgApisMetaV1WatchEvent])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * 
   * watch individual changes to a list of Pod
   * @param continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. (optional)
   * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
   * @param includeUninitialized If true, partially initialized resources are included in the response. (optional)
   * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
   * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. (optional)
   * @param pretty If &#39;true&#39;, then the output is pretty printed. (optional)
   * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
   * @param timeoutSeconds Timeout for the list/watch call. (optional)
   * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
   * @return IoK8sApimachineryPkgApisMetaV1WatchEvent
   */
  def watchCoreV1PodListForAllNamespaces(continue: Option[String] = None, fieldSelector: Option[String] = None, includeUninitialized: Option[Boolean] = None, labelSelector: Option[String] = None, limit: Option[Integer] = None, pretty: Option[String] = None, resourceVersion: Option[String] = None, timeoutSeconds: Option[Integer] = None, watch: Option[Boolean] = None): Option[IoK8sApimachineryPkgApisMetaV1WatchEvent] = {
    // create path and map variables
    val path = "/api/v1/watch/pods".replaceAll("\\{format\\}", "json")

    val contentTypes = List("*/*")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    continue.map(paramVal => queryParams += "continue" -> paramVal.toString)
    fieldSelector.map(paramVal => queryParams += "fieldSelector" -> paramVal.toString)
    includeUninitialized.map(paramVal => queryParams += "includeUninitialized" -> paramVal.toString)
    labelSelector.map(paramVal => queryParams += "labelSelector" -> paramVal.toString)
    limit.map(paramVal => queryParams += "limit" -> paramVal.toString)
    pretty.map(paramVal => queryParams += "pretty" -> paramVal.toString)
    resourceVersion.map(paramVal => queryParams += "resourceVersion" -> paramVal.toString)
    timeoutSeconds.map(paramVal => queryParams += "timeoutSeconds" -> paramVal.toString)
    watch.map(paramVal => queryParams += "watch" -> paramVal.toString)
    

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "GET", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "", classOf[IoK8sApimachineryPkgApisMetaV1WatchEvent]).asInstanceOf[IoK8sApimachineryPkgApisMetaV1WatchEvent])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * 
   * watch individual changes to a list of PodTemplate
   * @param continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. (optional)
   * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
   * @param includeUninitialized If true, partially initialized resources are included in the response. (optional)
   * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
   * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. (optional)
   * @param pretty If &#39;true&#39;, then the output is pretty printed. (optional)
   * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
   * @param timeoutSeconds Timeout for the list/watch call. (optional)
   * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
   * @return IoK8sApimachineryPkgApisMetaV1WatchEvent
   */
  def watchCoreV1PodTemplateListForAllNamespaces(continue: Option[String] = None, fieldSelector: Option[String] = None, includeUninitialized: Option[Boolean] = None, labelSelector: Option[String] = None, limit: Option[Integer] = None, pretty: Option[String] = None, resourceVersion: Option[String] = None, timeoutSeconds: Option[Integer] = None, watch: Option[Boolean] = None): Option[IoK8sApimachineryPkgApisMetaV1WatchEvent] = {
    // create path and map variables
    val path = "/api/v1/watch/podtemplates".replaceAll("\\{format\\}", "json")

    val contentTypes = List("*/*")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    continue.map(paramVal => queryParams += "continue" -> paramVal.toString)
    fieldSelector.map(paramVal => queryParams += "fieldSelector" -> paramVal.toString)
    includeUninitialized.map(paramVal => queryParams += "includeUninitialized" -> paramVal.toString)
    labelSelector.map(paramVal => queryParams += "labelSelector" -> paramVal.toString)
    limit.map(paramVal => queryParams += "limit" -> paramVal.toString)
    pretty.map(paramVal => queryParams += "pretty" -> paramVal.toString)
    resourceVersion.map(paramVal => queryParams += "resourceVersion" -> paramVal.toString)
    timeoutSeconds.map(paramVal => queryParams += "timeoutSeconds" -> paramVal.toString)
    watch.map(paramVal => queryParams += "watch" -> paramVal.toString)
    

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "GET", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "", classOf[IoK8sApimachineryPkgApisMetaV1WatchEvent]).asInstanceOf[IoK8sApimachineryPkgApisMetaV1WatchEvent])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * 
   * watch individual changes to a list of ReplicationController
   * @param continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. (optional)
   * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
   * @param includeUninitialized If true, partially initialized resources are included in the response. (optional)
   * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
   * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. (optional)
   * @param pretty If &#39;true&#39;, then the output is pretty printed. (optional)
   * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
   * @param timeoutSeconds Timeout for the list/watch call. (optional)
   * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
   * @return IoK8sApimachineryPkgApisMetaV1WatchEvent
   */
  def watchCoreV1ReplicationControllerListForAllNamespaces(continue: Option[String] = None, fieldSelector: Option[String] = None, includeUninitialized: Option[Boolean] = None, labelSelector: Option[String] = None, limit: Option[Integer] = None, pretty: Option[String] = None, resourceVersion: Option[String] = None, timeoutSeconds: Option[Integer] = None, watch: Option[Boolean] = None): Option[IoK8sApimachineryPkgApisMetaV1WatchEvent] = {
    // create path and map variables
    val path = "/api/v1/watch/replicationcontrollers".replaceAll("\\{format\\}", "json")

    val contentTypes = List("*/*")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    continue.map(paramVal => queryParams += "continue" -> paramVal.toString)
    fieldSelector.map(paramVal => queryParams += "fieldSelector" -> paramVal.toString)
    includeUninitialized.map(paramVal => queryParams += "includeUninitialized" -> paramVal.toString)
    labelSelector.map(paramVal => queryParams += "labelSelector" -> paramVal.toString)
    limit.map(paramVal => queryParams += "limit" -> paramVal.toString)
    pretty.map(paramVal => queryParams += "pretty" -> paramVal.toString)
    resourceVersion.map(paramVal => queryParams += "resourceVersion" -> paramVal.toString)
    timeoutSeconds.map(paramVal => queryParams += "timeoutSeconds" -> paramVal.toString)
    watch.map(paramVal => queryParams += "watch" -> paramVal.toString)
    

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "GET", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "", classOf[IoK8sApimachineryPkgApisMetaV1WatchEvent]).asInstanceOf[IoK8sApimachineryPkgApisMetaV1WatchEvent])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * 
   * watch individual changes to a list of ResourceQuota
   * @param continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. (optional)
   * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
   * @param includeUninitialized If true, partially initialized resources are included in the response. (optional)
   * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
   * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. (optional)
   * @param pretty If &#39;true&#39;, then the output is pretty printed. (optional)
   * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
   * @param timeoutSeconds Timeout for the list/watch call. (optional)
   * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
   * @return IoK8sApimachineryPkgApisMetaV1WatchEvent
   */
  def watchCoreV1ResourceQuotaListForAllNamespaces(continue: Option[String] = None, fieldSelector: Option[String] = None, includeUninitialized: Option[Boolean] = None, labelSelector: Option[String] = None, limit: Option[Integer] = None, pretty: Option[String] = None, resourceVersion: Option[String] = None, timeoutSeconds: Option[Integer] = None, watch: Option[Boolean] = None): Option[IoK8sApimachineryPkgApisMetaV1WatchEvent] = {
    // create path and map variables
    val path = "/api/v1/watch/resourcequotas".replaceAll("\\{format\\}", "json")

    val contentTypes = List("*/*")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    continue.map(paramVal => queryParams += "continue" -> paramVal.toString)
    fieldSelector.map(paramVal => queryParams += "fieldSelector" -> paramVal.toString)
    includeUninitialized.map(paramVal => queryParams += "includeUninitialized" -> paramVal.toString)
    labelSelector.map(paramVal => queryParams += "labelSelector" -> paramVal.toString)
    limit.map(paramVal => queryParams += "limit" -> paramVal.toString)
    pretty.map(paramVal => queryParams += "pretty" -> paramVal.toString)
    resourceVersion.map(paramVal => queryParams += "resourceVersion" -> paramVal.toString)
    timeoutSeconds.map(paramVal => queryParams += "timeoutSeconds" -> paramVal.toString)
    watch.map(paramVal => queryParams += "watch" -> paramVal.toString)
    

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "GET", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "", classOf[IoK8sApimachineryPkgApisMetaV1WatchEvent]).asInstanceOf[IoK8sApimachineryPkgApisMetaV1WatchEvent])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * 
   * watch individual changes to a list of Secret
   * @param continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. (optional)
   * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
   * @param includeUninitialized If true, partially initialized resources are included in the response. (optional)
   * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
   * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. (optional)
   * @param pretty If &#39;true&#39;, then the output is pretty printed. (optional)
   * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
   * @param timeoutSeconds Timeout for the list/watch call. (optional)
   * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
   * @return IoK8sApimachineryPkgApisMetaV1WatchEvent
   */
  def watchCoreV1SecretListForAllNamespaces(continue: Option[String] = None, fieldSelector: Option[String] = None, includeUninitialized: Option[Boolean] = None, labelSelector: Option[String] = None, limit: Option[Integer] = None, pretty: Option[String] = None, resourceVersion: Option[String] = None, timeoutSeconds: Option[Integer] = None, watch: Option[Boolean] = None): Option[IoK8sApimachineryPkgApisMetaV1WatchEvent] = {
    // create path and map variables
    val path = "/api/v1/watch/secrets".replaceAll("\\{format\\}", "json")

    val contentTypes = List("*/*")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    continue.map(paramVal => queryParams += "continue" -> paramVal.toString)
    fieldSelector.map(paramVal => queryParams += "fieldSelector" -> paramVal.toString)
    includeUninitialized.map(paramVal => queryParams += "includeUninitialized" -> paramVal.toString)
    labelSelector.map(paramVal => queryParams += "labelSelector" -> paramVal.toString)
    limit.map(paramVal => queryParams += "limit" -> paramVal.toString)
    pretty.map(paramVal => queryParams += "pretty" -> paramVal.toString)
    resourceVersion.map(paramVal => queryParams += "resourceVersion" -> paramVal.toString)
    timeoutSeconds.map(paramVal => queryParams += "timeoutSeconds" -> paramVal.toString)
    watch.map(paramVal => queryParams += "watch" -> paramVal.toString)
    

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "GET", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "", classOf[IoK8sApimachineryPkgApisMetaV1WatchEvent]).asInstanceOf[IoK8sApimachineryPkgApisMetaV1WatchEvent])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * 
   * watch individual changes to a list of ServiceAccount
   * @param continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. (optional)
   * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
   * @param includeUninitialized If true, partially initialized resources are included in the response. (optional)
   * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
   * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. (optional)
   * @param pretty If &#39;true&#39;, then the output is pretty printed. (optional)
   * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
   * @param timeoutSeconds Timeout for the list/watch call. (optional)
   * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
   * @return IoK8sApimachineryPkgApisMetaV1WatchEvent
   */
  def watchCoreV1ServiceAccountListForAllNamespaces(continue: Option[String] = None, fieldSelector: Option[String] = None, includeUninitialized: Option[Boolean] = None, labelSelector: Option[String] = None, limit: Option[Integer] = None, pretty: Option[String] = None, resourceVersion: Option[String] = None, timeoutSeconds: Option[Integer] = None, watch: Option[Boolean] = None): Option[IoK8sApimachineryPkgApisMetaV1WatchEvent] = {
    // create path and map variables
    val path = "/api/v1/watch/serviceaccounts".replaceAll("\\{format\\}", "json")

    val contentTypes = List("*/*")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    continue.map(paramVal => queryParams += "continue" -> paramVal.toString)
    fieldSelector.map(paramVal => queryParams += "fieldSelector" -> paramVal.toString)
    includeUninitialized.map(paramVal => queryParams += "includeUninitialized" -> paramVal.toString)
    labelSelector.map(paramVal => queryParams += "labelSelector" -> paramVal.toString)
    limit.map(paramVal => queryParams += "limit" -> paramVal.toString)
    pretty.map(paramVal => queryParams += "pretty" -> paramVal.toString)
    resourceVersion.map(paramVal => queryParams += "resourceVersion" -> paramVal.toString)
    timeoutSeconds.map(paramVal => queryParams += "timeoutSeconds" -> paramVal.toString)
    watch.map(paramVal => queryParams += "watch" -> paramVal.toString)
    

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "GET", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "", classOf[IoK8sApimachineryPkgApisMetaV1WatchEvent]).asInstanceOf[IoK8sApimachineryPkgApisMetaV1WatchEvent])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * 
   * watch individual changes to a list of Service
   * @param continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. (optional)
   * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)
   * @param includeUninitialized If true, partially initialized resources are included in the response. (optional)
   * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)
   * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. (optional)
   * @param pretty If &#39;true&#39;, then the output is pretty printed. (optional)
   * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)
   * @param timeoutSeconds Timeout for the list/watch call. (optional)
   * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion. (optional)
   * @return IoK8sApimachineryPkgApisMetaV1WatchEvent
   */
  def watchCoreV1ServiceListForAllNamespaces(continue: Option[String] = None, fieldSelector: Option[String] = None, includeUninitialized: Option[Boolean] = None, labelSelector: Option[String] = None, limit: Option[Integer] = None, pretty: Option[String] = None, resourceVersion: Option[String] = None, timeoutSeconds: Option[Integer] = None, watch: Option[Boolean] = None): Option[IoK8sApimachineryPkgApisMetaV1WatchEvent] = {
    // create path and map variables
    val path = "/api/v1/watch/services".replaceAll("\\{format\\}", "json")

    val contentTypes = List("*/*")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    continue.map(paramVal => queryParams += "continue" -> paramVal.toString)
    fieldSelector.map(paramVal => queryParams += "fieldSelector" -> paramVal.toString)
    includeUninitialized.map(paramVal => queryParams += "includeUninitialized" -> paramVal.toString)
    labelSelector.map(paramVal => queryParams += "labelSelector" -> paramVal.toString)
    limit.map(paramVal => queryParams += "limit" -> paramVal.toString)
    pretty.map(paramVal => queryParams += "pretty" -> paramVal.toString)
    resourceVersion.map(paramVal => queryParams += "resourceVersion" -> paramVal.toString)
    timeoutSeconds.map(paramVal => queryParams += "timeoutSeconds" -> paramVal.toString)
    watch.map(paramVal => queryParams += "watch" -> paramVal.toString)
    

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "GET", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "", classOf[IoK8sApimachineryPkgApisMetaV1WatchEvent]).asInstanceOf[IoK8sApimachineryPkgApisMetaV1WatchEvent])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

}
